[
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "generate_color",
        "importPath": "helpers",
        "description": "helpers",
        "isExtraImport": true,
        "detail": "helpers",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "DataFrame",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "DataFrame",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "Explorer",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "SAM",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOWorld",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "Explorer",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "download",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "RTDETR",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "Explorer",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "SAM",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOWorld",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics",
        "description": "ultralytics",
        "isExtraImport": true,
        "detail": "ultralytics",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "IterableSimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "USER_CONFIG_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOCAL_RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOCAL_RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_dir_writeable",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_kaggle",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DATASETS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS_YAML",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ARM64",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "get_default_args",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleClass",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "remove_colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_print",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ONLINE",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "get_git_origin_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_git_dir",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_pip_package",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ARM64",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_KEYS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "IterableSimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RUNS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "AUTOINSTALL",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ONLINE",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "USER_CONFIG_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ThreadingLocked",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "downloads",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_docker",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_github_action_running",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_jupyter",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_kaggle",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_online",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_pip_package",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "url2file",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_online",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "url2file",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleClass",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "plt_settings",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "plt_settings",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "threaded",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_KEYS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DATASETS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_PATH",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ONLINE",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "Retry",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_dir_writeable",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "IterableSimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "USER_CONFIG_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOCAL_RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOCAL_RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_dir_writeable",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_kaggle",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DATASETS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS_YAML",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ARM64",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "get_default_args",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleClass",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "remove_colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_print",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_save",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ONLINE",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "get_git_origin_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_git_dir",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_pip_package",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ARM64",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_KEYS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "IterableSimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "yaml_load",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RANK",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "RUNS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SETTINGS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TESTS_RUNNING",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "MACOS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "WEIGHTS_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ASSETS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "AUTOINSTALL",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LINUX",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ONLINE",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "USER_CONFIG_DIR",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ThreadingLocked",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "colorstr",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "downloads",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_colab",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_docker",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_github_action_running",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_jupyter",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_kaggle",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_online",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_pip_package",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "url2file",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "clean_url",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "is_online",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "url2file",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "emojis",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "SimpleClass",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "plt_settings",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "TryExcept",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "ops",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "plt_settings",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "threaded",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_KEYS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CFG_DICT",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "NUM_THREADS",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "checks",
        "importPath": "ultralytics.utils",
        "description": "ultralytics.utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_font",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "is_ascii",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_is_path_safe",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_amp",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_model_file_from_stem",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "print_args",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "IS_PYTHON_3_12",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolo",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_font",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "is_ascii",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_is_path_safe",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_amp",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_model_file_from_stem",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "print_args",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "IS_PYTHON_3_12",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolo",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "importPath": "ultralytics.utils.checks",
        "description": "ultralytics.utils.checks",
        "isExtraImport": true,
        "detail": "ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "image_select",
        "importPath": "streamlit_select",
        "description": "streamlit_select",
        "isExtraImport": true,
        "detail": "streamlit_select",
        "documentation": {}
    },
    {
        "label": "image_select",
        "importPath": "streamlit_select",
        "description": "streamlit_select",
        "isExtraImport": true,
        "detail": "streamlit_select",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "distributed",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "optim",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "distributed",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "optim",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "PIL",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PIL",
        "description": "PIL",
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageOps",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageOps",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "font_manager",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "font_manager",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "Format",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_transforms",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Compose",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Format",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "v8_transforms",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Format",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_transforms",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Compose",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Format",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "v8_transforms",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "importPath": "ultralytics.data.augment",
        "description": "ultralytics.data.augment",
        "isExtraImport": true,
        "detail": "ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data.dataset",
        "description": "ultralytics.data.dataset",
        "isExtraImport": true,
        "detail": "ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data.dataset",
        "description": "ultralytics.data.dataset",
        "isExtraImport": true,
        "detail": "ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data.dataset",
        "description": "ultralytics.data.dataset",
        "isExtraImport": true,
        "detail": "ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data.dataset",
        "description": "ultralytics.data.dataset",
        "isExtraImport": true,
        "detail": "ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "exif_size",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "img2label_paths",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "exif_size",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "img2label_paths",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "importPath": "ultralytics.data.utils",
        "description": "ultralytics.data.utils",
        "isExtraImport": true,
        "detail": "ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics.models.yolo.model",
        "description": "ultralytics.models.yolo.model",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "importPath": "ultralytics.models.yolo.model",
        "description": "ultralytics.models.yolo.model",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "getpass",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getpass",
        "description": "getpass",
        "detail": "getpass",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segment2box",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxyxyxy2xywhr",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "resample_segments",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segments2boxes",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "Profile",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "Profile",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "crop_mask",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segment2box",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxyxyxy2xywhr",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "resample_segments",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segments2boxes",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "Profile",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "Profile",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "crop_mask",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "importPath": "ultralytics.utils.ops",
        "description": "ultralytics.utils.ops",
        "isExtraImport": true,
        "detail": "ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "save_one_box",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_tune_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_labels",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_rotated_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "feature_visualization",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "save_one_box",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_tune_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_labels",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_rotated_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "feature_visualization",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "ultralytics.utils.plotting",
        "description": "ultralytics.utils.plotting",
        "isExtraImport": true,
        "detail": "ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "torchvision.transforms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.transforms",
        "description": "torchvision.transforms",
        "detail": "torchvision.transforms",
        "documentation": {}
    },
    {
        "label": "ToTensor",
        "importPath": "torchvision.transforms",
        "description": "torchvision.transforms",
        "isExtraImport": true,
        "detail": "torchvision.transforms",
        "documentation": {}
    },
    {
        "label": "Instances",
        "importPath": "ultralytics.utils.instance",
        "description": "ultralytics.utils.instance",
        "isExtraImport": true,
        "detail": "ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_2tuple",
        "importPath": "ultralytics.utils.instance",
        "description": "ultralytics.utils.instance",
        "isExtraImport": true,
        "detail": "ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "Instances",
        "importPath": "ultralytics.utils.instance",
        "description": "ultralytics.utils.instance",
        "isExtraImport": true,
        "detail": "ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_2tuple",
        "importPath": "ultralytics.utils.instance",
        "description": "ultralytics.utils.instance",
        "isExtraImport": true,
        "detail": "ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ClassifyMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "DetMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OBBMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "PoseMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "kpt_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "mask_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ClassifyMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "DetMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OBBMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "PoseMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "kpt_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "mask_iou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "importPath": "ultralytics.utils.metrics",
        "description": "ultralytics.utils.metrics",
        "isExtraImport": true,
        "detail": "ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_10",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_11",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_13",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_13",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_opset",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "EarlyStopping",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "ModelEMA",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_seeds",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "one_cycle",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "is_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_deconv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "initialize_weights",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "intersect_dicts",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "scale_img",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "time_sync",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info_for_loggers",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "profile",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_9",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_13",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_10",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_11",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_13",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_13",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_opset",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "EarlyStopping",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "ModelEMA",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_seeds",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "one_cycle",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "is_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_deconv_and_bn",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "initialize_weights",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "intersect_dicts",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "scale_img",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "time_sync",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info_for_loggers",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "profile",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "importPath": "ultralytics.utils.torch_utils",
        "description": "ultralytics.utils.torch_utils",
        "isExtraImport": true,
        "detail": "ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "dataloader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "distributed",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "dataloader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "distributed",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "LOADERS",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadImagesAndVideos",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadPilAndNumpy",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadScreenshots",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadStreams",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadTensor",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "SourceTypes",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "autocast_list",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LOADERS",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadImagesAndVideos",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadPilAndNumpy",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadScreenshots",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadStreams",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadTensor",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "SourceTypes",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "autocast_list",
        "importPath": "ultralytics.data.loaders",
        "description": "ultralytics.data.loaders",
        "isExtraImport": true,
        "detail": "ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "abc",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "abc",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "spaces_in_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "get_latest_run",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "spaces_in_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "get_latest_run",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "importPath": "ultralytics.utils.files",
        "description": "ultralytics.utils.files",
        "isExtraImport": true,
        "detail": "ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "torchvision",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision",
        "description": "torchvision",
        "detail": "torchvision",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlsplit",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlsplit",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "LineString",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "LineString",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "LineString",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "LineString",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "Polygon",
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "isExtraImport": true,
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "is_tarfile",
        "importPath": "tarfile",
        "description": "tarfile",
        "isExtraImport": true,
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "is_tarfile",
        "importPath": "tarfile",
        "description": "tarfile",
        "isExtraImport": true,
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "default_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "default_class_names",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "importPath": "ultralytics.nn.autobackend",
        "description": "ultralytics.nn.autobackend",
        "isExtraImport": true,
        "detail": "ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "download",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "safe_download",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "unzip_file",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_github_assets",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_NAMES",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "is_url",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "download",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "download",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "safe_download",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "unzip_file",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_github_assets",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_NAMES",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "is_url",
        "importPath": "ultralytics.utils.downloads",
        "description": "ultralytics.utils.downloads",
        "isExtraImport": true,
        "detail": "ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2METRIC",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2METRIC",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_cfg",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2METRIC",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2DATA",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "TASK2METRIC",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "get_save_dir",
        "importPath": "ultralytics.cfg",
        "description": "ultralytics.cfg",
        "isExtraImport": true,
        "detail": "ultralytics.cfg",
        "documentation": {}
    },
    {
        "label": "C2f",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "AIFI",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C1",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3TR",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "OBB",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPP",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPPF",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "BottleneckCSP",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2f",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2fAttn",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ImagePoolingAttn",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3Ghost",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3x",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Classify",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Concat",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Conv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Conv2",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ConvTranspose",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "DWConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "DWConvTranspose2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Focus",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "GhostBottleneck",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "GhostConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "HGBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "HGStem",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepC3",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ResNetLayer",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "WorldDetect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepNCSPELAN4",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ADown",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPPELAN",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "CBFuse",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "CBLinear",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Silence",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2fCIB",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "PSA",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SCDown",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepVGGDW",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2f",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "AIFI",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C1",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3TR",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "OBB",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPP",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPPF",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "BottleneckCSP",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2f",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2fAttn",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ImagePoolingAttn",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3Ghost",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C3x",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Classify",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Concat",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Conv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Conv2",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ConvTranspose",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "DWConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "DWConvTranspose2d",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Focus",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "GhostBottleneck",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "GhostConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "HGBlock",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "HGStem",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepC3",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepConv",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ResNetLayer",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Segment",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "WorldDetect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepNCSPELAN4",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "ADown",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SPPELAN",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "CBFuse",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "CBLinear",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "Silence",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "C2fCIB",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "PSA",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "SCDown",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "RepVGGDW",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "importPath": "ultralytics.nn.modules",
        "description": "ultralytics.nn.modules",
        "isExtraImport": true,
        "detail": "ultralytics.nn.modules",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_task",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "yaml_model_load",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_weights",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_task",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "yaml_model_load",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_weights",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionModel",
        "importPath": "ultralytics.nn.tasks",
        "description": "ultralytics.nn.tasks",
        "isExtraImport": true,
        "detail": "ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_API_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "request_with_credentials",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HELP_MSG",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "events",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_API_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "request_with_credentials",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HELP_MSG",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "TQDM",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "events",
        "importPath": "ultralytics.hub.utils",
        "description": "ultralytics.hub.utils",
        "isExtraImport": true,
        "detail": "ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "load_inference_source",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "converter",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "load_inference_source",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "converter",
        "importPath": "ultralytics.data",
        "description": "ultralytics.data",
        "isExtraImport": true,
        "detail": "ultralytics.data",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "check_train_batch_size",
        "importPath": "ultralytics.utils.autobatch",
        "description": "ultralytics.utils.autobatch",
        "isExtraImport": true,
        "detail": "ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "check_train_batch_size",
        "importPath": "ultralytics.utils.autobatch",
        "description": "ultralytics.utils.autobatch",
        "isExtraImport": true,
        "detail": "ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "ddp_cleanup",
        "importPath": "ultralytics.utils.dist",
        "description": "ultralytics.utils.dist",
        "isExtraImport": true,
        "detail": "ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_command",
        "importPath": "ultralytics.utils.dist",
        "description": "ultralytics.utils.dist",
        "isExtraImport": true,
        "detail": "ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "ddp_cleanup",
        "importPath": "ultralytics.utils.dist",
        "description": "ultralytics.utils.dist",
        "isExtraImport": true,
        "detail": "ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_command",
        "importPath": "ultralytics.utils.dist",
        "description": "ultralytics.utils.dist",
        "isExtraImport": true,
        "detail": "ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "HTTPStatus",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "HTTPStatus",
        "importPath": "http",
        "description": "http",
        "isExtraImport": true,
        "detail": "http",
        "documentation": {}
    },
    {
        "label": "HUBModelError",
        "importPath": "ultralytics.utils.errors",
        "description": "ultralytics.utils.errors",
        "isExtraImport": true,
        "detail": "ultralytics.utils.errors",
        "documentation": {}
    },
    {
        "label": "HUBModelError",
        "importPath": "ultralytics.utils.errors",
        "description": "ultralytics.utils.errors",
        "isExtraImport": true,
        "detail": "ultralytics.utils.errors",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "ultralytics.engine.model",
        "description": "ultralytics.engine.model",
        "isExtraImport": true,
        "detail": "ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "importPath": "ultralytics.engine.results",
        "description": "ultralytics.engine.results",
        "isExtraImport": true,
        "detail": "ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.models.fastsam.utils",
        "description": "ultralytics.models.fastsam.utils",
        "isExtraImport": true,
        "detail": "ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "importPath": "ultralytics.models.fastsam.utils",
        "description": "ultralytics.models.fastsam.utils",
        "isExtraImport": true,
        "detail": "ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect.predict",
        "description": "ultralytics.models.yolo.detect.predict",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "SegmentationValidator",
        "importPath": "ultralytics.models.yolo.segment",
        "description": "ultralytics.models.yolo.segment",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.segment",
        "documentation": {}
    },
    {
        "label": "SegmentationValidator",
        "importPath": "ultralytics.models.yolo.segment",
        "description": "ultralytics.models.yolo.segment",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.segment",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "ultralytics.engine.predictor",
        "description": "ultralytics.engine.predictor",
        "isExtraImport": true,
        "detail": "ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "importPath": "ultralytics.models.yolo.detect",
        "description": "ultralytics.models.yolo.detect",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo.detect",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "torch.utils.checkpoint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.utils.checkpoint",
        "description": "torch.utils.checkpoint",
        "detail": "torch.utils.checkpoint",
        "documentation": {}
    },
    {
        "label": "FocalLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "VarifocalLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8ClassificationLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8DetectionLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8OBBLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8PoseLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8SegmentationLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v10DetectLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "FocalLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "VarifocalLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8ClassificationLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8DetectionLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8OBBLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8PoseLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8SegmentationLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v10DetectLoss",
        "importPath": "ultralytics.utils.loss",
        "description": "ultralytics.utils.loss",
        "isExtraImport": true,
        "detail": "ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "linear_sum_assignment",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "linear_sum_assignment",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "importPath": "ultralytics.engine.trainer",
        "description": "ultralytics.engine.trainer",
        "isExtraImport": true,
        "detail": "ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "importPath": "ultralytics.engine.trainer",
        "description": "ultralytics.engine.trainer",
        "isExtraImport": true,
        "detail": "ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "importPath": "ultralytics.engine.trainer",
        "description": "ultralytics.engine.trainer",
        "isExtraImport": true,
        "detail": "ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "importPath": "ultralytics.engine.trainer",
        "description": "ultralytics.engine.trainer",
        "isExtraImport": true,
        "detail": "ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "yolo",
        "importPath": "ultralytics.models",
        "description": "ultralytics.models",
        "isExtraImport": true,
        "detail": "ultralytics.models",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "importPath": "ultralytics.engine.validator",
        "description": "ultralytics.engine.validator",
        "isExtraImport": true,
        "detail": "ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "importPath": "ultralytics.engine.validator",
        "description": "ultralytics.engine.validator",
        "isExtraImport": true,
        "detail": "ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "importPath": "ultralytics.engine.validator",
        "description": "ultralytics.engine.validator",
        "isExtraImport": true,
        "detail": "ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "importPath": "ultralytics.engine.validator",
        "description": "ultralytics.engine.validator",
        "isExtraImport": true,
        "detail": "ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "PyTorchModelHubMixin",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "PyTorchModelHubMixin",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "constant_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "xavier_uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "constant_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "xavier_uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "constant_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "xavier_uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "constant_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "xavier_uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "uniform_",
        "importPath": "torch.nn.init",
        "description": "torch.nn.init",
        "isExtraImport": true,
        "detail": "torch.nn.init",
        "documentation": {}
    },
    {
        "label": "TORCH_1_10",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "RotatedTaskAlignedAssigner",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "TaskAlignedAssigner",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "TORCH_1_10",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "RotatedTaskAlignedAssigner",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "TaskAlignedAssigner",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "importPath": "ultralytics.utils.tal",
        "description": "ultralytics.utils.tal",
        "isExtraImport": true,
        "detail": "ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "scipy.linalg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.linalg",
        "description": "scipy.linalg",
        "detail": "scipy.linalg",
        "documentation": {}
    },
    {
        "label": "scipy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy",
        "description": "scipy",
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "torch.cuda",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.cuda",
        "description": "torch.cuda",
        "detail": "torch.cuda",
        "documentation": {}
    },
    {
        "label": "export_formats",
        "importPath": "ultralytics.engine.exporter",
        "description": "ultralytics.engine.exporter",
        "isExtraImport": true,
        "detail": "ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "Exporter",
        "importPath": "ultralytics.engine.exporter",
        "description": "ultralytics.engine.exporter",
        "isExtraImport": true,
        "detail": "ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "export_formats",
        "importPath": "ultralytics.engine.exporter",
        "description": "ultralytics.engine.exporter",
        "isExtraImport": true,
        "detail": "ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "metadata",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "torch.distributed",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.distributed",
        "description": "torch.distributed",
        "detail": "torch.distributed",
        "documentation": {}
    },
    {
        "label": "onnxruntime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnxruntime",
        "description": "onnxruntime",
        "detail": "onnxruntime",
        "documentation": {}
    },
    {
        "label": "interpreter",
        "importPath": "tflite_runtime",
        "description": "tflite_runtime",
        "isExtraImport": true,
        "detail": "tflite_runtime",
        "documentation": {}
    },
    {
        "label": "cv2.dnn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2.dnn",
        "description": "cv2.dnn",
        "detail": "cv2.dnn",
        "documentation": {}
    },
    {
        "label": "Point",
        "importPath": "shapely.geometry.point",
        "description": "shapely.geometry.point",
        "isExtraImport": true,
        "detail": "shapely.geometry.point",
        "documentation": {}
    },
    {
        "label": "AutoDetectionModel",
        "importPath": "sahi",
        "description": "sahi",
        "isExtraImport": true,
        "detail": "sahi",
        "documentation": {}
    },
    {
        "label": "get_sliced_prediction",
        "importPath": "sahi.predict",
        "description": "sahi.predict",
        "isExtraImport": true,
        "detail": "sahi.predict",
        "documentation": {}
    },
    {
        "label": "download_yolov8s_model",
        "importPath": "sahi.utils.yolov8",
        "description": "sahi.utils.yolov8",
        "isExtraImport": true,
        "detail": "sahi.utils.yolov8",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "classify",
        "importPath": "ultralytics.models.yolo",
        "description": "ultralytics.models.yolo",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo",
        "documentation": {}
    },
    {
        "label": "detect",
        "importPath": "ultralytics.models.yolo",
        "description": "ultralytics.models.yolo",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo",
        "documentation": {}
    },
    {
        "label": "segment",
        "importPath": "ultralytics.models.yolo",
        "description": "ultralytics.models.yolo",
        "isExtraImport": true,
        "detail": "ultralytics.models.yolo",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "load_inference_source",
        "importPath": "ultralytics.data.build",
        "description": "ultralytics.data.build",
        "isExtraImport": true,
        "detail": "ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "gradio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gradio",
        "description": "gradio",
        "detail": "gradio",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": "Identification..venv.Scripts.activate_this",
        "description": "Identification..venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": "Identification..venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "generate_color",
        "kind": 2,
        "importPath": "Identification.yolo-data-visualization.helpers",
        "description": "Identification.yolo-data-visualization.helpers",
        "peekOfCode": "def generate_color():\n    # Generate random values for red, green, and blue channels\n    r = random.randint(0, 255)\n    g = random.randint(0, 255)\n    b = random.randint(0, 255)\n    # Ensure sufficient contrast for visualization\n    if (r + g + b) / 3 < 128:\n        return generate_color()  # If color is too dark, try again\n    else:\n        return (r, g, b)",
        "detail": "Identification.yolo-data-visualization.helpers",
        "documentation": {}
    },
    {
        "label": "load_list_classname",
        "kind": 2,
        "importPath": "Identification.yolo-data-visualization.remap_labels",
        "description": "Identification.yolo-data-visualization.remap_labels",
        "peekOfCode": "def load_list_classname(classname_file):\n    if classname_file.endswith(\".txt\"):\n        with open(classname_file, \"r\") as f:\n            list_classname = f.read().rstrip(\"\\n\").split(\"\\n\")\n    elif classname_file.endswith(\".json\"):\n        with open(classname_file, 'r') as f:\n            class_mapping_dict = json.load(f)\n        swap_dict = {}\n        for key in class_mapping_dict.keys():\n            swap_dict[class_mapping_dict[key]] = key",
        "detail": "Identification.yolo-data-visualization.remap_labels",
        "documentation": {}
    },
    {
        "label": "init_explorer_form",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def init_explorer_form():\n    \"\"\"Initializes an Explorer instance and creates embeddings table with progress tracking.\"\"\"\n    datasets = ROOT / \"cfg\" / \"datasets\"\n    ds = [d.name for d in datasets.glob(\"*.yaml\")]\n    models = [\n        \"yolov8n.pt\",\n        \"yolov8s.pt\",\n        \"yolov8m.pt\",\n        \"yolov8l.pt\",\n        \"yolov8x.pt\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "query_form",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def query_form():\n    \"\"\"Sets up a form in Streamlit to initialize Explorer with dataset and model selection.\"\"\"\n    with st.form(\"query_form\"):\n        col1, col2 = st.columns([0.8, 0.2])\n        with col1:\n            st.text_input(\n                \"Query\",\n                \"WHERE labels LIKE '%person%' AND labels LIKE '%dog%'\",\n                label_visibility=\"collapsed\",\n                key=\"query\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "ai_query_form",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def ai_query_form():\n    \"\"\"Sets up a Streamlit form for user input to initialize Explorer with dataset and model selection.\"\"\"\n    with st.form(\"ai_query_form\"):\n        col1, col2 = st.columns([0.8, 0.2])\n        with col1:\n            st.text_input(\"Query\", \"Show images with 1 person and 1 dog\", label_visibility=\"collapsed\", key=\"ai_query\")\n        with col2:\n            st.form_submit_button(\"Ask AI\", on_click=run_ai_query)\ndef find_similar_imgs(imgs):\n    \"\"\"Initializes a Streamlit form for AI-based image querying with custom input.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "find_similar_imgs",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def find_similar_imgs(imgs):\n    \"\"\"Initializes a Streamlit form for AI-based image querying with custom input.\"\"\"\n    exp = st.session_state[\"explorer\"]\n    similar = exp.get_similar(img=imgs, limit=st.session_state.get(\"limit\"), return_type=\"arrow\")\n    paths = similar.to_pydict()[\"im_file\"]\n    st.session_state[\"imgs\"] = paths\n    st.session_state[\"res\"] = similar\ndef similarity_form(selected_imgs):\n    \"\"\"Initializes a form for AI-based image querying with custom input in Streamlit.\"\"\"\n    st.write(\"Similarity Search\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "similarity_form",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def similarity_form(selected_imgs):\n    \"\"\"Initializes a form for AI-based image querying with custom input in Streamlit.\"\"\"\n    st.write(\"Similarity Search\")\n    with st.form(\"similarity_form\"):\n        subcol1, subcol2 = st.columns([1, 1])\n        with subcol1:\n            st.number_input(\n                \"limit\", min_value=None, max_value=None, value=25, label_visibility=\"collapsed\", key=\"limit\"\n            )\n        with subcol2:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "run_sql_query",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def run_sql_query():\n    \"\"\"Executes an SQL query and returns the results.\"\"\"\n    st.session_state[\"error\"] = None\n    query = st.session_state.get(\"query\")\n    if query.rstrip().lstrip():\n        exp = st.session_state[\"explorer\"]\n        res = exp.sql_query(query, return_type=\"arrow\")\n        st.session_state[\"imgs\"] = res.to_pydict()[\"im_file\"]\n        st.session_state[\"res\"] = res\ndef run_ai_query():",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "run_ai_query",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def run_ai_query():\n    \"\"\"Execute SQL query and update session state with query results.\"\"\"\n    if not SETTINGS[\"openai_api_key\"]:\n        st.session_state[\"error\"] = (\n            'OpenAI API key not found in settings. Please run yolo settings openai_api_key=\"...\"'\n        )\n        return\n    st.session_state[\"error\"] = None\n    query = st.session_state.get(\"ai_query\")\n    if query.rstrip().lstrip():",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "reset_explorer",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def reset_explorer():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    st.session_state[\"explorer\"] = None\n    st.session_state[\"imgs\"] = None\n    st.session_state[\"error\"] = None\ndef utralytics_explorer_docs_callback():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    with st.container(border=True):\n        st.image(\n            \"https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Original.svg\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "utralytics_explorer_docs_callback",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def utralytics_explorer_docs_callback():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    with st.container(border=True):\n        st.image(\n            \"https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Original.svg\",\n            width=100,\n        )\n        st.markdown(\n            \"<p>This demo is built using Ultralytics Explorer API. Visit <a href='https://docs.ultralytics.com/datasets/explorer/'>API docs</a> to try examples & learn more</p>\",\n            unsafe_allow_html=True,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "layout",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def layout():\n    \"\"\"Resets explorer session variables and provides documentation with a link to API docs.\"\"\"\n    st.set_page_config(layout=\"wide\", initial_sidebar_state=\"collapsed\")\n    st.markdown(\"<h1 style='text-align: center;'>Ultralytics Explorer Demo</h1>\", unsafe_allow_html=True)\n    if st.session_state.get(\"explorer\") is None:\n        init_explorer_form()\n        return\n    st.button(\":arrow_backward: Select Dataset\", on_click=reset_explorer)\n    exp = st.session_state.get(\"explorer\")\n    col1, col2 = st.columns([0.75, 0.25], gap=\"small\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "ExplorerDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "peekOfCode": "class ExplorerDataset(YOLODataset):\n    def __init__(self, *args, data: dict = None, **kwargs) -> None:\n        super().__init__(*args, data=data, **kwargs)\n    def load_image(self, i: int) -> Union[Tuple[np.ndarray, Tuple[int, int], Tuple[int, int]], Tuple[None, None, None]]:\n        \"\"\"Loads 1 image from dataset index 'i' without any resize ops.\"\"\"\n        im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]\n        if im is None:  # not cached in RAM\n            if fn.exists():  # load npy\n                im = np.load(fn)\n            else:  # read image",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "documentation": {}
    },
    {
        "label": "Explorer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "peekOfCode": "class Explorer:\n    def __init__(\n        self,\n        data: Union[str, Path] = \"coco128.yaml\",\n        model: str = \"yolov8n.pt\",\n        uri: str = USER_CONFIG_DIR / \"explorer\",\n    ) -> None:\n        # Note duckdb==0.10.0 bug https://github.com/ultralytics/ultralytics/pull/8181\n        checks.check_requirements([\"lancedb>=0.4.3\", \"duckdb<=0.9.2\"])\n        import lancedb",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.explorer",
        "documentation": {}
    },
    {
        "label": "get_table_schema",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "peekOfCode": "def get_table_schema(vector_size):\n    \"\"\"Extracts and returns the schema of a database table.\"\"\"\n    from lancedb.pydantic import LanceModel, Vector\n    class Schema(LanceModel):\n        im_file: str\n        labels: List[str]\n        cls: List[int]\n        bboxes: List[List[float]]\n        masks: List[List[List[int]]]\n        keypoints: List[List[List[float]]]",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "get_sim_index_schema",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "peekOfCode": "def get_sim_index_schema():\n    \"\"\"Returns a LanceModel schema for a database table with specified vector size.\"\"\"\n    from lancedb.pydantic import LanceModel\n    class Schema(LanceModel):\n        idx: int\n        im_file: str\n        count: int\n        sim_im_files: List[str]\n    return Schema\ndef sanitize_batch(batch, dataset_info):",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "sanitize_batch",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "peekOfCode": "def sanitize_batch(batch, dataset_info):\n    \"\"\"Sanitizes input batch for inference, ensuring correct format and dimensions.\"\"\"\n    batch[\"cls\"] = batch[\"cls\"].flatten().int().tolist()\n    box_cls_pair = sorted(zip(batch[\"bboxes\"].tolist(), batch[\"cls\"]), key=lambda x: x[1])\n    batch[\"bboxes\"] = [box for box, _ in box_cls_pair]\n    batch[\"cls\"] = [cls for _, cls in box_cls_pair]\n    batch[\"labels\"] = [dataset_info[\"names\"][i] for i in batch[\"cls\"]]\n    batch[\"masks\"] = batch[\"masks\"].tolist() if \"masks\" in batch else [[[]]]\n    batch[\"keypoints\"] = batch[\"keypoints\"].tolist() if \"keypoints\" in batch else [[[]]]\n    return batch",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "plot_query_result",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "peekOfCode": "def plot_query_result(similar_set, plot_labels=True):\n    \"\"\"\n    Plot images from the similar set.\n    Args:\n        similar_set (list): Pyarrow or pandas object containing the similar data points\n        plot_labels (bool): Whether to plot labels or not\n    \"\"\"\n    similar_set = (\n        similar_set.to_dict(orient=\"list\") if isinstance(similar_set, pd.DataFrame) else similar_set.to_pydict()\n    )",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "prompt_sql_query",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "peekOfCode": "def prompt_sql_query(query):\n    \"\"\"Plots images with optional labels from a similar data set.\"\"\"\n    check_requirements(\"openai>=1.6.1\")\n    from openai import OpenAI\n    if not SETTINGS[\"openai_api_key\"]:\n        logger.warning(\"OpenAI API key not found in settings. Please enter your API key below.\")\n        openai_api_key = getpass.getpass(\"OpenAI API key: \")\n        SETTINGS.update({\"openai_api_key\": openai_api_key})\n    openai = OpenAI(api_key=SETTINGS[\"openai_api_key\"])\n    messages = [",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "auto_annotate",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.annotator",
        "description": "Identification.yolov10.build.lib.ultralytics.data.annotator",
        "peekOfCode": "def auto_annotate(data, det_model=\"yolov8x.pt\", sam_model=\"sam_b.pt\", device=\"\", output_dir=None):\n    \"\"\"\n    Automatically annotates images using a YOLO object detection model and a SAM segmentation model.\n    Args:\n        data (str): Path to a folder containing images to be annotated.\n        det_model (str, optional): Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'.\n        sam_model (str, optional): Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'.\n        device (str, optional): Device to run the models on. Defaults to an empty string (CPU or GPU, if available).\n        output_dir (str | None | optional): Directory to save the annotated results.\n            Defaults to a 'labels' folder in the same directory as 'data'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.annotator",
        "documentation": {}
    },
    {
        "label": "BaseTransform",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.\n        apply_image: Applies image transformation to labels.\n        apply_instances: Applies transformations to object instances in labels.\n        apply_semantic: Applies semantic segmentation to an image.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Compose",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class Compose:\n    \"\"\"Class for composing multiple image transformations.\"\"\"\n    def __init__(self, transforms):\n        \"\"\"Initializes the Compose object with a list of transforms.\"\"\"\n        self.transforms = transforms\n    def __call__(self, data):\n        \"\"\"Applies a series of transformations to input data.\"\"\"\n        for t in self.transforms:\n            data = t(data)\n        return data",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "BaseMixTransform",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class BaseMixTransform:\n    \"\"\"\n    Class for base mix (MixUp/Mosaic) transformations.\n    This implementation is from mmyolo.\n    \"\"\"\n    def __init__(self, dataset, pre_transform=None, p=0.0) -> None:\n        \"\"\"Initializes the BaseMixTransform object with dataset, pre_transform, and probability.\"\"\"\n        self.dataset = dataset\n        self.pre_transform = pre_transform\n        self.p = p",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Mosaic",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class Mosaic(BaseMixTransform):\n    \"\"\"\n    Mosaic augmentation.\n    This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image.\n    The augmentation is applied to a dataset with a given probability.\n    Attributes:\n        dataset: The dataset on which the mosaic augmentation is applied.\n        imgsz (int, optional): Image size (height and width) after mosaic pipeline of a single image. Default to 640.\n        p (float, optional): Probability of applying the mosaic augmentation. Must be in the range 0-1. Default to 1.0.\n        n (int, optional): The grid size, either 4 (for 2x2) or 9 (for 3x3).",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "MixUp",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class MixUp(BaseMixTransform):\n    \"\"\"Class for applying MixUp augmentation to the dataset.\"\"\"\n    def __init__(self, dataset, pre_transform=None, p=0.0) -> None:\n        \"\"\"Initializes MixUp object with dataset, pre_transform, and probability of applying MixUp.\"\"\"\n        super().__init__(dataset=dataset, pre_transform=pre_transform, p=p)\n    def get_indexes(self):\n        \"\"\"Get a random index from the dataset.\"\"\"\n        return random.randint(0, len(self.dataset) - 1)\n    def _mix_transform(self, labels):\n        \"\"\"Applies MixUp augmentation as per https://arxiv.org/pdf/1710.09412.pdf.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomPerspective",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class RandomPerspective:\n    \"\"\"\n    Implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and\n    keypoints. These transformations include rotation, translation, scaling, and shearing. The class also offers the\n    option to apply these transformations conditionally with a specified probability.\n    Attributes:\n        degrees (float): Degree range for random rotations.\n        translate (float): Fraction of total width and height for random translation.\n        scale (float): Scaling factor interval, e.g., a scale factor of 0.1 allows a resize between 90%-110%.\n        shear (float): Shear intensity (angle in degrees).",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomHSV",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class RandomHSV:\n    \"\"\"\n    This class is responsible for performing random adjustments to the Hue, Saturation, and Value (HSV) channels of an\n    image.\n    The adjustments are random but within limits set by hgain, sgain, and vgain.\n    \"\"\"\n    def __init__(self, hgain=0.5, sgain=0.5, vgain=0.5) -> None:\n        \"\"\"\n        Initialize RandomHSV class with gains for each HSV channel.\n        Args:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomFlip",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class RandomFlip:\n    \"\"\"\n    Applies a random horizontal or vertical flip to an image with a given probability.\n    Also updates any instances (bounding boxes, keypoints, etc.) accordingly.\n    \"\"\"\n    def __init__(self, p=0.5, direction=\"horizontal\", flip_idx=None) -> None:\n        \"\"\"\n        Initializes the RandomFlip class with probability and direction.\n        Args:\n            p (float, optional): The probability of applying the flip. Must be between 0 and 1. Default is 0.5.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class LetterBox:\n    \"\"\"Resize image and padding for detection, instance segmentation, pose.\"\"\"\n    def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):\n        \"\"\"Initialize LetterBox object with specific parameters.\"\"\"\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup\n        self.stride = stride\n        self.center = center  # Put the image in the middle or top-left",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "CopyPaste",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class CopyPaste:\n    \"\"\"\n    Implements the Copy-Paste augmentation as described in the paper https://arxiv.org/abs/2012.07177. This class is\n    responsible for applying the Copy-Paste augmentation on images and their corresponding instances.\n    \"\"\"\n    def __init__(self, p=0.5) -> None:\n        \"\"\"\n        Initializes the CopyPaste class with a given probability.\n        Args:\n            p (float, optional): The probability of applying the Copy-Paste augmentation. Must be between 0 and 1.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Albumentations",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class Albumentations:\n    \"\"\"\n    Albumentations transformations.\n    Optional, uninstall package to disable. Applies Blur, Median Blur, convert to grayscale, Contrast Limited Adaptive\n    Histogram Equalization, random change of brightness and contrast, RandomGamma and lowering of image quality by\n    compression.\n    \"\"\"\n    def __init__(self, p=1.0):\n        \"\"\"Initialize the transform object for YOLO bbox formatted params.\"\"\"\n        self.p = p",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class Format:\n    \"\"\"\n    Formats image annotations for object detection, instance segmentation, and pose estimation tasks. The class\n    standardizes the image and instance annotations to be used by the `collate_fn` in PyTorch DataLoader.\n    Attributes:\n        bbox_format (str): Format for bounding boxes. Default is 'xywh'.\n        normalize (bool): Whether to normalize bounding boxes. Default is True.\n        return_mask (bool): Return instance masks for segmentation. Default is False.\n        return_keypoint (bool): Return keypoints for pose estimation. Default is False.\n        mask_ratio (int): Downsample ratio for masks. Default is 4.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "ClassifyLetterBox",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class ClassifyLetterBox:\n    \"\"\"\n    YOLOv8 LetterBox class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([LetterBox(size), ToTensor()]).\n    Attributes:\n        h (int): Target height of the image.\n        w (int): Target width of the image.\n        auto (bool): If True, automatically solves for short side using stride.\n        stride (int): The stride value, used when 'auto' is True.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "CenterCrop",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class CenterCrop:\n    \"\"\"YOLOv8 CenterCrop class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([CenterCrop(size), ToTensor()]).\n    \"\"\"\n    def __init__(self, size=640):\n        \"\"\"Converts an image from numpy array to PyTorch tensor.\"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n    def __call__(self, im):\n        \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "ToTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "class ToTensor:\n    \"\"\"YOLOv8 ToTensor class for image preprocessing, i.e., T.Compose([LetterBox(size), ToTensor()]).\"\"\"\n    def __init__(self, half=False):\n        \"\"\"Initialize YOLOv8 ToTensor object with optional half-precision support.\"\"\"\n        super().__init__()\n        self.half = half\n    def __call__(self, im):\n        \"\"\"\n        Transforms an image from a numpy array to a PyTorch tensor, applying optional half-precision and normalization.\n        Args:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "v8_transforms",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "def v8_transforms(dataset, imgsz, hyp, stretch=False):\n    \"\"\"Convert images to a size suitable for YOLOv8 training.\"\"\"\n    pre_transform = Compose(\n        [\n            Mosaic(dataset, imgsz=imgsz, p=hyp.mosaic),\n            CopyPaste(p=hyp.copy_paste),\n            RandomPerspective(\n                degrees=hyp.degrees,\n                translate=hyp.translate,\n                scale=hyp.scale,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_transforms",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "def classify_transforms(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    interpolation: T.InterpolationMode = T.InterpolationMode.BILINEAR,\n    crop_fraction: float = DEFAULT_CROP_FTACTION,\n):\n    \"\"\"\n    Classification transforms for evaluation/inference. Inspired by timm/data/transforms_factory.py.\n    Args:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_augmentations",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "def classify_augmentations(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    scale=None,\n    ratio=None,\n    hflip=0.5,\n    vflip=0.0,\n    auto_augment=None,\n    hsv_h=0.015,  # image HSV-Hue augmentation (fraction)",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MEAN",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_MEAN = (0.0, 0.0, 0.0)\nDEFAULT_STD = (1.0, 1.0, 1.0)\nDEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_STD",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_STD = (1.0, 1.0, 1.0)\nDEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CROP_FTACTION",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "description": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.\n        apply_image: Applies image transformation to labels.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "BaseDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.base",
        "description": "Identification.yolov10.build.lib.ultralytics.data.base",
        "peekOfCode": "class BaseDataset(Dataset):\n    \"\"\"\n    Base dataset class for loading and processing image data.\n    Args:\n        img_path (str): Path to the folder containing images.\n        imgsz (int, optional): Image size. Defaults to 640.\n        cache (bool, optional): Cache images to RAM or disk during training. Defaults to False.\n        augment (bool, optional): If True, data augmentation is applied. Defaults to True.\n        hyp (dict, optional): Hyperparameters to apply data augmentation. Defaults to None.\n        prefix (str, optional): Prefix to print in log messages. Defaults to ''.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.base",
        "documentation": {}
    },
    {
        "label": "InfiniteDataLoader",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "class InfiniteDataLoader(dataloader.DataLoader):\n    \"\"\"\n    Dataloader that reuses workers.\n    Uses same syntax as vanilla DataLoader.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Dataloader that infinitely recycles workers, inherits from DataLoader.\"\"\"\n        super().__init__(*args, **kwargs)\n        object.__setattr__(self, \"batch_sampler\", _RepeatSampler(self.batch_sampler))\n        self.iterator = super().__iter__()",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "_RepeatSampler",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "class _RepeatSampler:\n    \"\"\"\n    Sampler that repeats forever.\n    Args:\n        sampler (Dataset.sampler): The sampler to repeat.\n    \"\"\"\n    def __init__(self, sampler):\n        \"\"\"Initializes an object that repeats a given sampler indefinitely.\"\"\"\n        self.sampler = sampler\n    def __iter__(self):",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "seed_worker",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "def seed_worker(worker_id):  # noqa\n    \"\"\"Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader.\"\"\"\n    worker_seed = torch.initial_seed() % 2**32\n    np.random.seed(worker_seed)\n    random.seed(worker_seed)\ndef build_yolo_dataset(cfg, img_path, batch, data, mode=\"train\", rect=False, stride=32):\n    \"\"\"Build YOLO Dataset.\"\"\"\n    return YOLODataset(\n        img_path=img_path,\n        imgsz=cfg.imgsz,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "def build_yolo_dataset(cfg, img_path, batch, data, mode=\"train\", rect=False, stride=32):\n    \"\"\"Build YOLO Dataset.\"\"\"\n    return YOLODataset(\n        img_path=img_path,\n        imgsz=cfg.imgsz,\n        batch_size=batch,\n        augment=mode == \"train\",  # augmentation\n        hyp=cfg,  # TODO: probably add a get_hyps_from_cfg function\n        rect=cfg.rect or rect,  # rectangular batches\n        cache=cfg.cache or None,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "def build_dataloader(dataset, batch, workers, shuffle=True, rank=-1):\n    \"\"\"Return an InfiniteDataLoader or DataLoader for training or validation set.\"\"\"\n    batch = min(batch, len(dataset))\n    nd = torch.cuda.device_count()  # number of CUDA devices\n    nw = min([os.cpu_count() // max(nd, 1), workers])  # number of workers\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return InfiniteDataLoader(\n        dataset=dataset,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "check_source",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "def check_source(source):\n    \"\"\"Check source type and return corresponding flag values.\"\"\"\n    webcam, screenshot, from_img, in_memory, tensor = False, False, False, False, False\n    if isinstance(source, (str, int, Path)):  # int for local usb camera\n        source = str(source)\n        is_file = Path(source).suffix[1:] in (IMG_FORMATS | VID_FORMATS)\n        is_url = source.lower().startswith((\"https://\", \"http://\", \"rtsp://\", \"rtmp://\", \"tcp://\"))\n        webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n        screenshot = source.lower() == \"screen\"\n        if is_url and is_file:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "load_inference_source",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.build",
        "description": "Identification.yolov10.build.lib.ultralytics.data.build",
        "peekOfCode": "def load_inference_source(source=None, batch=1, vid_stride=1, buffer=False):\n    \"\"\"\n    Loads an inference source for object detection and applies necessary transformations.\n    Args:\n        source (str, Path, Tensor, PIL.Image, np.ndarray): The input source for inference.\n        batch (int, optional): Batch size for dataloaders. Default is 1.\n        vid_stride (int, optional): The frame interval for video sources. Default is 1.\n        buffer (bool, optional): Determined whether stream frames will be buffered. Default is False.\n    Returns:\n        dataset (Dataset): A dataset object for the specified input source.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "coco91_to_coco80_class",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def coco91_to_coco80_class():\n    \"\"\"\n    Converts 91-index COCO class IDs to 80-index COCO class IDs.\n    Returns:\n        (list): A list of 91 class IDs where the index represents the 80-index class ID and the value is the\n            corresponding 91-index class ID.\n    \"\"\"\n    return [\n        0,\n        1,",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "coco80_to_coco91_class",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def coco80_to_coco91_class():\n    \"\"\"\n    Converts 80-index (val2014) to 91-index (paper).\n    For details see https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/.\n    Example:\n        ```python\n        import numpy as np\n        a = np.loadtxt('data/coco.names', dtype='str', delimiter='\\n')\n        b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\\n')\n        x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "convert_coco",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def convert_coco(\n    labels_dir=\"../coco/annotations/\",\n    save_dir=\"coco_converted/\",\n    use_segments=False,\n    use_keypoints=False,\n    cls91to80=True,\n):\n    \"\"\"\n    Converts COCO dataset annotations to a YOLO annotation format  suitable for training YOLO models.\n    Args:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "convert_dota_to_yolo_obb",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def convert_dota_to_yolo_obb(dota_root_path: str):\n    \"\"\"\n    Converts DOTA dataset annotations to YOLO OBB (Oriented Bounding Box) format.\n    The function processes images in the 'train' and 'val' folders of the DOTA dataset. For each image, it reads the\n    associated label from the original labels directory and writes new labels in YOLO OBB format to a new directory.\n    Args:\n        dota_root_path (str): The root directory path of the DOTA dataset.\n    Example:\n        ```python\n        from ultralytics.data.converter import convert_dota_to_yolo_obb",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "min_index",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def min_index(arr1, arr2):\n    \"\"\"\n    Find a pair of indexes with the shortest distance between two arrays of 2D points.\n    Args:\n        arr1 (np.ndarray): A NumPy array of shape (N, 2) representing N 2D points.\n        arr2 (np.ndarray): A NumPy array of shape (M, 2) representing M 2D points.\n    Returns:\n        (tuple): A tuple containing the indexes of the points with the shortest distance in arr1 and arr2 respectively.\n    \"\"\"\n    dis = ((arr1[:, None, :] - arr2[None, :, :]) ** 2).sum(-1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "merge_multi_segment",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def merge_multi_segment(segments):\n    \"\"\"\n    Merge multiple segments into one list by connecting the coordinates with the minimum distance between each segment.\n    This function connects these coordinates with a thin line to merge all segments into one.\n    Args:\n        segments (List[List]): Original segmentations in COCO's JSON file.\n                               Each element is a list of coordinates, like [segmentation1, segmentation2,...].\n    Returns:\n        s (List[np.ndarray]): A list of connected segments represented as NumPy arrays.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "yolo_bbox2segment",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "description": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "peekOfCode": "def yolo_bbox2segment(im_dir, save_dir=None, sam_model=\"sam_b.pt\"):\n    \"\"\"\n    Converts existing object detection dataset (bounding boxes) to segmentation dataset or oriented bounding box (OBB)\n    in YOLO format. Generates segmentation data using SAM auto-annotator as needed.\n    Args:\n        im_dir (str | Path): Path to image directory to convert.\n        save_dir (str | Path): Path to save the generated labels, labels will be saved\n            into `labels-segment` in the same directory level of `im_dir` if save_dir is None. Default: None.\n        sam_model (str): Segmentation model to use for intermediate segmentation data; optional.\n    Notes:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "class YOLODataset(BaseDataset):\n    \"\"\"\n    Dataset class for loading object detection and/or segmentation labels in YOLO format.\n    Args:\n        data (dict, optional): A dataset YAML dictionary. Defaults to None.\n        task (str): An explicit arg to point current task, Defaults to 'detect'.\n    Returns:\n        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.\n    \"\"\"\n    def __init__(self, *args, data=None, task=\"detect\", **kwargs):",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "class ClassificationDataset(torchvision.datasets.ImageFolder):\n    \"\"\"\n    Extends torchvision ImageFolder to support YOLO classification tasks, offering functionalities like image\n    augmentation, caching, and verification. It's designed to efficiently handle large datasets for training deep\n    learning models, with optional image transformations and caching mechanisms to speed up training.\n    This class allows for augmentations using both torchvision and Albumentations libraries, and supports caching images\n    in RAM or on disk to reduce IO overhead during training. Additionally, it implements a robust verification process\n    to ensure data integrity and consistency.\n    Attributes:\n        cache_ram (bool): Indicates if caching in RAM is enabled.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "SemanticDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "class SemanticDataset(BaseDataset):\n    \"\"\"\n    Semantic Segmentation Dataset.\n    This class is responsible for handling datasets used for semantic segmentation tasks. It inherits functionalities\n    from the BaseDataset class.\n    Note:\n        This class is currently a placeholder and needs to be populated with methods and attributes for supporting\n        semantic segmentation tasks.\n    \"\"\"\n    def __init__(self):",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "load_dataset_cache_file",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "def load_dataset_cache_file(path):\n    \"\"\"Load an Ultralytics *.cache dictionary from path.\"\"\"\n    import gc\n    gc.disable()  # reduce pickle load time https://github.com/ultralytics/ultralytics/pull/1585\n    cache = np.load(str(path), allow_pickle=True).item()  # load dict\n    gc.enable()\n    return cache\ndef save_dataset_cache_file(prefix, path, x):\n    \"\"\"Save an Ultralytics dataset *.cache dictionary x to path.\"\"\"\n    x[\"version\"] = DATASET_CACHE_VERSION  # add cache version",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "save_dataset_cache_file",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "def save_dataset_cache_file(prefix, path, x):\n    \"\"\"Save an Ultralytics dataset *.cache dictionary x to path.\"\"\"\n    x[\"version\"] = DATASET_CACHE_VERSION  # add cache version\n    if is_dir_writeable(path.parent):\n        if path.exists():\n            path.unlink()  # remove *.cache file if exists\n        np.save(str(path), x)  # save cache for next time\n        path.with_suffix(\".cache.npy\").rename(path)  # remove .npy suffix\n        LOGGER.info(f\"{prefix}New cache created: {path}\")\n    else:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "DATASET_CACHE_VERSION",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "description": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "peekOfCode": "DATASET_CACHE_VERSION = \"1.0.3\"\nclass YOLODataset(BaseDataset):\n    \"\"\"\n    Dataset class for loading object detection and/or segmentation labels in YOLO format.\n    Args:\n        data (dict, optional): A dataset YAML dictionary. Defaults to None.\n        task (str): An explicit arg to point current task, Defaults to 'detect'.\n    Returns:\n        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "SourceTypes",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class SourceTypes:\n    \"\"\"Class to represent various types of input sources for predictions.\"\"\"\n    stream: bool = False\n    screenshot: bool = False\n    from_img: bool = False\n    tensor: bool = False\nclass LoadStreams:\n    \"\"\"\n    Stream Loader for various types of video streams, Supports RTSP, RTMP, HTTP, and TCP streams.\n    Attributes:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadStreams",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class LoadStreams:\n    \"\"\"\n    Stream Loader for various types of video streams, Supports RTSP, RTMP, HTTP, and TCP streams.\n    Attributes:\n        sources (str): The source input paths or URLs for the video streams.\n        vid_stride (int): Video frame-rate stride, defaults to 1.\n        buffer (bool): Whether to buffer input streams, defaults to False.\n        running (bool): Flag to indicate if the streaming thread is running.\n        mode (str): Set to 'stream' indicating real-time capture.\n        imgs (list): List of image frames for each stream.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadScreenshots",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class LoadScreenshots:\n    \"\"\"\n    YOLOv8 screenshot dataloader.\n    This class manages the loading of screenshot images for processing with YOLOv8.\n    Suitable for use with `yolo predict source=screen`.\n    Attributes:\n        source (str): The source input indicating which screen to capture.\n        screen (int): The screen number to capture.\n        left (int): The left coordinate for screen capture area.\n        top (int): The top coordinate for screen capture area.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadImagesAndVideos",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class LoadImagesAndVideos:\n    \"\"\"\n    YOLOv8 image/video dataloader.\n    This class manages the loading and pre-processing of image and video data for YOLOv8. It supports loading from\n    various formats, including single image files, video files, and lists of image and video paths.\n    Attributes:\n        files (list): List of image and video file paths.\n        nf (int): Total number of files (images and videos).\n        video_flag (list): Flags indicating whether a file is a video (True) or an image (False).\n        mode (str): Current mode, 'image' or 'video'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadPilAndNumpy",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class LoadPilAndNumpy:\n    \"\"\"\n    Load images from PIL and Numpy arrays for batch processing.\n    This class is designed to manage loading and pre-processing of image data from both PIL and Numpy formats.\n    It performs basic validation and format conversion to ensure that the images are in the required format for\n    downstream processing.\n    Attributes:\n        paths (list): List of image paths or autogenerated filenames.\n        im0 (list): List of images stored as Numpy arrays.\n        mode (str): Type of data being processed, defaults to 'image'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "class LoadTensor:\n    \"\"\"\n    Load images from torch.Tensor data.\n    This class manages the loading and pre-processing of image data from PyTorch tensors for further processing.\n    Attributes:\n        im0 (torch.Tensor): The input tensor containing the image(s).\n        bs (int): Batch size, inferred from the shape of `im0`.\n        mode (str): Current mode, set to 'image'.\n        paths (list): List of image paths or filenames.\n        count (int): Counter for iteration, initialized at 0 during `__iter__()`.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "autocast_list",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "def autocast_list(source):\n    \"\"\"Merges a list of source of different types into a list of numpy arrays or PIL images.\"\"\"\n    files = []\n    for im in source:\n        if isinstance(im, (str, Path)):  # filename or uri\n            files.append(Image.open(requests.get(im, stream=True).raw if str(im).startswith(\"http\") else im))\n        elif isinstance(im, (Image.Image, np.ndarray)):  # PIL or np Image\n            files.append(im)\n        else:\n            raise TypeError(",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "get_best_youtube_url",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "def get_best_youtube_url(url, use_pafy=True):\n    \"\"\"\n    Retrieves the URL of the best quality MP4 video stream from a given YouTube video.\n    This function uses the pafy or yt_dlp library to extract the video info from YouTube. It then finds the highest\n    quality MP4 format that has video codec but no audio codec, and returns the URL of this video stream.\n    Args:\n        url (str): The URL of the YouTube video.\n        use_pafy (bool): Use the pafy package, default=True, otherwise use yt_dlp package.\n    Returns:\n        (str): The URL of the best quality MP4 video stream, or None if no suitable stream is found.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LOADERS",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "description": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "peekOfCode": "LOADERS = (LoadStreams, LoadPilAndNumpy, LoadImagesAndVideos, LoadScreenshots)",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "bbox_iof",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def bbox_iof(polygon1, bbox2, eps=1e-6):\n    \"\"\"\n    Calculate iofs between bbox1 and bbox2.\n    Args:\n        polygon1 (np.ndarray): Polygon coordinates, (n, 8).\n        bbox2 (np.ndarray): Bounding boxes, (n ,4).\n    \"\"\"\n    polygon1 = polygon1.reshape(-1, 4, 2)\n    lt_point = np.min(polygon1, axis=-2)\n    rb_point = np.max(polygon1, axis=-2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "load_yolo_dota",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def load_yolo_dota(data_root, split=\"train\"):\n    \"\"\"\n    Load DOTA dataset.\n    Args:\n        data_root (str): Data root.\n        split (str): The split data set, could be train or val.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "get_windows",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def get_windows(im_size, crop_sizes=[1024], gaps=[200], im_rate_thr=0.6, eps=0.01):\n    \"\"\"\n    Get the coordinates of windows.\n    Args:\n        im_size (tuple): Original image size, (h, w).\n        crop_sizes (List(int)): Crop size of windows.\n        gaps (List(int)): Gap between crops.\n        im_rate_thr (float): Threshold of windows areas divided by image ares.\n    \"\"\"\n    h, w = im_size",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "get_window_obj",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def get_window_obj(anno, windows, iof_thr=0.7):\n    \"\"\"Get objects for each window.\"\"\"\n    h, w = anno[\"ori_size\"]\n    label = anno[\"label\"]\n    if len(label):\n        label[:, 1::2] *= w\n        label[:, 2::2] *= h\n        iofs = bbox_iof(label[:, 1:], windows)\n        # Unnormalized and misaligned coordinates\n        return [(label[iofs[:, i] >= iof_thr]) for i in range(len(windows))]  # window_anns",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "crop_and_save",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def crop_and_save(anno, windows, window_objs, im_dir, lb_dir):\n    \"\"\"\n    Crop images and save new labels.\n    Args:\n        anno (dict): Annotation dict, including `filepath`, `label`, `ori_size` as its keys.\n        windows (list): A list of windows coordinates.\n        window_objs (list): A list of labels inside each window.\n        im_dir (str): The output directory path of images.\n        lb_dir (str): The output directory path of labels.\n    Notes:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_images_and_labels",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def split_images_and_labels(data_root, save_dir, split=\"train\", crop_sizes=[1024], gaps=[200]):\n    \"\"\"\n    Split both images and labels.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - split\n                - labels\n                    - split",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_trainval",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def split_trainval(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split train and val set of DOTA.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - train\n                    - val\n                - labels",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_test",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "description": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "peekOfCode": "def split_test(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split test set of DOTA, labels are not included within this set.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - test\n        and the output directory structure is:\n            - save_dir",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "HUBDatasetStats",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "class HUBDatasetStats:\n    \"\"\"\n    A class for generating HUB dataset JSON and `-hub` dataset directory.\n    Args:\n        path (str): Path to data.yaml or data.zip (with data.yaml inside data.zip). Default is 'coco8.yaml'.\n        task (str): Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Default is 'detect'.\n        autodownload (bool): Attempt to download dataset if not found locally. Default is False.\n    Example:\n        Download *.zip files from https://github.com/ultralytics/hub/tree/main/example_datasets\n            i.e. https://github.com/ultralytics/hub/raw/main/example_datasets/coco8.zip for coco8.zip.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "img2label_paths",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "get_hash",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash\ndef exif_size(img: Image.Image):\n    \"\"\"Returns exif-corrected PIL size.\"\"\"\n    s = img.size  # (width, height)\n    if img.format == \"JPEG\":  # only support JPEG images",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "exif_size",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def exif_size(img: Image.Image):\n    \"\"\"Returns exif-corrected PIL size.\"\"\"\n    s = img.size  # (width, height)\n    if img.format == \"JPEG\":  # only support JPEG images\n        with contextlib.suppress(Exception):\n            exif = img.getexif()\n            if exif:\n                rotation = exif.get(274, None)  # the EXIF key for the orientation tag is 274\n                if rotation in [6, 8]:  # rotation 270 or 90\n                    s = s[1], s[0]",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "verify_image",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def verify_image(args):\n    \"\"\"Verify one image.\"\"\"\n    (im_file, cls), prefix = args\n    # Number (found, corrupt), message\n    nf, nc, msg = 0, 0, \"\"\n    try:\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size\n        shape = (shape[1], shape[0])  # hw",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "verify_image_label",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def verify_image_label(args):\n    \"\"\"Verify one image-label pair.\"\"\"\n    im_file, lb_file, prefix, keypoint, num_cls, nkpt, ndim = args\n    # Number (missing, found, empty, corrupt), message, segments, keypoints\n    nm, nf, ne, nc, msg, segments, keypoints = 0, 0, 0, 0, \"\", [], None\n    try:\n        # Verify images\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygon2mask",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def polygon2mask(imgsz, polygons, color=1, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a binary mask of the specified image size.\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int, optional): The color value to fill in the polygons on the mask. Defaults to 1.\n        downsample_ratio (int, optional): Factor by which to downsample the mask. Defaults to 1.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygons2masks",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def polygons2masks(imgsz, polygons, color, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a set of binary masks of the specified image size.\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int): The color value to fill in the polygons on the masks.\n        downsample_ratio (int, optional): Factor by which to downsample each mask. Defaults to 1.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygons2masks_overlap",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def polygons2masks_overlap(imgsz, segments, downsample_ratio=1):\n    \"\"\"Return a (640, 640) overlap mask.\"\"\"\n    masks = np.zeros(\n        (imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio),\n        dtype=np.int32 if len(segments) > 255 else np.uint8,\n    )\n    areas = []\n    ms = []\n    for si in range(len(segments)):\n        mask = polygon2mask(imgsz, [segments[si].reshape(-1)], downsample_ratio=downsample_ratio, color=1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "find_dataset_yaml",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def find_dataset_yaml(path: Path) -> Path:\n    \"\"\"\n    Find and return the YAML file associated with a Detect, Segment or Pose dataset.\n    This function searches for a YAML file at the root level of the provided directory first, and if not found, it\n    performs a recursive search. It prefers YAML files that have the same stem as the provided path. An AssertionError\n    is raised if no YAML file is found or if multiple YAML files are found.\n    Args:\n        path (Path): The directory path to search for the YAML file.\n    Returns:\n        (Path): The path of the found YAML file.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def check_det_dataset(dataset, autodownload=True):\n    \"\"\"\n    Download, verify, and/or unzip a dataset if not found locally.\n    This function checks the availability of a specified dataset, and if not found, it has the option to download and\n    unzip the dataset. It then reads and parses the accompanying YAML data, ensuring key requirements are met and also\n    resolves paths related to the dataset.\n    Args:\n        dataset (str): Path to the dataset or dataset descriptor (like a YAML file).\n        autodownload (bool, optional): Whether to automatically download the dataset if not found. Defaults to True.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def check_cls_dataset(dataset, split=\"\"):\n    \"\"\"\n    Checks a classification dataset such as Imagenet.\n    This function accepts a `dataset` name and attempts to retrieve the corresponding dataset information.\n    If the dataset is not found locally, it attempts to download the dataset from the internet and save it locally.\n    Args:\n        dataset (str | Path): The name of the dataset.\n        split (str, optional): The split of the dataset. Either 'val', 'test', or ''. Defaults to ''.\n    Returns:\n        (dict): A dictionary containing the following keys:",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "compress_one_image",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def compress_one_image(f, f_new=None, max_dim=1920, quality=50):\n    \"\"\"\n    Compresses a single image file to reduced size while preserving its aspect ratio and quality using either the Python\n    Imaging Library (PIL) or OpenCV library. If the input image is smaller than the maximum dimension, it will not be\n    resized.\n    Args:\n        f (str): The path to the input image file.\n        f_new (str, optional): The path to the output image file. If not specified, the input file will be overwritten.\n        max_dim (int, optional): The maximum dimension (width or height) of the output image. Default is 1920 pixels.\n        quality (int, optional): The image compression quality as a percentage. Default is 50%.",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "autosplit",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "def autosplit(path=DATASETS_DIR / \"coco8/images\", weights=(0.9, 0.1, 0.0), annotated_only=False):\n    \"\"\"\n    Automatically split a dataset into train/val/test splits and save the resulting splits into autosplit_*.txt files.\n    Args:\n        path (Path, optional): Path to images directory. Defaults to DATASETS_DIR / 'coco8/images'.\n        weights (list | tuple, optional): Train, validation, and test split fractions. Defaults to (0.9, 0.1, 0.0).\n        annotated_only (bool, optional): If True, only images with an associated txt file are used. Defaults to False.\n    Example:\n        ```python\n        from ultralytics.data.utils import autosplit",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "HELP_URL",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "HELP_URL = \"See https://docs.ultralytics.com/datasets/detect for dataset formatting guidance.\"\nIMG_FORMATS = {\"bmp\", \"dng\", \"jpeg\", \"jpg\", \"mpo\", \"png\", \"tif\", \"tiff\", \"webp\", \"pfm\"}  # image suffixes\nVID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "IMG_FORMATS = {\"bmp\", \"dng\", \"jpeg\", \"jpg\", \"mpo\", \"png\", \"tif\", \"tiff\", \"webp\", \"pfm\"}  # image suffixes\nVID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "VID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "PIN_MEMORY",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "peekOfCode": "PIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths",
        "detail": "Identification.yolov10.build.lib.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "Exporter",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "peekOfCode": "class Exporter:\n    \"\"\"\n    A class for exporting a model.\n    Attributes:\n        args (SimpleNamespace): Configuration for the exporter.\n        callbacks (list, optional): List of callback functions. Defaults to None.\n    \"\"\"\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the Exporter class.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "IOSDetectModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "peekOfCode": "class IOSDetectModel(torch.nn.Module):\n    \"\"\"Wrap an Ultralytics YOLO model for Apple iOS CoreML export.\"\"\"\n    def __init__(self, model, im):\n        \"\"\"Initialize the IOSDetectModel class with a YOLO model and example image.\"\"\"\n        super().__init__()\n        _, _, h, w = im.shape  # batch, channel, height, width\n        self.model = model\n        self.nc = len(model.names)  # number of classes\n        if w == h:\n            self.normalize = 1.0 / w  # scalar",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "export_formats",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "peekOfCode": "def export_formats():\n    \"\"\"YOLOv8 export formats.\"\"\"\n    import pandas\n    x = [\n        [\"PyTorch\", \"-\", \".pt\", True, True],\n        [\"TorchScript\", \"torchscript\", \".torchscript\", True, True],\n        [\"ONNX\", \"onnx\", \".onnx\", True, True],\n        [\"OpenVINO\", \"openvino\", \"_openvino_model\", True, False],\n        [\"TensorRT\", \"engine\", \".engine\", False, True],\n        [\"CoreML\", \"coreml\", \".mlpackage\", True, False],",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "gd_outputs",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "peekOfCode": "def gd_outputs(gd):\n    \"\"\"TensorFlow GraphDef model output node names.\"\"\"\n    name_list, input_list = [], []\n    for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n        name_list.append(node.name)\n        input_list.extend(node.input)\n    return sorted(f\"{x}:0\" for x in list(set(name_list) - set(input_list)) if not x.startswith(\"NoOp\"))\ndef try_export(inner_func):\n    \"\"\"YOLOv8 export decorator, i..e @try_export.\"\"\"\n    inner_args = get_default_args(inner_func)",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "try_export",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "peekOfCode": "def try_export(inner_func):\n    \"\"\"YOLOv8 export decorator, i..e @try_export.\"\"\"\n    inner_args = get_default_args(inner_func)\n    def outer_func(*args, **kwargs):\n        \"\"\"Export a model.\"\"\"\n        prefix = inner_args[\"prefix\"]\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f\"{prefix} export success  {dt.t:.1f}s, saved as '{f}' ({file_size(f):.1f} MB)\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.model",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.model",
        "peekOfCode": "class Model(nn.Module):\n    \"\"\"\n    A base class for implementing YOLO models, unifying APIs across different model types.\n    This class provides a common interface for various operations related to YOLO models, such as training,\n    validation, prediction, exporting, and benchmarking. It handles different types of models, including those\n    loaded from local files, Ultralytics HUB, or Triton Server. The class is designed to be flexible and\n    extendable for different tasks and model configurations.\n    Args:\n        model (Union[str, Path], optional): Path or name of the model to load or create. This can be a local file\n            path, a model name from Ultralytics HUB, or a Triton Server model. Defaults to 'yolov8n.pt'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "peekOfCode": "class BasePredictor:\n    \"\"\"\n    BasePredictor.\n    A base class for creating predictors.\n    Attributes:\n        args (SimpleNamespace): Configuration for the predictor.\n        save_dir (Path): Directory to save results.\n        done_warmup (bool): Whether the predictor has finished setup.\n        model (nn.Module): Model used for prediction.\n        data (dict): Data configuration.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "STREAM_WARNING",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "peekOfCode": "STREAM_WARNING = \"\"\"\nWARNING  inference results will accumulate in RAM unless `stream=True` is passed, causing potential out-of-memory\nerrors for large sources or long-running streams and videos. See https://docs.ultralytics.com/modes/predict/ for help.\nExample:\n    results = model(source=..., stream=True)  # generator of Results objects\n    for r in results:\n        boxes = r.boxes  # Boxes object for bbox outputs\n        masks = r.masks  # Masks object for segment masks outputs\n        probs = r.probs  # Class probabilities for classification outputs\n\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BaseTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class BaseTensor(SimpleClass):\n    \"\"\"Base tensor class with additional methods for easy manipulation and device handling.\"\"\"\n    def __init__(self, data, orig_shape) -> None:\n        \"\"\"\n        Initialize BaseTensor with data and original shape.\n        Args:\n            data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.\n            orig_shape (tuple): Original shape of image.\n        \"\"\"\n        assert isinstance(data, (torch.Tensor, np.ndarray))",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class Results(SimpleClass):\n    \"\"\"\n    A class for storing and manipulating inference results.\n    Attributes:\n        orig_img (numpy.ndarray): Original image as a numpy array.\n        orig_shape (tuple): Original image shape in (height, width) format.\n        boxes (Boxes, optional): Object containing detection bounding boxes.\n        masks (Masks, optional): Object containing detection masks.\n        probs (Probs, optional): Object containing class probabilities for classification tasks.\n        keypoints (Keypoints, optional): Object containing detected keypoints for each object.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Boxes",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class Boxes(BaseTensor):\n    \"\"\"\n    Manages detection boxes, providing easy access and manipulation of box coordinates, confidence scores, class\n    identifiers, and optional tracking IDs. Supports multiple formats for box coordinates, including both absolute and\n    normalized forms.\n    Attributes:\n        data (torch.Tensor): The raw tensor containing detection boxes and their associated data.\n        orig_shape (tuple): The original image size as a tuple (height, width), used for normalization.\n        is_track (bool): Indicates whether tracking IDs are included in the box data.\n    Properties:",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Masks",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class Masks(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection masks.\n    Attributes:\n        xy (list): A list of segments in pixel coordinates.\n        xyn (list): A list of normalized segments.\n    Methods:\n        cpu(): Returns the masks tensor on CPU memory.\n        numpy(): Returns the masks tensor as a numpy array.\n        cuda(): Returns the masks tensor on GPU memory.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Keypoints",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class Keypoints(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection keypoints.\n    Attributes:\n        xy (torch.Tensor): A collection of keypoints containing x, y coordinates for each detection.\n        xyn (torch.Tensor): A normalized version of xy with coordinates in the range [0, 1].\n        conf (torch.Tensor): Confidence values associated with keypoints if available, otherwise None.\n    Methods:\n        cpu(): Returns a copy of the keypoints tensor on CPU memory.\n        numpy(): Returns a copy of the keypoints tensor as a numpy array.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Probs",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class Probs(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating classification predictions.\n    Attributes:\n        top1 (int): Index of the top 1 class.\n        top5 (list[int]): Indices of the top 5 classes.\n        top1conf (torch.Tensor): Confidence of the top 1 class.\n        top5conf (torch.Tensor): Confidences of the top 5 classes.\n    Methods:\n        cpu(): Returns a copy of the probs tensor on CPU memory.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "OBB",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "peekOfCode": "class OBB(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating Oriented Bounding Boxes (OBB).\n    Args:\n        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,\n            with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values.\n            If present, the third last column contains track IDs, and the fifth column from the left contains rotation.\n        orig_shape (tuple): Original image size, in the format (height, width).\n    Attributes:\n        xywhr (torch.Tensor | numpy.ndarray): The boxes in [x_center, y_center, width, height, rotation] format.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.trainer",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.trainer",
        "peekOfCode": "class BaseTrainer:\n    \"\"\"\n    BaseTrainer.\n    A base class for creating trainers.\n    Attributes:\n        args (SimpleNamespace): Configuration for the trainer.\n        validator (BaseValidator): Validator instance.\n        model (nn.Module): Model instance.\n        callbacks (defaultdict): Dictionary of callbacks.\n        save_dir (Path): Directory to save results.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "Tuner",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.tuner",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.tuner",
        "peekOfCode": "class Tuner:\n    \"\"\"\n    Class responsible for hyperparameter tuning of YOLO models.\n    The class evolves YOLO model hyperparameters over a given number of iterations\n    by mutating them according to the search space and retraining the model to evaluate their performance.\n    Attributes:\n        space (dict): Hyperparameter search space containing bounds and scaling factors for mutation.\n        tune_dir (Path): Directory where evolution logs and results will be saved.\n        tune_csv (Path): Path to the CSV file where evolution logs are saved.\n    Methods:",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.tuner",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.engine.validator",
        "description": "Identification.yolov10.build.lib.ultralytics.engine.validator",
        "peekOfCode": "class BaseValidator:\n    \"\"\"\n    BaseValidator.\n    A base class for creating validators.\n    Attributes:\n        args (SimpleNamespace): Configuration for the validator.\n        dataloader (DataLoader): Dataloader to use for validation.\n        pbar (tqdm): Progress bar to update during validation.\n        model (nn.Module): Model to validate.\n        data (dict): Data dictionary.",
        "detail": "Identification.yolov10.build.lib.ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "Auth",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "peekOfCode": "class Auth:\n    \"\"\"\n    Manages authentication processes including API key handling, cookie-based authentication, and header generation.\n    The class supports different methods of authentication:\n    1. Directly using an API key.\n    2. Authenticating using browser cookies (specifically in Google Colab).\n    3. Prompting the user to enter an API key.\n    Attributes:\n        id_token (str or bool): Token used for identity verification, initialized as False.\n        api_key (str or bool): API key for authentication, initialized as False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "documentation": {}
    },
    {
        "label": "API_KEY_URL",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "peekOfCode": "API_KEY_URL = f\"{HUB_WEB_ROOT}/settings?tab=api+keys\"\nclass Auth:\n    \"\"\"\n    Manages authentication processes including API key handling, cookie-based authentication, and header generation.\n    The class supports different methods of authentication:\n    1. Directly using an API key.\n    2. Authenticating using browser cookies (specifically in Google Colab).\n    3. Prompting the user to enter an API key.\n    Attributes:\n        id_token (str or bool): Token used for identity verification, initialized as False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.auth",
        "documentation": {}
    },
    {
        "label": "HUBTrainingSession",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "peekOfCode": "class HUBTrainingSession:\n    \"\"\"\n    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.\n    Attributes:\n        agent_id (str): Identifier for the instance communicating with the server.\n        model_id (str): Identifier for the YOLO model being trained.\n        model_url (str): URL for the model in Ultralytics HUB.\n        api_url (str): API URL for the model in Ultralytics HUB.\n        auth_header (dict): Authentication header for the Ultralytics HUB API requests.\n        rate_limits (dict): Rate limits for different API calls (in seconds).",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "documentation": {}
    },
    {
        "label": "AGENT_NAME",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "peekOfCode": "AGENT_NAME = f\"python-{__version__}-colab\" if is_colab() else f\"python-{__version__}-local\"\nclass HUBTrainingSession:\n    \"\"\"\n    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.\n    Attributes:\n        agent_id (str): Identifier for the instance communicating with the server.\n        model_id (str): Identifier for the YOLO model being trained.\n        model_url (str): URL for the model in Ultralytics HUB.\n        api_url (str): API URL for the model in Ultralytics HUB.\n        auth_header (dict): Authentication header for the Ultralytics HUB API requests.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.session",
        "documentation": {}
    },
    {
        "label": "Events",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "class Events:\n    \"\"\"\n    A class for collecting anonymous event analytics. Event analytics are enabled when sync=True in settings and\n    disabled when sync=False. Run 'yolo settings' to see and update settings YAML file.\n    Attributes:\n        url (str): The URL to send anonymous events.\n        rate_limit (float): The rate limit in seconds for sending events.\n        metadata (dict): A dictionary containing metadata about the environment.\n        enabled (bool): A flag to enable or disable Events based on certain conditions.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "request_with_credentials",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "def request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:\n        OSError: If the function is not run in a Google Colab environment.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "requests_with_progress",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "def requests_with_progress(method, url, **kwargs):\n    \"\"\"\n    Make an HTTP request using the specified method and URL, with an optional progress bar.\n    Args:\n        method (str): The HTTP method to use (e.g. 'GET', 'POST').\n        url (str): The URL to send the request to.\n        **kwargs (any): Additional keyword arguments to pass to the underlying `requests.request` function.\n    Returns:\n        (requests.Response): The response object from the HTTP request.\n    Note:",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "smart_request",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "def smart_request(method, url, retry=3, timeout=30, thread=True, code=-1, verbose=True, progress=False, **kwargs):\n    \"\"\"\n    Makes an HTTP request using the 'requests' library, with exponential backoff retries up to a specified timeout.\n    Args:\n        method (str): The HTTP method to use for the request. Choices are 'post' and 'get'.\n        url (str): The URL to make the request to.\n        retry (int, optional): Number of retries to attempt before giving up. Default is 3.\n        timeout (int, optional): Timeout in seconds after which the function will give up retrying. Default is 30.\n        thread (bool, optional): Whether to execute the request in a separate daemon thread. Default is True.\n        code (int, optional): An identifier for the request, used for logging purposes. Default is -1.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_API_ROOT",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "HUB_API_ROOT = os.environ.get(\"ULTRALYTICS_HUB_API\", \"https://api.ultralytics.com\")\nHUB_WEB_ROOT = os.environ.get(\"ULTRALYTICS_HUB_WEB\", \"https://hub.ultralytics.com\")\nPREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "HUB_WEB_ROOT = os.environ.get(\"ULTRALYTICS_HUB_WEB\", \"https://hub.ultralytics.com\")\nPREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "PREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HELP_MSG",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "HELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:\n        OSError: If the function is not run in a Google Colab environment.",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "events",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "peekOfCode": "events = Events()",
        "detail": "Identification.yolov10.build.lib.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "FastSAM",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.model",
        "peekOfCode": "class FastSAM(Model):\n    \"\"\"\n    FastSAM model interface.\n    Example:\n        ```python\n        from ultralytics import FastSAM\n        model = FastSAM('last.pt')\n        results = model.predict('ultralytics/assets/bus.jpg')\n        ```\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.model",
        "documentation": {}
    },
    {
        "label": "FastSAMPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.predict",
        "peekOfCode": "class FastSAMPredictor(DetectionPredictor):\n    \"\"\"\n    FastSAMPredictor is specialized for fast SAM (Segment Anything Model) segmentation prediction tasks in Ultralytics\n    YOLO framework.\n    This class extends the DetectionPredictor, customizing the prediction pipeline specifically for fast SAM.\n    It adjusts post-processing steps to incorporate mask prediction and non-max suppression while optimizing\n    for single-class segmentation.\n    Attributes:\n        cfg (dict): Configuration parameters for prediction.\n        overrides (dict, optional): Optional parameter overrides for custom behavior.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.predict",
        "documentation": {}
    },
    {
        "label": "FastSAMPrompt",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.prompt",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.prompt",
        "peekOfCode": "class FastSAMPrompt:\n    \"\"\"\n    Fast Segment Anything Model class for image annotation and visualization.\n    Attributes:\n        device (str): Computing device ('cuda' or 'cpu').\n        results: Object detection or segmentation results.\n        source: Source image or image path.\n        clip: CLIP model for linear assignment.\n    \"\"\"\n    def __init__(self, source, results, device=\"cuda\") -> None:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.prompt",
        "documentation": {}
    },
    {
        "label": "adjust_bboxes_to_image_border",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "peekOfCode": "def adjust_bboxes_to_image_border(boxes, image_shape, threshold=20):\n    \"\"\"\n    Adjust bounding boxes to stick to image border if they are within a certain threshold.\n    Args:\n        boxes (torch.Tensor): (n, 4)\n        image_shape (tuple): (height, width)\n        threshold (int): pixel threshold\n    Returns:\n        adjusted_boxes (torch.Tensor): adjusted bounding boxes\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "peekOfCode": "def bbox_iou(box1, boxes, iou_thres=0.9, image_shape=(640, 640), raw_output=False):\n    \"\"\"\n    Compute the Intersection-Over-Union of a bounding box with respect to an array of other bounding boxes.\n    Args:\n        box1 (torch.Tensor): (4, )\n        boxes (torch.Tensor): (n, 4)\n        iou_thres (float): IoU threshold\n        image_shape (tuple): (height, width)\n        raw_output (bool): If True, return the raw IoU values instead of the indices\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "FastSAMValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.fastsam.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.fastsam.val",
        "peekOfCode": "class FastSAMValidator(SegmentationValidator):\n    \"\"\"\n    Custom validation class for fast SAM (Segment Anything Model) segmentation in Ultralytics YOLO framework.\n    Extends the SegmentationValidator class, customizing the validation process specifically for fast SAM. This class\n    sets the task to 'segment' and uses the SegmentMetrics for evaluation. Additionally, plotting features are disabled\n    to avoid errors during validation.\n    Attributes:\n        dataloader: The data loader object used for validation.\n        save_dir (str): The directory where validation results will be saved.\n        pbar: A progress bar object.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.fastsam.val",
        "documentation": {}
    },
    {
        "label": "NAS",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.nas.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.nas.model",
        "peekOfCode": "class NAS(Model):\n    \"\"\"\n    YOLO NAS model for object detection.\n    This class provides an interface for the YOLO-NAS models and extends the `Model` class from Ultralytics engine.\n    It is designed to facilitate the task of object detection using pre-trained or custom-trained YOLO-NAS models.\n    Example:\n        ```python\n        from ultralytics import NAS\n        model = NAS('yolo_nas_s')\n        results = model.predict('ultralytics/assets/bus.jpg')",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.nas.model",
        "documentation": {}
    },
    {
        "label": "NASPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.nas.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.nas.predict",
        "peekOfCode": "class NASPredictor(BasePredictor):\n    \"\"\"\n    Ultralytics YOLO NAS Predictor for object detection.\n    This class extends the `BasePredictor` from Ultralytics engine and is responsible for post-processing the\n    raw predictions generated by the YOLO NAS models. It applies operations like non-maximum suppression and\n    scaling the bounding boxes to fit the original image dimensions.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.nas.predict",
        "documentation": {}
    },
    {
        "label": "NASValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "peekOfCode": "class NASValidator(DetectionValidator):\n    \"\"\"\n    Ultralytics YOLO NAS Validator for object detection.\n    Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions\n    generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes,\n    ultimately producing the final detections.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.\n        lb (torch.Tensor): Optional tensor for multilabel NMS.\n    Example:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "peekOfCode": "__all__ = [\"NASValidator\"]\nclass NASValidator(DetectionValidator):\n    \"\"\"\n    Ultralytics YOLO NAS Validator for object detection.\n    Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions\n    generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes,\n    ultimately producing the final detections.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.\n        lb (torch.Tensor): Optional tensor for multilabel NMS.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.nas.val",
        "documentation": {}
    },
    {
        "label": "RTDETR",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.model",
        "peekOfCode": "class RTDETR(Model):\n    \"\"\"\n    Interface for Baidu's RT-DETR model. This Vision Transformer-based object detector provides real-time performance\n    with high accuracy. It supports efficient hybrid encoding, IoU-aware query selection, and adaptable inference speed.\n    Attributes:\n        model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.\n    \"\"\"\n    def __init__(self, model=\"rtdetr-l.pt\") -> None:\n        \"\"\"\n        Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.model",
        "documentation": {}
    },
    {
        "label": "RTDETRPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.predict",
        "peekOfCode": "class RTDETRPredictor(BasePredictor):\n    \"\"\"\n    RT-DETR (Real-Time Detection Transformer) Predictor extending the BasePredictor class for making predictions using\n    Baidu's RT-DETR model.\n    This class leverages the power of Vision Transformers to provide real-time object detection while maintaining\n    high accuracy. It supports key features like efficient hybrid encoding and IoU-aware query selection.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.rtdetr import RTDETRPredictor",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.predict",
        "documentation": {}
    },
    {
        "label": "RTDETRTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.train",
        "peekOfCode": "class RTDETRTrainer(DetectionTrainer):\n    \"\"\"\n    Trainer class for the RT-DETR model developed by Baidu for real-time object detection. Extends the DetectionTrainer\n    class for YOLO to adapt to the specific features and architecture of RT-DETR. This model leverages Vision\n    Transformers and has capabilities like IoU-aware query selection and adaptable inference speed.\n    Notes:\n        - F.grid_sample used in RT-DETR does not support the `deterministic=True` argument.\n        - AMP training can lead to NaN outputs and may produce errors during bipartite graph matching.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.train",
        "documentation": {}
    },
    {
        "label": "RTDETRDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "peekOfCode": "class RTDETRDataset(YOLODataset):\n    \"\"\"\n    Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.\n    This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for\n    real-time detection and tracking tasks.\n    \"\"\"\n    def __init__(self, *args, data=None, **kwargs):\n        \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n        super().__init__(*args, data=data, **kwargs)\n    # NOTE: add stretch version load_image for RTDETR mosaic",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "RTDETRValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "peekOfCode": "class RTDETRValidator(DetectionValidator):\n    \"\"\"\n    RTDETRValidator extends the DetectionValidator class to provide validation capabilities specifically tailored for\n    the RT-DETR (Real-Time DETR) object detection model.\n    The class allows building of an RTDETR-specific dataset for validation, applies Non-maximum suppression for\n    post-processing, and updates evaluation metrics accordingly.\n    Example:\n        ```python\n        from ultralytics.models.rtdetr import RTDETRValidator\n        args = dict(model='rtdetr-l.pt', data='coco8.yaml')",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "peekOfCode": "__all__ = (\"RTDETRValidator\",)  # tuple or list\nclass RTDETRDataset(YOLODataset):\n    \"\"\"\n    Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.\n    This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for\n    real-time detection and tracking tasks.\n    \"\"\"\n    def __init__(self, *args, data=None, **kwargs):\n        \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n        super().__init__(*args, data=data, **kwargs)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "MaskDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "peekOfCode": "class MaskDecoder(nn.Module):\n    \"\"\"\n    Decoder module for generating masks and their associated quality scores, using a transformer architecture to predict\n    masks given image and prompt embeddings.\n    Attributes:\n        transformer_dim (int): Channel dimension for the transformer module.\n        transformer (nn.Module): The transformer module used for mask prediction.\n        num_multimask_outputs (int): Number of masks to predict for disambiguating masks.\n        iou_token (nn.Embedding): Embedding for the IoU token.\n        num_mask_tokens (int): Number of mask tokens.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "documentation": {}
    },
    {
        "label": "MLP",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "peekOfCode": "class MLP(nn.Module):\n    \"\"\"\n    MLP (Multi-Layer Perceptron) model lightly adapted from\n    https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py\n    \"\"\"\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.decoders",
        "documentation": {}
    },
    {
        "label": "ImageEncoderViT",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class ImageEncoderViT(nn.Module):\n    \"\"\"\n    An image encoder using Vision Transformer (ViT) architecture for encoding an image into a compact latent space. The\n    encoder takes an image, splits it into patches, and processes these patches through a series of transformer blocks.\n    The encoded patches are then processed through a neck to generate the final encoded representation.\n    This class and its supporting functions below lightly adapted from the ViTDet backbone available at\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py.\n    Attributes:\n        img_size (int): Dimension of input images, assumed to be square.\n        patch_embed (PatchEmbed): Module for patch embedding.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PromptEncoder",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PromptEncoder(nn.Module):\n    \"\"\"\n    Encodes different types of prompts, including points, boxes, and masks, for input to SAM's mask decoder. The encoder\n    produces both sparse and dense embeddings for the input prompts.\n    Attributes:\n        embed_dim (int): Dimension of the embeddings.\n        input_image_size (Tuple[int, int]): Size of the input image as (H, W).\n        image_embedding_size (Tuple[int, int]): Spatial size of the image embedding as (H, W).\n        pe_layer (PositionEmbeddingRandom): Module for random position embedding.\n        num_point_embeddings (int): Number of point embeddings for different types of points.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PositionEmbeddingRandom",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PositionEmbeddingRandom(nn.Module):\n    \"\"\"Positional encoding using random spatial frequencies.\"\"\"\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        \"\"\"Initializes a position embedding using random spatial frequencies.\"\"\"\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\"positional_encoding_gaussian_matrix\", scale * torch.randn((2, num_pos_feats)))\n        # Set non-deterministic for forward() error 'cumsum_cuda_kernel does not have a deterministic implementation'\n        torch.use_deterministic_algorithms(False)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Block",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class Block(nn.Module):\n    \"\"\"Transformer blocks with support of window attention and residual propagation blocks.\"\"\"\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class Attention(nn.Module):\n    \"\"\"Multi-head Attention block with relative position embeddings.\"\"\"\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int = 8,\n        qkv_bias: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        input_size: Optional[Tuple[int, int]] = None,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PatchEmbed(nn.Module):\n    \"\"\"Image to Patch Embedding.\"\"\"\n    def __init__(\n        self,\n        kernel_size: Tuple[int, int] = (16, 16),\n        stride: Tuple[int, int] = (16, 16),\n        padding: Tuple[int, int] = (0, 0),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ) -> None:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "window_partition",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def window_partition(x: torch.Tensor, window_size: int) -> Tuple[torch.Tensor, Tuple[int, int]]:\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "window_unpartition",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def window_unpartition(\n    windows: torch.Tensor, window_size: int, pad_hw: Tuple[int, int], hw: Tuple[int, int]\n) -> torch.Tensor:\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n    Args:\n        windows (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "get_rel_pos",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def get_rel_pos(q_size: int, k_size: int, rel_pos: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Get relative positional embeddings according to the relative positions of query and key sizes.\n    Args:\n        q_size (int): size of query q.\n        k_size (int): size of key k.\n        rel_pos (Tensor): relative position embeddings (L, C).\n    Returns:\n        Extracted positional embeddings according to relative positions.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "add_decomposed_rel_pos",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def add_decomposed_rel_pos(\n    attn: torch.Tensor,\n    q: torch.Tensor,\n    rel_pos_h: torch.Tensor,\n    rel_pos_w: torch.Tensor,\n    q_size: Tuple[int, int],\n    k_size: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Calculate decomposed Relative Positional Embeddings from mvitv2 paper at",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Sam",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.sam",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.sam",
        "peekOfCode": "class Sam(nn.Module):\n    \"\"\"\n    Sam (Segment Anything Model) is designed for object segmentation tasks. It uses image encoders to generate image\n    embeddings, and prompt encoders to encode various types of input prompts. These embeddings are then used by the mask\n    decoder to predict object masks.\n    Attributes:\n        mask_threshold (float): Threshold value for mask prediction.\n        image_format (str): Format of the input image, default is 'RGB'.\n        image_encoder (ImageEncoderViT): The backbone used to encode the image into embeddings.\n        prompt_encoder (PromptEncoder): Encodes various types of input prompts.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.sam",
        "documentation": {}
    },
    {
        "label": "Conv2d_BN",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Conv2d_BN(torch.nn.Sequential):\n    \"\"\"A sequential container that performs 2D convolution followed by batch normalization.\"\"\"\n    def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1):\n        \"\"\"Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and\n        drop path.\n        \"\"\"\n        super().__init__()\n        self.add_module(\"c\", torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))\n        bn = torch.nn.BatchNorm2d(b)\n        torch.nn.init.constant_(bn.weight, bn_weight_init)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class PatchEmbed(nn.Module):\n    \"\"\"Embeds images into patches and projects them into a specified embedding dimension.\"\"\"\n    def __init__(self, in_chans, embed_dim, resolution, activation):\n        \"\"\"Initialize the PatchMerging class with specified input, output dimensions, resolution and activation\n        function.\n        \"\"\"\n        super().__init__()\n        img_size: Tuple[int, int] = to_2tuple(resolution)\n        self.patches_resolution = (img_size[0] // 4, img_size[1] // 4)\n        self.num_patches = self.patches_resolution[0] * self.patches_resolution[1]",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "MBConv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class MBConv(nn.Module):\n    \"\"\"Mobile Inverted Bottleneck Conv (MBConv) layer, part of the EfficientNet architecture.\"\"\"\n    def __init__(self, in_chans, out_chans, expand_ratio, activation, drop_path):\n        \"\"\"Initializes a convolutional layer with specified dimensions, input resolution, depth, and activation\n        function.\n        \"\"\"\n        super().__init__()\n        self.in_chans = in_chans\n        self.hidden_chans = int(in_chans * expand_ratio)\n        self.out_chans = out_chans",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "PatchMerging",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class PatchMerging(nn.Module):\n    \"\"\"Merges neighboring patches in the feature map and projects to a new dimension.\"\"\"\n    def __init__(self, input_resolution, dim, out_dim, activation):\n        \"\"\"Initializes the ConvLayer with specific dimension, input resolution, depth, activation, drop path, and other\n        optional parameters.\n        \"\"\"\n        super().__init__()\n        self.input_resolution = input_resolution\n        self.dim = dim\n        self.out_dim = out_dim",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "ConvLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class ConvLayer(nn.Module):\n    \"\"\"\n    Convolutional Layer featuring multiple MobileNetV3-style inverted bottleneck convolutions (MBConv).\n    Optionally applies downsample operations to the output, and provides support for gradient checkpointing.\n    \"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Mlp(nn.Module):\n    \"\"\"\n    Multi-layer Perceptron (MLP) for transformer architectures.\n    This layer takes an input with in_features, applies layer normalization and two fully-connected layers.\n    \"\"\"\n    def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0):\n        \"\"\"Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc.\"\"\"\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Attention(torch.nn.Module):\n    \"\"\"\n    Multi-head attention module with support for spatial awareness, applying attention biases based on spatial\n    resolution. Implements trainable attention biases for each unique offset between spatial positions in the resolution\n    grid.\n    Attributes:\n        ab (Tensor, optional): Cached attention biases for inference, deleted during training.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TinyViTBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class TinyViTBlock(nn.Module):\n    \"\"\"TinyViT Block that applies self-attention and a local convolution to the input.\"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        num_heads,\n        window_size=7,\n        mlp_ratio=4.0,\n        drop=0.0,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "BasicLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class BasicLayer(nn.Module):\n    \"\"\"A basic TinyViT layer for one stage in a TinyViT architecture.\"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,\n        num_heads,\n        window_size,\n        mlp_ratio=4.0,",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class LayerNorm2d(nn.Module):\n    \"\"\"A PyTorch implementation of Layer Normalization in 2D.\"\"\"\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        \"\"\"Initialize LayerNorm2d with the number of channels and an optional epsilon.\"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Perform a forward pass, normalizing the input tensor.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TinyViT",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class TinyViT(nn.Module):\n    \"\"\"\n    The TinyViT architecture for vision tasks.\n    Attributes:\n        img_size (int): Input image size.\n        in_chans (int): Number of input channels.\n        num_classes (int): Number of classification classes.\n        embed_dims (List[int]): List of embedding dimensions for each layer.\n        depths (List[int]): List of depths for each layer.\n        num_heads (List[int]): List of number of attention heads for each layer.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TwoWayTransformer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class TwoWayTransformer(nn.Module):\n    \"\"\"\n    A Two-Way Transformer module that enables the simultaneous attention to both image and query points. This class\n    serves as a specialized transformer decoder that attends to an input image using queries whose positional embedding\n    is supplied. This is particularly useful for tasks like object detection, image segmentation, and point cloud\n    processing.\n    Attributes:\n        depth (int): The number of layers in the transformer.\n        embedding_dim (int): The channel dimension for the input embeddings.\n        num_heads (int): The number of heads for multihead attention.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TwoWayAttentionBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class TwoWayAttentionBlock(nn.Module):\n    \"\"\"\n    An attention block that performs both self-attention and cross-attention in two directions: queries to keys and\n    keys to queries. This block consists of four main layers: (1) self-attention on sparse inputs, (2) cross-attention\n    of sparse inputs to dense inputs, (3) an MLP block on sparse inputs, and (4) cross-attention of dense inputs to\n    sparse inputs.\n    Attributes:\n        self_attn (Attention): The self-attention layer for the queries.\n        norm1 (nn.LayerNorm): Layer normalization following the first attention block.\n        cross_attn_token_to_image (Attention): Cross-attention layer from queries to keys.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class Attention(nn.Module):\n    \"\"\"An attention layer that allows for downscaling the size of the embedding after projection to queries, keys, and\n    values.\n    \"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -> None:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "is_box_near_crop_edge",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -> torch.Tensor:\n    \"\"\"Return a boolean tensor indicating if boxes are near the crop edge.\"\"\"\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "batch_iterator",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    \"\"\"Yield batches of data from the input arguments.\"\"\"\n    assert args and all(len(a) == len(args[0]) for a in args), \"Batched iteration must have same-size inputs.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\ndef calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks.\n    The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "calculate_stability_score",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks.\n    The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high\n    and low values.\n    Notes:\n        - One mask is always contained inside the other.\n        - Save memory by preventing unnecessary cast to torch.int64\n    \"\"\"\n    intersections = (masks > (mask_threshold + threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_point_grid",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def build_point_grid(n_per_side: int) -> np.ndarray:\n    \"\"\"Generate a 2D grid of evenly spaced points in the range [0,1]x[0,1].\"\"\"\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    return np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\ndef build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:\n    \"\"\"Generate point grids for all crop layers.\"\"\"\n    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_all_layer_point_grids",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:\n    \"\"\"Generate point grids for all crop layers.\"\"\"\n    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]\ndef generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes.\n    Each layer has (2**i)**2 boxes for the ith layer.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "generate_crop_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes.\n    Each layer has (2**i)**2 boxes for the ith layer.\n    \"\"\"\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_boxes_xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop bounding boxes by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\ndef uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop points by adding the crop box offset.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_points",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop points by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\ndef uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -> torch.Tensor:\n    \"\"\"Uncrop masks by padding them to the original image size.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_masks",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -> torch.Tensor:\n    \"\"\"Uncrop masks by padding them to the original image size.\"\"\"\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)\ndef remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "remove_small_regions",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:\n    \"\"\"Remove small disconnected regions or holes in a mask, returning the mask and a modification indicator.\"\"\"\n    import cv2  # type: ignore\n    assert mode in {\"holes\", \"islands\"}\n    correct_holes = mode == \"holes\"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]\n    if not small_regions:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "batched_mask_to_box",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "peekOfCode": "def batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks.\n    Return [0,0,0,0] for an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n    # Normalize shape to CxHxW\n    shape = masks.shape",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_h",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_h(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) h-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )\ndef build_sam_vit_l(checkpoint=None):",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_l",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_l(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) l-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )\ndef build_sam_vit_b(checkpoint=None):",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_b",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_b(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) b-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )\ndef build_mobile_sam(checkpoint=None):",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_mobile_sam",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "def build_mobile_sam(checkpoint=None):\n    \"\"\"Build and return Mobile Segment Anything Model (Mobile-SAM).\"\"\"\n    return _build_sam(\n        encoder_embed_dim=[64, 128, 160, 320],\n        encoder_depth=[2, 2, 6, 2],\n        encoder_num_heads=[2, 4, 5, 10],\n        encoder_global_attn_indexes=None,\n        mobile_sam=True,\n        checkpoint=checkpoint,\n    )",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam(ckpt=\"sam_b.pt\"):\n    \"\"\"Build a SAM model specified by ckpt.\"\"\"\n    model_builder = None\n    ckpt = str(ckpt)  # to allow Path ckpt types\n    for k in sam_model_map.keys():\n        if ckpt.endswith(k):\n            model_builder = sam_model_map.get(k)\n    if not model_builder:\n        raise FileNotFoundError(f\"{ckpt} is not a supported SAM model. Available models are: \\n {sam_model_map.keys()}\")\n    return model_builder(ckpt)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "sam_model_map",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "peekOfCode": "sam_model_map = {\n    \"sam_h.pt\": build_sam_vit_h,\n    \"sam_l.pt\": build_sam_vit_l,\n    \"sam_b.pt\": build_sam_vit_b,\n    \"mobile_sam.pt\": build_mobile_sam,\n}\ndef build_sam(ckpt=\"sam_b.pt\"):\n    \"\"\"Build a SAM model specified by ckpt.\"\"\"\n    model_builder = None\n    ckpt = str(ckpt)  # to allow Path ckpt types",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "SAM",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.model",
        "peekOfCode": "class SAM(Model):\n    \"\"\"\n    SAM (Segment Anything Model) interface class.\n    SAM is designed for promptable real-time image segmentation. It can be used with a variety of prompts such as\n    bounding boxes, points, or labels. The model has capabilities for zero-shot performance and is trained on the SA-1B\n    dataset.\n    \"\"\"\n    def __init__(self, model=\"sam_b.pt\") -> None:\n        \"\"\"\n        Initializes the SAM model with a pre-trained model file.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.model",
        "documentation": {}
    },
    {
        "label": "Predictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.sam.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.sam.predict",
        "peekOfCode": "class Predictor(BasePredictor):\n    \"\"\"\n    Predictor class for the Segment Anything Model (SAM), extending BasePredictor.\n    The class provides an interface for model inference tailored to image segmentation tasks.\n    With advanced architecture and promptable segmentation capabilities, it facilitates flexible and real-time\n    mask generation. The class is capable of working with various types of prompts such as bounding boxes,\n    points, and low-resolution masks.\n    Attributes:\n        cfg (dict): Configuration dictionary specifying model and task-related parameters.\n        overrides (dict): Dictionary containing values that override the default configuration.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.sam.predict",
        "documentation": {}
    },
    {
        "label": "DETRLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "peekOfCode": "class DETRLoss(nn.Module):\n    \"\"\"\n    DETR (DEtection TRansformer) Loss class. This class calculates and returns the different loss components for the\n    DETR object detection model. It computes classification loss, bounding box loss, GIoU loss, and optionally auxiliary\n    losses.\n    Attributes:\n        nc (int): The number of classes.\n        loss_gain (dict): Coefficients for different loss components.\n        aux_loss (bool): Whether to compute auxiliary losses.\n        use_fl (bool): Use FocalLoss or not.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "peekOfCode": "class RTDETRDetectionLoss(DETRLoss):\n    \"\"\"\n    Real-Time DeepTracker (RT-DETR) Detection Loss class that extends the DETRLoss.\n    This class computes the detection loss for the RT-DETR model, which includes the standard detection loss as well as\n    an additional denoising training loss when provided with denoising metadata.\n    \"\"\"\n    def forward(self, preds, batch, dn_bboxes=None, dn_scores=None, dn_meta=None):\n        \"\"\"\n        Forward pass to compute the detection loss.\n        Args:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.utils.loss",
        "documentation": {}
    },
    {
        "label": "HungarianMatcher",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "peekOfCode": "class HungarianMatcher(nn.Module):\n    \"\"\"\n    A module implementing the HungarianMatcher, which is a differentiable module to solve the assignment problem in an\n    end-to-end fashion.\n    HungarianMatcher performs optimal assignment over the predicted and ground truth bounding boxes using a cost\n    function that considers classification scores, bounding box coordinates, and optionally, mask predictions.\n    Attributes:\n        cost_gain (dict): Dictionary of cost coefficients: 'class', 'bbox', 'giou', 'mask', and 'dice'.\n        use_fl (bool): Indicates whether to use Focal Loss for the classification cost calculation.\n        with_mask (bool): Indicates whether the model makes mask predictions.",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "documentation": {}
    },
    {
        "label": "get_cdn_group",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "peekOfCode": "def get_cdn_group(\n    batch, num_classes, num_queries, class_embed, num_dn=100, cls_noise_ratio=0.5, box_noise_scale=1.0, training=False\n):\n    \"\"\"\n    Get contrastive denoising training group. This function creates a contrastive denoising training group with positive\n    and negative samples from the ground truths (gt). It applies noise to the class labels and bounding box coordinates,\n    and returns the modified labels, bounding boxes, attention mask and meta information.\n    Args:\n        batch (dict): A dict that includes 'gt_cls' (torch.Tensor with shape [num_gts, ]), 'gt_bboxes'\n            (torch.Tensor with shape [num_gts, 4]), 'gt_groups' (List(int)) which is a list of batch size length",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.utils.ops",
        "documentation": {}
    },
    {
        "label": "ClassificationPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.predict",
        "peekOfCode": "class ClassificationPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.classify import ClassificationPredictor\n        args = dict(model='yolov8n-cls.pt', source=ASSETS)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.predict",
        "documentation": {}
    },
    {
        "label": "ClassificationTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.train",
        "peekOfCode": "class ClassificationTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationTrainer\n        args = dict(model='yolov8n-cls.pt', data='imagenet10', epochs=3)\n        trainer = ClassificationTrainer(overrides=args)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.train",
        "documentation": {}
    },
    {
        "label": "ClassificationValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.val",
        "peekOfCode": "class ClassificationValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationValidator\n        args = dict(model='yolov8n-cls.pt', data='imagenet10')\n        validator = ClassificationValidator(args=args)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.classify.val",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.predict",
        "peekOfCode": "class DetectionPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a detection model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.detect import DetectionPredictor\n        args = dict(model='yolov8n.pt', source=ASSETS)\n        predictor = DetectionPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.train",
        "peekOfCode": "class DetectionTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a detection model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionTrainer\n        args = dict(model='yolov8n.pt', data='coco8.yaml', epochs=3)\n        trainer = DetectionTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.train",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.val",
        "peekOfCode": "class DetectionValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a detection model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionValidator\n        args = dict(model='yolov8n.pt', data='coco8.yaml')\n        validator = DetectionValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.detect.val",
        "documentation": {}
    },
    {
        "label": "OBBPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.predict",
        "peekOfCode": "class OBBPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.obb import OBBPredictor\n        args = dict(model='yolov8n-obb.pt', source=ASSETS)\n        predictor = OBBPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.predict",
        "documentation": {}
    },
    {
        "label": "OBBTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.train",
        "peekOfCode": "class OBBTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBTrainer\n        args = dict(model='yolov8n-obb.pt', data='dota8.yaml', epochs=3)\n        trainer = OBBTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.train",
        "documentation": {}
    },
    {
        "label": "OBBValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.val",
        "peekOfCode": "class OBBValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBValidator\n        args = dict(model='yolov8n-obb.pt', data='dota8.yaml')\n        validator = OBBValidator(args=args)\n        validator(model=args['model'])\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.obb.val",
        "documentation": {}
    },
    {
        "label": "PosePredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.predict",
        "peekOfCode": "class PosePredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a pose model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.pose import PosePredictor\n        args = dict(model='yolov8n-pose.pt', source=ASSETS)\n        predictor = PosePredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.predict",
        "documentation": {}
    },
    {
        "label": "PoseTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.train",
        "peekOfCode": "class PoseTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a pose model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseTrainer\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml', epochs=3)\n        trainer = PoseTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.train",
        "documentation": {}
    },
    {
        "label": "PoseValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.val",
        "peekOfCode": "class PoseValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a pose model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseValidator\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')\n        validator = PoseValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.pose.val",
        "documentation": {}
    },
    {
        "label": "SegmentationPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.predict",
        "peekOfCode": "class SegmentationPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.segment import SegmentationPredictor\n        args = dict(model='yolov8n-seg.pt', source=ASSETS)\n        predictor = SegmentationPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.predict",
        "documentation": {}
    },
    {
        "label": "SegmentationTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.train",
        "peekOfCode": "class SegmentationTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationTrainer\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\n        trainer = SegmentationTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.train",
        "documentation": {}
    },
    {
        "label": "SegmentationValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.val",
        "peekOfCode": "class SegmentationValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationValidator\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml')\n        validator = SegmentationValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.segment.val",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "peekOfCode": "class YOLO(Model):\n    \"\"\"YOLO (You Only Look Once) object detection model.\"\"\"\n    def __init__(self, model=\"yolov8n.pt\", task=None, verbose=False):\n        \"\"\"Initialize YOLO model, switching to YOLOWorld if model filename contains '-world'.\"\"\"\n        path = Path(model)\n        if \"-world\" in path.stem and path.suffix in {\".pt\", \".yaml\", \".yml\"}:  # if YOLOWorld PyTorch model\n            new_instance = YOLOWorld(path)\n            self.__class__ = type(new_instance)\n            self.__dict__ = new_instance.__dict__\n        elif \"yolov10\" in path.stem:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "YOLOWorld",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "peekOfCode": "class YOLOWorld(Model):\n    \"\"\"YOLO-World object detection model.\"\"\"\n    def __init__(self, model=\"yolov8s-world.pt\") -> None:\n        \"\"\"\n        Initializes the YOLOv8-World model with the given pre-trained model file. Supports *.pt and *.yaml formats.\n        Args:\n            model (str | Path): Path to the pre-trained model. Defaults to 'yolov8s-world.pt'.\n        \"\"\"\n        super().__init__(model=model, task=\"detect\")\n        # Assign default COCO class names when there are no custom names",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "card_template_text",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "peekOfCode": "card_template_text = \"\"\"\n---\nlicense: agpl-3.0\nlibrary_name: ultralytics\nrepo_url: https://github.com/THU-MIG/yolov10\ntags:\n- object-detection\n- computer-vision\n- yolov10\ndatasets:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "peekOfCode": "model = YOLOv10.from_pretrained('jameslahm/yolov10n')\n# Training\nmodel.train(...)\n# after training, one can push to the hub\nmodel.push_to_hub(\"your-hf-username/yolov10-finetuned\")\n# Validation\nmodel.val(...)\n```\n### Inference\nHere's an end-to-end example showcasing inference on a cats image:",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "peekOfCode": "model = YOLOv10.from_pretrained('jameslahm/yolov10n')\nsource = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nmodel.predict(source=source, save=True)\n```\nwhich shows:\n![image/png](https://cdn-uploads.huggingface.co/production/uploads/628ece6054698ce61d1e7be3/tBwAsKcQA_96HCYQp7BRr.png)\n### BibTeX Entry and Citation Info\n```\n@article{wang2024yolov10,\n  title={YOLOv10: Real-Time End-to-End Object Detection},",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "peekOfCode": "source = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nmodel.predict(source=source, save=True)\n```\nwhich shows:\n![image/png](https://cdn-uploads.huggingface.co/production/uploads/628ece6054698ce61d1e7be3/tBwAsKcQA_96HCYQp7BRr.png)\n### BibTeX Entry and Citation Info\n```\n@article{wang2024yolov10,\n  title={YOLOv10: Real-Time End-to-End Object Detection},\n  author={Wang, Ao and Chen, Hui and Liu, Lihao and Chen, Kai and Lin, Zijia and Han, Jungong and Ding, Guiguang},",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.model",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.model",
        "peekOfCode": "class YOLOv10(Model, PyTorchModelHubMixin, model_card_template=card_template_text):\n    def __init__(self, model=\"yolov10n.pt\", task=None, verbose=False, \n                 names=None):\n        super().__init__(model=model, task=task, verbose=verbose)\n        if names is not None:\n            setattr(self.model, 'names', names)\n    def push_to_hub(self, repo_name, **kwargs):\n        config = kwargs.get('config', {})\n        config['names'] = self.names\n        config['model'] = self.model.yaml['yaml_file']",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.model",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.predict",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.predict",
        "peekOfCode": "class YOLOv10DetectionPredictor(DetectionPredictor):\n    def postprocess(self, preds, img, orig_imgs):\n        if isinstance(preds, dict):\n            preds = preds[\"one2one\"]\n        if isinstance(preds, (list, tuple)):\n            preds = preds[0]\n        if preds.shape[-1] == 6:\n            pass\n        else:\n            preds = preds.transpose(-1, -2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.predict",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.train",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.train",
        "peekOfCode": "class YOLOv10DetectionTrainer(DetectionTrainer):\n    def get_validator(self):\n        \"\"\"Returns a DetectionValidator for YOLO model validation.\"\"\"\n        self.loss_names = \"box_om\", \"cls_om\", \"dfl_om\", \"box_oo\", \"cls_oo\", \"dfl_oo\", \n        return YOLOv10DetectionValidator(\n            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n        )\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Return a YOLO detection model.\"\"\"\n        model = YOLOv10DetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.train",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.models.yolov10.val",
        "description": "Identification.yolov10.build.lib.ultralytics.models.yolov10.val",
        "peekOfCode": "class YOLOv10DetectionValidator(DetectionValidator):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.args.save_json |= self.is_coco\n    def postprocess(self, preds):\n        if isinstance(preds, dict):\n            preds = preds[\"one2one\"]\n        if isinstance(preds, (list, tuple)):\n            preds = preds[0]\n        # Acknowledgement: Thanks to sanha9999 in #190 and #181!",
        "detail": "Identification.yolov10.build.lib.ultralytics.models.yolov10.val",
        "documentation": {}
    },
    {
        "label": "DFL",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class DFL(nn.Module):\n    \"\"\"\n    Integral module of Distribution Focal Loss (DFL).\n    Proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391\n    \"\"\"\n    def __init__(self, c1=16):\n        \"\"\"Initialize a convolutional layer with a given number of input channels.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, 1, 1, bias=False).requires_grad_(False)\n        x = torch.arange(c1, dtype=torch.float)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Proto",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class Proto(nn.Module):\n    \"\"\"YOLOv8 mask Proto module for segmentation models.\"\"\"\n    def __init__(self, c1, c_=256, c2=32):\n        \"\"\"\n        Initializes the YOLOv8 mask Proto module with specified number of protos and masks.\n        Input arguments are ch_in, number of protos, number of masks.\n        \"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c_, k=3)\n        self.upsample = nn.ConvTranspose2d(c_, c_, 2, 2, 0, bias=True)  # nn.Upsample(scale_factor=2, mode='nearest')",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "HGStem",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class HGStem(nn.Module):\n    \"\"\"\n    StemBlock of PPHGNetV2 with 5 convolutions and one maxpool2d.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, cm, c2):\n        \"\"\"Initialize the SPP layer with input/output channels and specified kernel sizes for max pooling.\"\"\"\n        super().__init__()\n        self.stem1 = Conv(c1, cm, 3, 2, act=nn.ReLU())\n        self.stem2a = Conv(cm, cm // 2, 2, 1, 0, act=nn.ReLU())",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "HGBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class HGBlock(nn.Module):\n    \"\"\"\n    HG_Block of PPHGNetV2 with 2 convolutions and LightConv.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, cm, c2, k=3, n=6, lightconv=False, shortcut=False, act=nn.ReLU()):\n        \"\"\"Initializes a CSP Bottleneck with 1 convolution using specified input and output channels.\"\"\"\n        super().__init__()\n        block = LightConv if lightconv else Conv\n        self.m = nn.ModuleList(block(c1 if i == 0 else cm, cm, k=k, act=act) for i in range(n))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPP",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class SPP(nn.Module):\n    \"\"\"Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729.\"\"\"\n    def __init__(self, c1, c2, k=(5, 9, 13)):\n        \"\"\"Initialize the SPP layer with input/output channels and pooling kernel sizes.\"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])\n    def forward(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPPF",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class SPPF(nn.Module):\n    \"\"\"Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher.\"\"\"\n    def __init__(self, c1, c2, k=5):\n        \"\"\"\n        Initializes the SPPF layer with given input/output channels and kernel size.\n        This module is equivalent to SPP(k=(5, 9, 13)).\n        \"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C1",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C1(nn.Module):\n    \"\"\"CSP Bottleneck with 1 convolution.\"\"\"\n    def __init__(self, c1, c2, n=1):\n        \"\"\"Initializes the CSP Bottleneck with configurations for 1 convolution with arguments ch_in, ch_out, number.\"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*(Conv(c2, c2, 3) for _ in range(n)))\n    def forward(self, x):\n        \"\"\"Applies cross-convolutions to input in the C3 module.\"\"\"\n        y = self.cv1(x)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C2(nn.Module):\n    \"\"\"CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck with 2 convolutions module with arguments ch_in, ch_out, number, shortcut,\n        groups, expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv(2 * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2f",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C2f(nn.Module):\n    \"\"\"Faster Implementation of CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv((2 + n) * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C3(nn.Module):\n    \"\"\"CSP Bottleneck with 3 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize the CSP Bottleneck with given channels, number, shortcut, groups, and expansion values.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, k=((1, 1), (3, 3)), e=1.0) for _ in range(n)))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3x",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C3x(C3):\n    \"\"\"C3 module with cross-convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3TR instance and set default parameters.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        self.c_ = int(c2 * e)\n        self.m = nn.Sequential(*(Bottleneck(self.c_, self.c_, shortcut, g, k=((1, 3), (3, 1)), e=1) for _ in range(n)))\nclass RepC3(nn.Module):\n    \"\"\"Rep C3.\"\"\"\n    def __init__(self, c1, c2, n=3, e=1.0):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepC3",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class RepC3(nn.Module):\n    \"\"\"Rep C3.\"\"\"\n    def __init__(self, c1, c2, n=3, e=1.0):\n        \"\"\"Initialize CSP Bottleneck with a single convolution using input channels, output channels, and number.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.cv2 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*[RepConv(c_, c_) for _ in range(n)])\n        self.cv3 = Conv(c_, c2, 1, 1) if c_ != c2 else nn.Identity()",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3TR",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C3TR(C3):\n    \"\"\"C3 module with TransformerBlock().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3Ghost module with GhostBottleneck().\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = TransformerBlock(c_, c_, 4, n)\nclass C3Ghost(C3):\n    \"\"\"C3 module with GhostBottleneck().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3Ghost",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C3Ghost(C3):\n    \"\"\"C3 module with GhostBottleneck().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize 'SPP' module with various pooling sizes for spatial pyramid pooling.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)  # hidden channels\n        self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))\nclass GhostBottleneck(nn.Module):\n    \"\"\"Ghost Bottleneck https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "GhostBottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class GhostBottleneck(nn.Module):\n    \"\"\"Ghost Bottleneck https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1):\n        \"\"\"Initializes GhostBottleneck module with arguments ch_in, ch_out, kernel, stride.\"\"\"\n        super().__init__()\n        c_ = c2 // 2\n        self.conv = nn.Sequential(\n            GhostConv(c1, c_, 1, 1),  # pw\n            DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n            GhostConv(c_, c2, 1, 1, act=False),  # pw-linear",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class Bottleneck(nn.Module):\n    \"\"\"Standard bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n        \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, k[0], 1)\n        self.cv2 = Conv(c_, c2, k[1], 1, g=g)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "BottleneckCSP",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class BottleneckCSP(nn.Module):\n    \"\"\"CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck given arguments for ch_in, ch_out, number, shortcut, groups, expansion.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n        self.cv4 = Conv(2 * c_, c2, 1, 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ResNetBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class ResNetBlock(nn.Module):\n    \"\"\"ResNet block with standard convolution layers.\"\"\"\n    def __init__(self, c1, c2, s=1, e=4):\n        \"\"\"Initialize convolution with given parameters.\"\"\"\n        super().__init__()\n        c3 = e * c2\n        self.cv1 = Conv(c1, c2, k=1, s=1, act=True)\n        self.cv2 = Conv(c2, c2, k=3, s=s, p=1, act=True)\n        self.cv3 = Conv(c2, c3, k=1, act=False)\n        self.shortcut = nn.Sequential(Conv(c1, c3, k=1, s=s, act=False)) if s != 1 or c1 != c3 else nn.Identity()",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ResNetLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class ResNetLayer(nn.Module):\n    \"\"\"ResNet layer with multiple ResNet blocks.\"\"\"\n    def __init__(self, c1, c2, s=1, is_first=False, n=1, e=4):\n        \"\"\"Initializes the ResNetLayer given arguments.\"\"\"\n        super().__init__()\n        self.is_first = is_first\n        if self.is_first:\n            self.layer = nn.Sequential(\n                Conv(c1, c2, k=7, s=2, p=3, act=True), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n            )",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "MaxSigmoidAttnBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class MaxSigmoidAttnBlock(nn.Module):\n    \"\"\"Max Sigmoid attention block.\"\"\"\n    def __init__(self, c1, c2, nh=1, ec=128, gc=512, scale=False):\n        \"\"\"Initializes MaxSigmoidAttnBlock with specified arguments.\"\"\"\n        super().__init__()\n        self.nh = nh\n        self.hc = c2 // nh\n        self.ec = Conv(c1, ec, k=1, act=False) if c1 != ec else None\n        self.gl = nn.Linear(gc, ec)\n        self.bias = nn.Parameter(torch.zeros(nh))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2fAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C2fAttn(nn.Module):\n    \"\"\"C2f module with an additional attn module.\"\"\"\n    def __init__(self, c1, c2, n=1, ec=128, nh=1, gc=512, shortcut=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv((3 + n) * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ImagePoolingAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class ImagePoolingAttn(nn.Module):\n    \"\"\"ImagePoolingAttn: Enhance the text embeddings with image-aware information.\"\"\"\n    def __init__(self, ec=256, ch=(), ct=512, nh=8, k=3, scale=False):\n        \"\"\"Initializes ImagePoolingAttn with specified arguments.\"\"\"\n        super().__init__()\n        nf = len(ch)\n        self.query = nn.Sequential(nn.LayerNorm(ct), nn.Linear(ct, ec))\n        self.key = nn.Sequential(nn.LayerNorm(ec), nn.Linear(ec, ec))\n        self.value = nn.Sequential(nn.LayerNorm(ec), nn.Linear(ec, ec))\n        self.proj = nn.Linear(ec, ct)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ContrastiveHead",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class ContrastiveHead(nn.Module):\n    \"\"\"Contrastive Head for YOLO-World compute the region-text scores according to the similarity between image and text\n    features.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes ContrastiveHead with specified region-text similarity parameters.\"\"\"\n        super().__init__()\n        self.bias = nn.Parameter(torch.zeros([]))\n        self.logit_scale = nn.Parameter(torch.ones([]) * torch.tensor(1 / 0.07).log())\n    def forward(self, x, w):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "BNContrastiveHead",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class BNContrastiveHead(nn.Module):\n    \"\"\"\n    Batch Norm Contrastive Head for YOLO-World using batch norm instead of l2-normalization.\n    Args:\n        embed_dims (int): Embed dimensions of text and image features.\n    \"\"\"\n    def __init__(self, embed_dims: int):\n        \"\"\"Initialize ContrastiveHead with region-text similarity parameters.\"\"\"\n        super().__init__()\n        self.norm = nn.BatchNorm2d(embed_dims)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepBottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class RepBottleneck(nn.Module):\n    \"\"\"Rep bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n        \"\"\"Initializes a RepBottleneck module with customizable in/out channels, shortcut option, groups and expansion\n        ratio.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = RepConv(c1, c_, k[0], 1)\n        self.cv2 = Conv(c_, c2, k[1], 1, g=g)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepCSP",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class RepCSP(nn.Module):\n    \"\"\"Rep CSP Bottleneck with 3 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes RepCSP layer with given channels, repetitions, shortcut, groups and expansion ratio.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(RepBottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepNCSPELAN4",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class RepNCSPELAN4(nn.Module):\n    \"\"\"CSP-ELAN.\"\"\"\n    def __init__(self, c1, c2, c3, c4, n=1):\n        \"\"\"Initializes CSP-ELAN layer with specified channel sizes, repetitions, and convolutions.\"\"\"\n        super().__init__()\n        self.c = c3 // 2\n        self.cv1 = Conv(c1, c3, 1, 1)\n        self.cv2 = nn.Sequential(RepCSP(c3 // 2, c4, n), Conv(c4, c4, 3, 1))\n        self.cv3 = nn.Sequential(RepCSP(c4, c4, n), Conv(c4, c4, 3, 1))\n        self.cv4 = Conv(c3 + (2 * c4), c2, 1, 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ADown",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class ADown(nn.Module):\n    \"\"\"ADown.\"\"\"\n    def __init__(self, c1, c2):\n        \"\"\"Initializes ADown module with convolution layers to downsample input from channels c1 to c2.\"\"\"\n        super().__init__()\n        self.c = c2 // 2\n        self.cv1 = Conv(c1 // 2, self.c, 3, 2, 1)\n        self.cv2 = Conv(c1 // 2, self.c, 1, 1, 0)\n    def forward(self, x):\n        \"\"\"Forward pass through ADown layer.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPPELAN",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class SPPELAN(nn.Module):\n    \"\"\"SPP-ELAN.\"\"\"\n    def __init__(self, c1, c2, c3, k=5):\n        \"\"\"Initializes SPP-ELAN block with convolution and max pooling layers for spatial pyramid pooling.\"\"\"\n        super().__init__()\n        self.c = c3\n        self.cv1 = Conv(c1, c3, 1, 1)\n        self.cv2 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n        self.cv3 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n        self.cv4 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Silence",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class Silence(nn.Module):\n    \"\"\"Silence.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the Silence module.\"\"\"\n        super(Silence, self).__init__()\n    def forward(self, x):\n        \"\"\"Forward pass through Silence layer.\"\"\"\n        return x\nclass CBLinear(nn.Module):\n    \"\"\"CBLinear.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CBLinear",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class CBLinear(nn.Module):\n    \"\"\"CBLinear.\"\"\"\n    def __init__(self, c1, c2s, k=1, s=1, p=None, g=1):\n        \"\"\"Initializes the CBLinear module, passing inputs unchanged.\"\"\"\n        super(CBLinear, self).__init__()\n        self.c2s = c2s\n        self.conv = nn.Conv2d(c1, sum(c2s), k, s, autopad(k, p), groups=g, bias=True)\n    def forward(self, x):\n        \"\"\"Forward pass through CBLinear layer.\"\"\"\n        outs = self.conv(x).split(self.c2s, dim=1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CBFuse",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class CBFuse(nn.Module):\n    \"\"\"CBFuse.\"\"\"\n    def __init__(self, idx):\n        \"\"\"Initializes CBFuse module with layer index for selective feature fusion.\"\"\"\n        super(CBFuse, self).__init__()\n        self.idx = idx\n    def forward(self, xs):\n        \"\"\"Forward pass through CBFuse layer.\"\"\"\n        target_size = xs[-1].shape[2:]\n        res = [F.interpolate(x[self.idx[i]], size=target_size, mode=\"nearest\") for i, x in enumerate(xs[:-1])]",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepVGGDW",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class RepVGGDW(torch.nn.Module):\n    def __init__(self, ed) -> None:\n        super().__init__()\n        self.conv = Conv(ed, ed, 7, 1, 3, g=ed, act=False)\n        self.conv1 = Conv(ed, ed, 3, 1, 1, g=ed, act=False)\n        self.dim = ed\n        self.act = nn.SiLU()\n    def forward(self, x):\n        return self.act(self.conv(x) + self.conv1(x))\n    def forward_fuse(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CIB",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class CIB(nn.Module):\n    \"\"\"Standard bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, e=0.5, lk=False):\n        \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = nn.Sequential(\n            Conv(c1, c1, 3, g=c1),",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2fCIB",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class C2fCIB(C2f):\n    \"\"\"Faster Implementation of CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=False, lk=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        self.m = nn.ModuleList(CIB(self.c, self.c, shortcut, e=1.0, lk=lk) for _ in range(n))\nclass Attention(nn.Module):\n    def __init__(self, dim, num_heads=8,",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class Attention(nn.Module):\n    def __init__(self, dim, num_heads=8,\n                 attn_ratio=0.5):\n        super().__init__()\n        self.num_heads = num_heads\n        self.head_dim = dim // num_heads\n        self.key_dim = int(self.head_dim * attn_ratio)\n        self.scale = self.key_dim ** -0.5\n        nh_kd = nh_kd = self.key_dim * num_heads\n        h = dim + nh_kd * 2",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "PSA",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class PSA(nn.Module):\n    def __init__(self, c1, c2, e=0.5):\n        super().__init__()\n        assert(c1 == c2)\n        self.c = int(c1 * e)\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv(2 * self.c, c1, 1)\n        self.attn = Attention(self.c, attn_ratio=0.5, num_heads=self.c // 64)\n        self.ffn = nn.Sequential(\n            Conv(self.c, self.c*2, 1),",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SCDown",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "class SCDown(nn.Module):\n    def __init__(self, c1, c2, k, s):\n        super().__init__()\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.cv2 = Conv(c2, c2, k=k, s=s, g=c2, act=False)\n    def forward(self, x):\n        return self.cv2(self.cv1(x))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "peekOfCode": "__all__ = (\n    \"DFL\",\n    \"HGBlock\",\n    \"HGStem\",\n    \"SPP\",\n    \"SPPF\",\n    \"C1\",\n    \"C2\",\n    \"C3\",\n    \"C2f\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Conv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class Conv(nn.Module):\n    \"\"\"Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n    def forward(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Conv2",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class Conv2(Conv):\n    \"\"\"Simplified RepConv module with Conv fusing.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__(c1, c2, k, s, p, g=g, d=d, act=act)\n        self.cv2 = nn.Conv2d(c1, c2, 1, s, autopad(1, p, d), groups=g, dilation=d, bias=False)  # add 1x1 conv\n    def forward(self, x):\n        \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n        return self.act(self.bn(self.conv(x) + self.cv2(x)))\n    def forward_fuse(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "LightConv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class LightConv(nn.Module):\n    \"\"\"\n    Light convolution with args(ch_in, ch_out, kernel).\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, c2, k=1, act=nn.ReLU()):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv1 = Conv(c1, c2, 1, act=False)\n        self.conv2 = DWConv(c2, c2, k, act=act)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "DWConv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class DWConv(Conv):\n    \"\"\"Depth-wise convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, d=1, act=True):  # ch_in, ch_out, kernel, stride, dilation, activation\n        \"\"\"Initialize Depth-wise convolution with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)\nclass DWConvTranspose2d(nn.ConvTranspose2d):\n    \"\"\"Depth-wise transpose convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "DWConvTranspose2d",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class DWConvTranspose2d(nn.ConvTranspose2d):\n    \"\"\"Depth-wise transpose convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))\nclass ConvTranspose(nn.Module):\n    \"\"\"Convolution transpose 2d layer.\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n        \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "ConvTranspose",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class ConvTranspose(nn.Module):\n    \"\"\"Convolution transpose 2d layer.\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n        \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"\n        super().__init__()\n        self.conv_transpose = nn.ConvTranspose2d(c1, c2, k, s, p, bias=not bn)\n        self.bn = nn.BatchNorm2d(c2) if bn else nn.Identity()\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n    def forward(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Focus",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class Focus(nn.Module):\n    \"\"\"Focus wh information into c-space.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):\n        \"\"\"Initializes Focus object with user defined channel, convolution, padding, group and activation values.\"\"\"\n        super().__init__()\n        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)\n        # self.contract = Contract(gain=2)\n    def forward(self, x):\n        \"\"\"\n        Applies convolution to concatenated tensor and returns the output.",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "GhostConv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class GhostConv(nn.Module):\n    \"\"\"Ghost Convolution https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\n        \"\"\"Initializes the GhostConv object with input channels, output channels, kernel size, stride, groups and\n        activation.\n        \"\"\"\n        super().__init__()\n        c_ = c2 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "RepConv",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class RepConv(nn.Module):\n    \"\"\"\n    RepConv is a basic rep-style block, including training and deploy status.\n    This module is used in RT-DETR.\n    Based on https://github.com/DingXiaoH/RepVGG/blob/main/repvgg.py\n    \"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False):\n        \"\"\"Initializes Light Convolution layer with inputs, outputs & optional activation function.\"\"\"\n        super().__init__()",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "ChannelAttention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class ChannelAttention(nn.Module):\n    \"\"\"Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet.\"\"\"\n    def __init__(self, channels: int) -> None:\n        \"\"\"Initializes the class and sets the basic configurations and instance variables required.\"\"\"\n        super().__init__()\n        self.pool = nn.AdaptiveAvgPool2d(1)\n        self.fc = nn.Conv2d(channels, channels, 1, 1, 0, bias=True)\n        self.act = nn.Sigmoid()\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Applies forward pass using activation on convolutions of the input, optionally using batch normalization.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "SpatialAttention",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class SpatialAttention(nn.Module):\n    \"\"\"Spatial-attention module.\"\"\"\n    def __init__(self, kernel_size=7):\n        \"\"\"Initialize Spatial-attention module with kernel size argument.\"\"\"\n        super().__init__()\n        assert kernel_size in (3, 7), \"kernel size must be 3 or 7\"\n        padding = 3 if kernel_size == 7 else 1\n        self.cv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)\n        self.act = nn.Sigmoid()\n    def forward(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "CBAM",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class CBAM(nn.Module):\n    \"\"\"Convolutional Block Attention Module.\"\"\"\n    def __init__(self, c1, kernel_size=7):\n        \"\"\"Initialize CBAM with given input channel (c1) and kernel size.\"\"\"\n        super().__init__()\n        self.channel_attention = ChannelAttention(c1)\n        self.spatial_attention = SpatialAttention(kernel_size)\n    def forward(self, x):\n        \"\"\"Applies the forward pass through C1 module.\"\"\"\n        return self.spatial_attention(self.channel_attention(x))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Concat",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "class Concat(nn.Module):\n    \"\"\"Concatenate a list of tensors along dimension.\"\"\"\n    def __init__(self, dimension=1):\n        \"\"\"Concatenates a list of tensors along a specified dimension.\"\"\"\n        super().__init__()\n        self.d = dimension\n    def forward(self, x):\n        \"\"\"Forward pass for the YOLOv8 mask Proto module.\"\"\"\n        return torch.cat(x, self.d)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "autopad",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "def autopad(k, p=None, d=1):  # kernel, padding, dilation\n    \"\"\"Pad to 'same' shape outputs.\"\"\"\n    if d > 1:\n        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size\n    if p is None:\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\n    return p\nclass Conv(nn.Module):\n    \"\"\"Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).\"\"\"\n    default_act = nn.SiLU()  # default activation",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "peekOfCode": "__all__ = (\n    \"Conv\",\n    \"Conv2\",\n    \"LightConv\",\n    \"DWConv\",\n    \"DWConvTranspose2d\",\n    \"ConvTranspose\",\n    \"Focus\",\n    \"GhostConv\",\n    \"ChannelAttention\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Detect",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class Detect(nn.Module):\n    \"\"\"YOLOv8 Detect head for detection models.\"\"\"\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n    shape = None\n    anchors = torch.empty(0)  # init\n    strides = torch.empty(0)  # init\n    def __init__(self, nc=80, ch=()):\n        \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"\n        super().__init__()",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class Segment(Detect):\n    \"\"\"YOLOv8 Segment head for segmentation models.\"\"\"\n    def __init__(self, nc=80, nm=32, npr=256, ch=()):\n        \"\"\"Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers.\"\"\"\n        super().__init__(nc, ch)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.nm)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "OBB",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class OBB(Detect):\n    \"\"\"YOLOv8 OBB detection head for detection with rotation models.\"\"\"\n    def __init__(self, nc=80, ne=1, ch=()):\n        \"\"\"Initialize OBB with number of classes `nc` and layer channels `ch`.\"\"\"\n        super().__init__(nc, ch)\n        self.ne = ne  # number of extra parameters\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.ne)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.ne, 1)) for x in ch)\n    def forward(self, x):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Pose",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class Pose(Detect):\n    \"\"\"YOLOv8 Pose head for keypoints models.\"\"\"\n    def __init__(self, nc=80, kpt_shape=(17, 3), ch=()):\n        \"\"\"Initialize YOLO network with default parameters and Convolutional Layers.\"\"\"\n        super().__init__(nc, ch)\n        self.kpt_shape = kpt_shape  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\n        self.nk = kpt_shape[0] * kpt_shape[1]  # number of keypoints total\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.nk)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nk, 1)) for x in ch)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Classify",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class Classify(nn.Module):\n    \"\"\"YOLOv8 classification head, i.e. x(b,c1,20,20) to x(b,c2).\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1):\n        \"\"\"Initializes YOLOv8 classification head with specified input and output channels, kernel size, stride,\n        padding, and groups.\n        \"\"\"\n        super().__init__()\n        c_ = 1280  # efficientnet_b0 size\n        self.conv = Conv(c1, c_, k, s, p, g)\n        self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "WorldDetect",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class WorldDetect(Detect):\n    def __init__(self, nc=80, embed=512, with_bn=False, ch=()):\n        \"\"\"Initialize YOLOv8 detection layer with nc classes and layer channels ch.\"\"\"\n        super().__init__(nc, ch)\n        c3 = max(ch[0], min(self.nc, 100))\n        self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, embed, 1)) for x in ch)\n        self.cv4 = nn.ModuleList(BNContrastiveHead(embed) if with_bn else ContrastiveHead() for _ in ch)\n    def forward(self, x, text):\n        \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n        for i in range(self.nl):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class RTDETRDecoder(nn.Module):\n    \"\"\"\n    Real-Time Deformable Transformer Decoder (RTDETRDecoder) module for object detection.\n    This decoder module utilizes Transformer architecture along with deformable convolutions to predict bounding boxes\n    and class labels for objects in an image. It integrates features from multiple layers and runs through a series of\n    Transformer decoder layers to output the final predictions.\n    \"\"\"\n    export = False  # export mode\n    def __init__(\n        self,",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "class v10Detect(Detect):\n    max_det = 300\n    def __init__(self, nc=80, ch=()):\n        super().__init__(nc, ch)\n        c3 = max(ch[0], min(self.nc, 100))  # channels\n        self.cv3 = nn.ModuleList(nn.Sequential(nn.Sequential(Conv(x, x, 3, g=x), Conv(x, c3, 1)), \\\n                                               nn.Sequential(Conv(c3, c3, 3, g=c3), Conv(c3, c3, 1)), \\\n                                                nn.Conv2d(c3, self.nc, 1)) for i, x in enumerate(ch))\n        self.one2one_cv2 = copy.deepcopy(self.cv2)\n        self.one2one_cv3 = copy.deepcopy(self.cv3)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "peekOfCode": "__all__ = \"Detect\", \"Segment\", \"Pose\", \"Classify\", \"OBB\", \"RTDETRDecoder\"\nclass Detect(nn.Module):\n    \"\"\"YOLOv8 Detect head for detection models.\"\"\"\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n    shape = None\n    anchors = torch.empty(0)  # init\n    strides = torch.empty(0)  # init\n    def __init__(self, nc=80, ch=()):\n        \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "TransformerEncoderLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerEncoderLayer(nn.Module):\n    \"\"\"Defines a single layer of the transformer encoder.\"\"\"\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the TransformerEncoderLayer with specified parameters.\"\"\"\n        super().__init__()\n        from ...utils.torch_utils import TORCH_1_9\n        if not TORCH_1_9:\n            raise ModuleNotFoundError(\n                \"TransformerEncoderLayer() requires torch>=1.9 to use nn.MultiheadAttention(batch_first=True).\"\n            )",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "AIFI",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class AIFI(TransformerEncoderLayer):\n    \"\"\"Defines the AIFI transformer layer.\"\"\"\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the AIFI instance with specified parameters.\"\"\"\n        super().__init__(c1, cm, num_heads, dropout, act, normalize_before)\n    def forward(self, x):\n        \"\"\"Forward pass for the AIFI transformer layer.\"\"\"\n        c, h, w = x.shape[1:]\n        pos_embed = self.build_2d_sincos_position_embedding(w, h, c)\n        # Flatten [B, C, H, W] to [B, HxW, C]",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerLayer(nn.Module):\n    \"\"\"Transformer layer https://arxiv.org/abs/2010.11929 (LayerNorm layers removed for better performance).\"\"\"\n    def __init__(self, c, num_heads):\n        \"\"\"Initializes a self-attention mechanism using linear transformations and multi-head attention.\"\"\"\n        super().__init__()\n        self.q = nn.Linear(c, c, bias=False)\n        self.k = nn.Linear(c, c, bias=False)\n        self.v = nn.Linear(c, c, bias=False)\n        self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n        self.fc1 = nn.Linear(c, c, bias=False)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerBlock(nn.Module):\n    \"\"\"Vision Transformer https://arxiv.org/abs/2010.11929.\"\"\"\n    def __init__(self, c1, c2, num_heads, num_layers):\n        \"\"\"Initialize a Transformer module with position embedding and specified number of heads and layers.\"\"\"\n        super().__init__()\n        self.conv = None\n        if c1 != c2:\n            self.conv = Conv(c1, c2)\n        self.linear = nn.Linear(c2, c2)  # learnable position embedding\n        self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MLPBlock(nn.Module):\n    \"\"\"Implements a single block of a multi-layer perceptron.\"\"\"\n    def __init__(self, embedding_dim, mlp_dim, act=nn.GELU):\n        \"\"\"Initialize the MLPBlock with specified embedding dimension, MLP dimension, and activation function.\"\"\"\n        super().__init__()\n        self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n        self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n        self.act = act()\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Forward pass for the MLPBlock.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MLP",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MLP(nn.Module):\n    \"\"\"Implements a simple multi-layer perceptron (also called FFN).\"\"\"\n    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):\n        \"\"\"Initialize the MLP with specified input, hidden, output dimensions and number of layers.\"\"\"\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n    def forward(self, x):\n        \"\"\"Forward pass for the entire MLP.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class LayerNorm2d(nn.Module):\n    \"\"\"\n    2D Layer Normalization module inspired by Detectron2 and ConvNeXt implementations.\n    Original implementations in\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py\n    and\n    https://github.com/facebookresearch/ConvNeXt/blob/main/models/convnext.py.\n    \"\"\"\n    def __init__(self, num_channels, eps=1e-6):\n        \"\"\"Initialize LayerNorm2d with the given parameters.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MSDeformAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MSDeformAttn(nn.Module):\n    \"\"\"\n    Multiscale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py\n    \"\"\"\n    def __init__(self, d_model=256, n_levels=4, n_heads=8, n_points=4):\n        \"\"\"Initialize MSDeformAttn with the given parameters.\"\"\"\n        super().__init__()\n        if d_model % n_heads != 0:\n            raise ValueError(f\"d_model must be divisible by n_heads, but got {d_model} and {n_heads}\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "DeformableTransformerDecoderLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class DeformableTransformerDecoderLayer(nn.Module):\n    \"\"\"\n    Deformable Transformer Decoder Layer inspired by PaddleDetection and Deformable-DETR implementations.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/deformable_transformer.py\n    \"\"\"\n    def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4):\n        \"\"\"Initialize the DeformableTransformerDecoderLayer with the given parameters.\"\"\"\n        super().__init__()\n        # Self attention",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "DeformableTransformerDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "class DeformableTransformerDecoder(nn.Module):\n    \"\"\"\n    Implementation of Deformable Transformer Decoder based on PaddleDetection.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    \"\"\"\n    def __init__(self, hidden_dim, decoder_layer, num_layers, eval_idx=-1):\n        \"\"\"Initialize the DeformableTransformerDecoder with the given parameters.\"\"\"\n        super().__init__()\n        self.layers = _get_clones(decoder_layer, num_layers)\n        self.num_layers = num_layers",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "peekOfCode": "__all__ = (\n    \"TransformerEncoderLayer\",\n    \"TransformerLayer\",\n    \"TransformerBlock\",\n    \"MLPBlock\",\n    \"LayerNorm2d\",\n    \"AIFI\",\n    \"DeformableTransformerDecoder\",\n    \"DeformableTransformerDecoderLayer\",\n    \"MSDeformAttn\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "bias_init_with_prob",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "peekOfCode": "def bias_init_with_prob(prior_prob=0.01):\n    \"\"\"Initialize conv/fc bias value according to a given probability value.\"\"\"\n    return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init\ndef linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])\n    uniform_(module.weight, -bound, bound)\n    if hasattr(module, \"bias\") and module.bias is not None:\n        uniform_(module.bias, -bound, bound)\ndef inverse_sigmoid(x, eps=1e-5):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "linear_init",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "peekOfCode": "def linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])\n    uniform_(module.weight, -bound, bound)\n    if hasattr(module, \"bias\") and module.bias is not None:\n        uniform_(module.bias, -bound, bound)\ndef inverse_sigmoid(x, eps=1e-5):\n    \"\"\"Calculate the inverse sigmoid function for a tensor.\"\"\"\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "inverse_sigmoid",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "peekOfCode": "def inverse_sigmoid(x, eps=1e-5):\n    \"\"\"Calculate the inverse sigmoid function for a tensor.\"\"\"\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)\n    x2 = (1 - x).clamp(min=eps)\n    return torch.log(x1 / x2)\ndef multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "multi_scale_deformable_attn_pytorch",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "peekOfCode": "def multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,\n    attention_weights: torch.Tensor,\n) -> torch.Tensor:\n    \"\"\"\n    Multiscale deformable attention.\n    https://github.com/IDEA-Research/detrex/blob/main/detrex/layers/multi_scale_deform_attn.py\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "peekOfCode": "__all__ = \"multi_scale_deformable_attn_pytorch\", \"inverse_sigmoid\"\ndef _get_clones(module, n):\n    \"\"\"Create a list of cloned modules from the given module.\"\"\"\n    return nn.ModuleList([copy.deepcopy(module) for _ in range(n)])\ndef bias_init_with_prob(prior_prob=0.01):\n    \"\"\"Initialize conv/fc bias value according to a given probability value.\"\"\"\n    return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init\ndef linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "peekOfCode": "class AutoBackend(nn.Module):\n    \"\"\"\n    Handles dynamic backend selection for running inference using Ultralytics YOLO models.\n    The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide\n    range of formats, each with specific naming conventions as outlined below:\n        Supported Formats and Naming Conventions:\n            | Format                | File Suffix      |\n            |-----------------------|------------------|\n            | PyTorch               | *.pt             |\n            | TorchScript           | *.torchscript    |",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "peekOfCode": "def check_class_names(names):\n    \"\"\"\n    Check class names.\n    Map imagenet class codes to human-readable names if required. Convert lists to dicts.\n    \"\"\"\n    if isinstance(names, list):  # names is a list\n        names = dict(enumerate(names))  # convert to dict\n    if isinstance(names, dict):\n        # Convert 1) string keys to int, i.e. '0' to 0, and non-string values to strings, i.e. True to 'True'\n        names = {int(k): str(v) for k, v in names.items()}",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "default_class_names",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "peekOfCode": "def default_class_names(data=None):\n    \"\"\"Applies default class names to an input YAML file or returns numerical class names.\"\"\"\n    if data:\n        with contextlib.suppress(Exception):\n            return yaml_load(check_yaml(data))[\"names\"]\n    return {i: f\"class{i}\" for i in range(999)}  # return default if above errors\nclass AutoBackend(nn.Module):\n    \"\"\"\n    Handles dynamic backend selection for running inference using Ultralytics YOLO models.\n    The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class BaseModel(nn.Module):\n    \"\"\"The BaseModel class serves as a base class for all the models in the Ultralytics YOLO family.\"\"\"\n    def forward(self, x, *args, **kwargs):\n        \"\"\"\n        Forward pass of the model on a single scale. Wrapper for `_forward_once` method.\n        Args:\n            x (torch.Tensor | dict): The input image tensor or a dict including image tensor and gt labels.\n        Returns:\n            (torch.Tensor): The output of the network.\n        \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class DetectionModel(BaseModel):\n    \"\"\"YOLOv8 detection model.\"\"\"\n    def __init__(self, cfg=\"yolov8n.yaml\", ch=3, nc=None, verbose=True):  # model, input channels, number of classes\n        \"\"\"Initialize the YOLOv8 detection model with the given config and parameters.\"\"\"\n        super().__init__()\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n        # Define model\n        ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class OBBModel(DetectionModel):\n    \"\"\"YOLOv8 Oriented Bounding Box (OBB) model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-obb.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 OBB model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the model.\"\"\"\n        return v8OBBLoss(self)\nclass SegmentationModel(DetectionModel):\n    \"\"\"YOLOv8 segmentation model.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class SegmentationModel(DetectionModel):\n    \"\"\"YOLOv8 segmentation model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-seg.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 segmentation model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the SegmentationModel.\"\"\"\n        return v8SegmentationLoss(self)\nclass PoseModel(DetectionModel):\n    \"\"\"YOLOv8 pose model.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class PoseModel(DetectionModel):\n    \"\"\"YOLOv8 pose model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-pose.yaml\", ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):\n        \"\"\"Initialize YOLOv8 Pose model.\"\"\"\n        if not isinstance(cfg, dict):\n            cfg = yaml_model_load(cfg)  # load model YAML\n        if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg[\"kpt_shape\"]):\n            LOGGER.info(f\"Overriding model.yaml kpt_shape={cfg['kpt_shape']} with kpt_shape={data_kpt_shape}\")\n            cfg[\"kpt_shape\"] = data_kpt_shape\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class ClassificationModel(BaseModel):\n    \"\"\"YOLOv8 classification model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-cls.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Init ClassificationModel with YAML, channels, number of classes, verbose flag.\"\"\"\n        super().__init__()\n        self._from_yaml(cfg, ch, nc, verbose)\n    def _from_yaml(self, cfg, ch, nc, verbose):\n        \"\"\"Set YOLOv8 model configurations and define the model architecture.\"\"\"\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n        # Define model",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class RTDETRDetectionModel(DetectionModel):\n    \"\"\"\n    RTDETR (Real-time DEtection and Tracking using Transformers) Detection Model class.\n    This class is responsible for constructing the RTDETR architecture, defining loss functions, and facilitating both\n    the training and inference processes. RTDETR is an object detection and tracking model that extends from the\n    DetectionModel base class.\n    Attributes:\n        cfg (str): The configuration file path or preset string. Default is 'rtdetr-l.yaml'.\n        ch (int): Number of input channels. Default is 3 (RGB).\n        nc (int, optional): Number of classes for object detection. Default is None.",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class WorldModel(DetectionModel):\n    \"\"\"YOLOv8 World Model.\"\"\"\n    def __init__(self, cfg=\"yolov8s-world.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 world model with given config and parameters.\"\"\"\n        self.txt_feats = torch.randn(1, nc or 80, 512)  # features placeholder\n        self.clip_model = None  # CLIP model placeholder\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def set_classes(self, text):\n        \"\"\"Perform a forward pass with optional profiling, visualization, and embedding extraction.\"\"\"\n        try:",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class YOLOv10DetectionModel(DetectionModel):\n    def init_criterion(self):\n        return v10DetectLoss(self)\nclass Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize an ensemble of models.\"\"\"\n        super().__init__()\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Function generates the YOLO network's final layer.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "Ensemble",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "class Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize an ensemble of models.\"\"\"\n        super().__init__()\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Function generates the YOLO network's final layer.\"\"\"\n        y = [module(x, augment, profile, visualize)[0] for module in self]\n        # y = torch.stack(y).max(0)[0]  # max ensemble\n        # y = torch.stack(y).mean(0)  # mean ensemble",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "temporary_modules",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def temporary_modules(modules=None):\n    \"\"\"\n    Context manager for temporarily adding or modifying modules in Python's module cache (`sys.modules`).\n    This function can be used to change the module paths during runtime. It's useful when refactoring code,\n    where you've moved a module from one location to another, but you still want to support the old import\n    paths for backwards compatibility.\n    Args:\n        modules (dict, optional): A dictionary mapping old module paths to new module paths.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "torch_safe_load",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def torch_safe_load(weight):\n    \"\"\"\n    This function attempts to load a PyTorch model with the torch.load() function. If a ModuleNotFoundError is raised,\n    it catches the error, logs a warning message, and attempts to install the missing module via the\n    check_requirements() function. After installation, the function again attempts to load the model using torch.load().\n    Args:\n        weight (str): The file path of the PyTorch model.\n    Returns:\n        (dict): The loaded PyTorch model.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_weights",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def attempt_load_weights(weights, device=None, inplace=True, fuse=False):\n    \"\"\"Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a.\"\"\"\n    ensemble = Ensemble()\n    for w in weights if isinstance(weights, list) else [weights]:\n        ckpt, w = torch_safe_load(w)  # load ckpt\n        args = {**DEFAULT_CFG_DICT, **ckpt[\"train_args\"]} if \"train_args\" in ckpt else None  # combined args\n        model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n        # Model compatibility updates\n        model.args = args  # attach args to model\n        model.pt_path = w  # attach *.pt file path to model",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def attempt_load_one_weight(weight, device=None, inplace=True, fuse=False):\n    \"\"\"Loads a single model weights.\"\"\"\n    ckpt, weight = torch_safe_load(weight)  # load ckpt\n    args = {**DEFAULT_CFG_DICT, **(ckpt.get(\"train_args\", {}))}  # combine model and default args, preferring model args\n    model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n    # Model compatibility updates\n    model.args = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # attach args to model\n    model.pt_path = weight  # attach *.pt file path to model\n    model.task = guess_model_task(model)\n    if not hasattr(model, \"stride\"):",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "parse_model",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def parse_model(d, ch, verbose=True):  # model_dict, input_channels(3)\n    \"\"\"Parse a YOLO model.yaml dictionary into a PyTorch model.\"\"\"\n    import ast\n    # Args\n    max_channels = float(\"inf\")\n    nc, act, scales = (d.get(x) for x in (\"nc\", \"activation\", \"scales\"))\n    depth, width, kpt_shape = (d.get(x, 1.0) for x in (\"depth_multiple\", \"width_multiple\", \"kpt_shape\"))\n    if scales:\n        scale = d.get(\"scale\")\n        if not scale:",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "yaml_model_load",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def yaml_model_load(path):\n    \"\"\"Load a YOLOv8 model from a YAML file.\"\"\"\n    import re\n    path = Path(path)\n    if path.stem in (f\"yolov{d}{x}6\" for x in \"nsmlx\" for d in (5, 8)):\n        new_stem = re.sub(r\"(\\d+)([nslmx])6(.+)?$\", r\"\\1\\2-p6\\3\", path.stem)\n        LOGGER.warning(f\"WARNING  Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.\")\n        path = path.with_name(new_stem + path.suffix)\n    if \"v10\" not in str(path):\n        unified_path = re.sub(r\"(\\d+)([nsblmx])(.+)?$\", r\"\\1\\3\", str(path))  # i.e. yolov8x.yaml -> yolov8.yaml",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_scale",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def guess_model_scale(model_path):\n    \"\"\"\n    Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function\n    uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by\n    n, s, m, l, or x. The function returns the size character of the model scale as a string.\n    Args:\n        model_path (str | Path): The path to the YOLO model's YAML file.\n    Returns:\n        (str): The size character of the model's scale, which can be n, s, m, l, or x.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_task",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "description": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "peekOfCode": "def guess_model_task(model):\n    \"\"\"\n    Guess the task of a PyTorch model from its architecture or configuration.\n    Args:\n        model (nn.Module | dict): PyTorch model or model configuration in YAML format.\n    Returns:\n        (str): Task of the model ('detect', 'segment', 'classify', 'pose').\n    Raises:\n        SyntaxError: If the task of the model could not be determined.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "AIGym",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.solutions.ai_gym",
        "description": "Identification.yolov10.build.lib.ultralytics.solutions.ai_gym",
        "peekOfCode": "class AIGym:\n    \"\"\"A class to manage the gym steps of people in a real-time video stream based on their poses.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the AIGym with default values for Visual and Image parameters.\"\"\"\n        # Image and line thickness\n        self.im0 = None\n        self.tf = None\n        # Keypoints and count information\n        self.keypoints = None\n        self.poseup_angle = None",
        "detail": "Identification.yolov10.build.lib.ultralytics.solutions.ai_gym",
        "documentation": {}
    },
    {
        "label": "DistanceCalculation",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.solutions.distance_calculation",
        "description": "Identification.yolov10.build.lib.ultralytics.solutions.distance_calculation",
        "peekOfCode": "class DistanceCalculation:\n    \"\"\"A class to calculate distance between two objects in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the distance calculation class with default values for Visual, Image, track and distance\n        parameters.\n        \"\"\"\n        # Visual & im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False",
        "detail": "Identification.yolov10.build.lib.ultralytics.solutions.distance_calculation",
        "documentation": {}
    },
    {
        "label": "Heatmap",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.solutions.heatmap",
        "description": "Identification.yolov10.build.lib.ultralytics.solutions.heatmap",
        "peekOfCode": "class Heatmap:\n    \"\"\"A class to draw heatmaps in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the heatmap class with default values for Visual, Image, track, count and heatmap parameters.\"\"\"\n        # Visual information\n        self.annotator = None\n        self.view_img = False\n        self.shape = \"circle\"\n        # Image information\n        self.imw = None",
        "detail": "Identification.yolov10.build.lib.ultralytics.solutions.heatmap",
        "documentation": {}
    },
    {
        "label": "ObjectCounter",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.solutions.object_counter",
        "description": "Identification.yolov10.build.lib.ultralytics.solutions.object_counter",
        "peekOfCode": "class ObjectCounter:\n    \"\"\"A class to manage the counting of objects in a real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the Counter with default values for various tracking and counting parameters.\"\"\"\n        # Mouse events\n        self.is_drawing = False\n        self.selected_point = None\n        # Region & Line Information\n        self.reg_pts = [(20, 400), (1260, 400)]\n        self.line_dist_thresh = 15",
        "detail": "Identification.yolov10.build.lib.ultralytics.solutions.object_counter",
        "documentation": {}
    },
    {
        "label": "SpeedEstimator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.solutions.speed_estimation",
        "description": "Identification.yolov10.build.lib.ultralytics.solutions.speed_estimation",
        "peekOfCode": "class SpeedEstimator:\n    \"\"\"A class to estimation speed of objects in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the speed-estimator class with default values for Visual, Image, track and speed parameters.\"\"\"\n        # Visual & im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False\n        # Region information\n        self.reg_pts = [(20, 400), (1260, 400)]",
        "detail": "Identification.yolov10.build.lib.ultralytics.solutions.speed_estimation",
        "documentation": {}
    },
    {
        "label": "GMC",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.gmc",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.gmc",
        "peekOfCode": "class GMC:\n    \"\"\"\n    Generalized Motion Compensation (GMC) class for tracking and object detection in video frames.\n    This class provides methods for tracking and detecting objects based on several tracking algorithms including ORB,\n    SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of frames for computational efficiency.\n    Attributes:\n        method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.\n        downscale (int): Factor by which to downscale the frames for processing.\n        prevFrame (np.ndarray): Stores the previous frame for tracking.\n        prevKeyPoints (list): Stores the keypoints from the previous frame.",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.gmc",
        "documentation": {}
    },
    {
        "label": "KalmanFilterXYAH",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "peekOfCode": "class KalmanFilterXYAH:\n    \"\"\"\n    For bytetrack. A simple Kalman filter for tracking bounding boxes in image space.\n    The 8-dimensional state space (x, y, a, h, vx, vy, va, vh) contains the bounding box center position (x, y), aspect\n    ratio a, height h, and their respective velocities.\n    Object motion follows a constant velocity model. The bounding box location (x, y, a, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize Kalman filter model matrices with motion and observation uncertainty weights.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "documentation": {}
    },
    {
        "label": "KalmanFilterXYWH",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "peekOfCode": "class KalmanFilterXYWH(KalmanFilterXYAH):\n    \"\"\"\n    For BoT-SORT. A simple Kalman filter for tracking bounding boxes in image space.\n    The 8-dimensional state space (x, y, w, h, vx, vy, vw, vh) contains the bounding box center position (x, y), width\n    w, height h, and their respective velocities.\n    Object motion follows a constant velocity model. The bounding box location (x, y, w, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n    def initiate(self, measurement: np.ndarray) -> tuple:\n        \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.kalman_filter",
        "documentation": {}
    },
    {
        "label": "linear_assignment",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "peekOfCode": "def linear_assignment(cost_matrix: np.ndarray, thresh: float, use_lap: bool = True) -> tuple:\n    \"\"\"\n    Perform linear assignment using scipy or lap.lapjv.\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        thresh (float): Threshold for considering an assignment valid.\n        use_lap (bool, optional): Whether to use lap.lapjv. Defaults to True.\n    Returns:\n        Tuple with:\n            - matched indices",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "iou_distance",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "peekOfCode": "def iou_distance(atracks: list, btracks: list) -> np.ndarray:\n    \"\"\"\n    Compute cost based on Intersection over Union (IoU) between tracks.\n    Args:\n        atracks (list[STrack] | list[np.ndarray]): List of tracks 'a' or bounding boxes.\n        btracks (list[STrack] | list[np.ndarray]): List of tracks 'b' or bounding boxes.\n    Returns:\n        (np.ndarray): Cost matrix computed based on IoU.\n    \"\"\"\n    if atracks and isinstance(atracks[0], np.ndarray) or btracks and isinstance(btracks[0], np.ndarray):",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "embedding_distance",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "peekOfCode": "def embedding_distance(tracks: list, detections: list, metric: str = \"cosine\") -> np.ndarray:\n    \"\"\"\n    Compute distance between tracks and detections based on embeddings.\n    Args:\n        tracks (list[STrack]): List of tracks.\n        detections (list[BaseTrack]): List of detections.\n        metric (str, optional): Metric for distance computation. Defaults to 'cosine'.\n    Returns:\n        (np.ndarray): Cost matrix computed based on embeddings.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "fuse_score",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "peekOfCode": "def fuse_score(cost_matrix: np.ndarray, detections: list) -> np.ndarray:\n    \"\"\"\n    Fuses cost matrix with detection scores to produce a single similarity matrix.\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        detections (list[BaseTrack]): List of detections with scores.\n    Returns:\n        (np.ndarray): Fused similarity matrix.\n    \"\"\"\n    if cost_matrix.size == 0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "TrackState",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "peekOfCode": "class TrackState:\n    \"\"\"\n    Enumeration class representing the possible states of an object being tracked.\n    Attributes:\n        New (int): State when the object is newly detected.\n        Tracked (int): State when the object is successfully tracked in subsequent frames.\n        Lost (int): State when the object is no longer tracked.\n        Removed (int): State when the object is removed from tracking.\n    \"\"\"\n    New = 0",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "documentation": {}
    },
    {
        "label": "BaseTrack",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "peekOfCode": "class BaseTrack:\n    \"\"\"\n    Base class for object tracking, providing foundational attributes and methods.\n    Attributes:\n        _count (int): Class-level counter for unique track IDs.\n        track_id (int): Unique identifier for the track.\n        is_activated (bool): Flag indicating whether the track is currently active.\n        state (TrackState): Current state of the track.\n        history (OrderedDict): Ordered history of the track's states.\n        features (list): List of features extracted from the object for tracking.",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.basetrack",
        "documentation": {}
    },
    {
        "label": "BOTrack",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "peekOfCode": "class BOTrack(STrack):\n    \"\"\"\n    An extended version of the STrack class for YOLOv8, adding object tracking features.\n    Attributes:\n        shared_kalman (KalmanFilterXYWH): A shared Kalman filter for all instances of BOTrack.\n        smooth_feat (np.ndarray): Smoothed feature vector.\n        curr_feat (np.ndarray): Current feature vector.\n        features (deque): A deque to store feature vectors with a maximum length defined by `feat_history`.\n        alpha (float): Smoothing factor for the exponential moving average of features.\n        mean (np.ndarray): The mean state of the Kalman filter.",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "documentation": {}
    },
    {
        "label": "BOTSORT",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "peekOfCode": "class BOTSORT(BYTETracker):\n    \"\"\"\n    An extended version of the BYTETracker class for YOLOv8, designed for object tracking with ReID and GMC algorithm.\n    Attributes:\n        proximity_thresh (float): Threshold for spatial proximity (IoU) between tracks and detections.\n        appearance_thresh (float): Threshold for appearance similarity (ReID embeddings) between tracks and detections.\n        encoder (object): Object to handle ReID embeddings, set to None if ReID is not enabled.\n        gmc (GMC): An instance of the GMC algorithm for data association.\n        args (object): Parsed command-line arguments containing tracking parameters.\n    Methods:",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.bot_sort",
        "documentation": {}
    },
    {
        "label": "STrack",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "peekOfCode": "class STrack(BaseTrack):\n    \"\"\"\n    Single object tracking representation that uses Kalman filtering for state estimation.\n    This class is responsible for storing all the information regarding individual tracklets and performs state updates\n    and predictions based on Kalman filter.\n    Attributes:\n        shared_kalman (KalmanFilterXYAH): Shared Kalman filter that is used across all STrack instances for prediction.\n        _tlwh (np.ndarray): Private attribute to store top-left corner coordinates and width and height of bounding box.\n        kalman_filter (KalmanFilterXYAH): Instance of Kalman filter used for this particular object track.\n        mean (np.ndarray): Mean state estimate vector.",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "documentation": {}
    },
    {
        "label": "BYTETracker",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "peekOfCode": "class BYTETracker:\n    \"\"\"\n    BYTETracker: A tracking algorithm built on top of YOLOv8 for object detection and tracking.\n    The class is responsible for initializing, updating, and managing the tracks for detected objects in a video\n    sequence. It maintains the state of tracked, lost, and removed tracks over frames, utilizes Kalman filtering for\n    predicting the new object locations, and performs data association.\n    Attributes:\n        tracked_stracks (list[STrack]): List of successfully activated tracks.\n        lost_stracks (list[STrack]): List of lost tracks.\n        removed_stracks (list[STrack]): List of removed tracks.",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.byte_tracker",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "peekOfCode": "def on_predict_start(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Initialize trackers for object tracking during prediction.\n    Args:\n        predictor (object): The predictor object to initialize trackers for.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    Raises:\n        AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.\n    \"\"\"\n    if hasattr(predictor, \"trackers\") and persist:",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "on_predict_postprocess_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "peekOfCode": "def on_predict_postprocess_end(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Postprocess detected boxes and update with object tracking.\n    Args:\n        predictor (object): The predictor object containing the predictions.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    \"\"\"\n    path, im0s = predictor.batch[:2]\n    is_obb = predictor.args.task == \"obb\"\n    is_stream = predictor.dataset.mode == \"stream\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "register_tracker",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "peekOfCode": "def register_tracker(model: object, persist: bool) -> None:\n    \"\"\"\n    Register tracking callbacks to the model for object tracking during prediction.\n    Args:\n        model (object): The model object to register tracking callbacks for.\n        persist (bool): Whether to persist the trackers if they already exist.\n    \"\"\"\n    model.add_callback(\"on_predict_start\", partial(on_predict_start, persist=persist))\n    model.add_callback(\"on_predict_postprocess_end\", partial(on_predict_postprocess_end, persist=persist))",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "TRACKER_MAP",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "description": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "peekOfCode": "TRACKER_MAP = {\"bytetrack\": BYTETracker, \"botsort\": BOTSORT}\ndef on_predict_start(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Initialize trackers for object tracking during prediction.\n    Args:\n        predictor (object): The predictor object to initialize trackers for.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    Raises:\n        AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Called before the pretraining routine starts.\"\"\"\n    pass\ndef on_pretrain_routine_end(trainer):\n    \"\"\"Called after the pretraining routine ends.\"\"\"\n    pass\ndef on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Called after the pretraining routine ends.\"\"\"\n    pass\ndef on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "optimizer_step",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_before_zero_grad",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_model_save",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_params_update",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------\ndef on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "teardown",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------\ndef on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass\ndef on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass\ndef on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass\ndef on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass\ndef on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------\ndef on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------\ndef on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass\ndef on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass\ndef on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass\ndef on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass\ndef on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_postprocess_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------\ndef on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------\ndef on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass\ndef on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_export_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass\ndef on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass\ndefault_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_export_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass\ndefault_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],\n    \"on_train_start\": [on_train_start],\n    \"on_train_epoch_start\": [on_train_epoch_start],\n    \"on_train_batch_start\": [on_train_batch_start],",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "get_default_callbacks",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def get_default_callbacks():\n    \"\"\"\n    Return a copy of the default_callbacks dictionary with lists as default values.\n    Returns:\n        (defaultdict): A defaultdict with keys from default_callbacks and empty lists as default values.\n    \"\"\"\n    return defaultdict(list, deepcopy(default_callbacks))\ndef add_integration_callbacks(instance):\n    \"\"\"\n    Add integration callbacks from various sources to the instance's callbacks.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "add_integration_callbacks",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "def add_integration_callbacks(instance):\n    \"\"\"\n    Add integration callbacks from various sources to the instance's callbacks.\n    Args:\n        instance (Trainer, Predictor, Validator, Exporter): An object with a 'callbacks' attribute that is a dictionary\n            of callback lists.\n    \"\"\"\n    # Load HUB callbacks\n    from .hub import callbacks as hub_cb\n    callbacks_list = [hub_cb]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "default_callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "peekOfCode": "default_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],\n    \"on_train_start\": [on_train_start],\n    \"on_train_epoch_start\": [on_train_epoch_start],\n    \"on_train_batch_start\": [on_train_batch_start],\n    \"optimizer_step\": [optimizer_step],\n    \"on_before_zero_grad\": [on_before_zero_grad],\n    \"on_train_batch_end\": [on_train_batch_end],",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Runs at start of pretraining routine; initializes and connects/ logs task to ClearML.\"\"\"\n    try:\n        if task := Task.current_task():\n            # Make sure the automatic pytorch and matplotlib bindings are disabled!\n            # We are logging these plots and model files manually in the integration\n            PatchPyTorchModelIO.update_current_task(None)\n            PatchedMatplotlib.update_current_task(None)\n        else:\n            task = Task.init(",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Logs debug samples for the first epoch of YOLO training and report current training progress.\"\"\"\n    if task := Task.current_task():\n        # Log debug samples\n        if trainer.epoch == 1:\n            _log_debug_samples(sorted(trainer.save_dir.glob(\"train_batch*.jpg\")), \"Mosaic\")\n        # Report the current training progress\n        for k, v in trainer.label_loss_items(trainer.tloss, prefix=\"train\").items():\n            task.get_logger().report_scalar(\"train\", k, v, iteration=trainer.epoch)\n        for k, v in trainer.lr.items():",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Reports model information to logger at the end of an epoch.\"\"\"\n    if task := Task.current_task():\n        # You should have access to the validation bboxes under jdict\n        task.get_logger().report_scalar(\n            title=\"Epoch Time\", series=\"Epoch Time\", value=trainer.epoch_time, iteration=trainer.epoch\n        )\n        for k, v in trainer.metrics.items():\n            task.get_logger().report_scalar(\"val\", k, v, iteration=trainer.epoch)\n        if trainer.epoch == 0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Logs validation results including labels and predictions.\"\"\"\n    if Task.current_task():\n        # Log val_labels and val_pred\n        _log_debug_samples(sorted(validator.save_dir.glob(\"val*.jpg\")), \"Validation\")\ndef on_train_end(trainer):\n    \"\"\"Logs final model and its name on training completion.\"\"\"\n    if task := Task.current_task():\n        # Log final results, CM matrix + PR plots\n        files = [",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Logs final model and its name on training completion.\"\"\"\n    if task := Task.current_task():\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_val_end\": on_val_end,\n        \"on_train_end\": on_train_end,\n    }\n    if clearml\n    else {}",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Creates or resumes a CometML experiment at the start of a YOLO pre-training routine.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    is_alive = getattr(experiment, \"alive\", False)\n    if not experiment or not is_alive:\n        _create_experiment(trainer.args)\ndef on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save batch images at the end of training epochs.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save batch images at the end of training epochs.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    experiment.log_metrics(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=curr_step, epoch=curr_epoch)\n    if curr_epoch == 1:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs model assets at the end of each epoch.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    save_assets = metadata[\"save_assets\"]\n    experiment.log_metrics(trainer.metrics, step=curr_step, epoch=curr_epoch)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Perform operations at the end of training.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    plots = trainer.args.plots\n    _log_model(experiment, trainer)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if comet_ml\n    else {}\n)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initializes DVCLive logger for training metadata during pre-training routine.\"\"\"\n    try:\n        global live\n        live = dvclive.Live(save_dvc_exp=True, cache_images=True)\n        LOGGER.info(\"DVCLive is detected and auto logging is enabled (run 'yolo settings dvc=False' to disable).\")\n    except Exception as e:\n        LOGGER.warning(f\"WARNING  DVCLive installed but not initialized correctly, not logging this run. {e}\")\ndef on_pretrain_routine_end(trainer):\n    \"\"\"Logs plots related to the training process at the end of the pretraining routine.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Logs plots related to the training process at the end of the pretraining routine.\"\"\"\n    _log_plots(trainer.plots, \"train\")\ndef on_train_start(trainer):\n    \"\"\"Logs the training parameters if DVCLive logging is active.\"\"\"\n    if live:\n        live.log_params(trainer.args)\ndef on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Logs the training parameters if DVCLive logging is active.\"\"\"\n    if live:\n        live.log_params(trainer.args)\ndef on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch\n    _training_epoch = True\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch\n    _training_epoch = True\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"\n    global _training_epoch\n    if live and _training_epoch:\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"\n    global _training_epoch\n    if live and _training_epoch:\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value)\n        if trainer.epoch == 0:\n            from ultralytics.utils.torch_utils import model_info_for_loggers\n            for metric, value in model_info_for_loggers(trainer).items():",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Logs the best metrics, plots, and confusion matrix at the end of training if DVCLive is active.\"\"\"\n    if live:\n        # At the end log the best metrics. It runs validator on the best model internally.\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value, plot=False)\n        _log_plots(trainer.plots, \"val\")\n        _log_plots(trainer.validator.plots, \"val\")\n        _log_confusion_matrix(trainer.validator)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_train_start\": on_train_start,\n        \"on_train_epoch_start\": on_train_epoch_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if dvclive",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Logs info before starting timer for upload rate limit.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Start timer for upload rate limit\n        session.timers = {\n            \"metrics\": time(),\n            \"ckpt\": time(),\n        }  # start timer on session.rate_limit\ndef on_fit_epoch_end(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Uploads training progress metrics at the end of each epoch.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload metrics after val end\n        all_plots = {\n            **trainer.label_loss_items(trainer.tloss, prefix=\"train\"),\n            **trainer.metrics,\n        }\n        if trainer.epoch == 0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_model_save",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_model_save(trainer):\n    \"\"\"Saves checkpoints to Ultralytics HUB with rate limiting.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload checkpoints with rate limiting\n        is_best = trainer.best_fitness == trainer.fitness\n        if time() - session.timers[\"ckpt\"] > session.rate_limits[\"ckpt\"]:\n            LOGGER.info(f\"{PREFIX}Uploading checkpoint {HUB_WEB_ROOT}/models/{session.model.id}\")\n            session.upload_model(trainer.epoch, trainer.last, is_best)\n            session.timers[\"ckpt\"] = time()  # reset timer",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Upload final model and metrics to Ultralytics HUB at the end of training.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload final model and metrics with exponential standoff\n        LOGGER.info(f\"{PREFIX}Syncing final model...\")\n        session.upload_model(\n            trainer.epoch,\n            trainer.best,\n            map=trainer.metrics.get(\"metrics/mAP50-95(B)\", 0),",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Run events on train start.\"\"\"\n    events(trainer.args)\ndef on_val_start(validator):\n    \"\"\"Runs events on validation start.\"\"\"\n    events(validator.args)\ndef on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_val_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_val_start(validator):\n    \"\"\"Runs events on validation start.\"\"\"\n    events(validator.args)\ndef on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_export_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_model_save\": on_model_save,\n        \"on_train_end\": on_train_end,\n        \"on_train_start\": on_train_start,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_model_save\": on_model_save,\n        \"on_train_end\": on_train_end,\n        \"on_train_start\": on_train_start,\n        \"on_val_start\": on_val_start,\n        \"on_predict_start\": on_predict_start,\n        \"on_export_start\": on_export_start,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"\n    Log training parameters to MLflow at the end of the pretraining routine.\n    This function sets up MLflow logging based on environment variables and trainer arguments. It sets the tracking URI,\n    experiment name, and run name, then starts the MLflow run if not already active. It finally logs the parameters\n    from the trainer.\n    Args:\n        trainer (ultralytics.engine.trainer.BaseTrainer): The training object with arguments and parameters to log.\n    Global:\n        mlflow: The imported mlflow module to use for logging.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each train epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(\n            metrics={\n                **SANITIZE(trainer.lr),\n                **SANITIZE(trainer.label_loss_items(trainer.tloss, prefix=\"train\")),\n            },\n            step=trainer.epoch,\n        )",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each fit epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(metrics=SANITIZE(trainer.metrics), step=trainer.epoch)\ndef on_train_end(trainer):\n    \"\"\"Log model artifacts at the end of the training.\"\"\"\n    if mlflow:\n        mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt\n        for f in trainer.save_dir.glob(\"*\"):  # log all other files in save_dir\n            if f.suffix in {\".png\", \".jpg\", \".csv\", \".pt\", \".yaml\"}:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Log model artifacts at the end of the training.\"\"\"\n    if mlflow:\n        mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt\n        for f in trainer.save_dir.glob(\"*\"):  # log all other files in save_dir\n            if f.suffix in {\".png\", \".jpg\", \".csv\", \".pt\", \".yaml\"}:\n                mlflow.log_artifact(str(f))\n        keep_run_active = os.environ.get(\"MLFLOW_KEEP_RUN_ACTIVE\", \"False\").lower() in (\"true\")\n        if keep_run_active:\n            LOGGER.info(f\"{PREFIX}mlflow run still alive, remember to close it using mlflow.end_run()\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if mlflow\n    else {}\n)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Callback function called before the training routine starts.\"\"\"\n    try:\n        global run\n        run = neptune.init_run(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, tags=[\"YOLOv8\"])\n        run[\"Configuration/Hyperparameters\"] = {k: \"\" if v is None else v for k, v in vars(trainer.args).items()}\n    except Exception as e:\n        LOGGER.warning(f\"WARNING  NeptuneAI installed but not initialized correctly, not logging this run. {e}\")\ndef on_train_epoch_end(trainer):\n    \"\"\"Callback function called at end of each training epoch.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Callback function called at end of each training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_images({f.stem: str(f) for f in trainer.save_dir.glob(\"train_batch*.jpg\")}, \"Mosaic\")\ndef on_fit_epoch_end(trainer):\n    \"\"\"Callback function called at end of each fit (train+val) epoch.\"\"\"\n    if run and trainer.epoch == 0:\n        from ultralytics.utils.torch_utils import model_info_for_loggers",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Callback function called at end of each fit (train+val) epoch.\"\"\"\n    if run and trainer.epoch == 0:\n        from ultralytics.utils.torch_utils import model_info_for_loggers\n        run[\"Configuration/Model\"] = model_info_for_loggers(trainer)\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ndef on_val_end(validator):\n    \"\"\"Callback function called at end of each validation.\"\"\"\n    if run:\n        # Log val_labels and val_pred",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Callback function called at end of each validation.\"\"\"\n    if run:\n        # Log val_labels and val_pred\n        _log_images({f.stem: str(f) for f in validator.save_dir.glob(\"val*.jpg\")}, \"Validation\")\ndef on_train_end(trainer):\n    \"\"\"Callback function called at end of training.\"\"\"\n    if run:\n        # Log final results, CM matrix + PR plots\n        files = [",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Callback function called at end of training.\"\"\"\n    if run:\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_val_end\": on_val_end,\n        \"on_train_end\": on_train_end,\n    }\n    if neptune\n    else {}",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Sends training metrics to Ray Tune at end of each epoch.\"\"\"\n    if ray.tune.is_session_enabled():\n        metrics = trainer.metrics\n        metrics[\"epoch\"] = trainer.epoch\n        session.report(metrics)\ncallbacks = (\n    {\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n    }",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "peekOfCode": "callbacks = (\n    {\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n    }\n    if tune\n    else {}\n)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.raytune",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initialize TensorBoard logging with SummaryWriter.\"\"\"\n    if SummaryWriter:\n        try:\n            global WRITER\n            WRITER = SummaryWriter(str(trainer.save_dir))\n            LOGGER.info(f\"{PREFIX}Start with 'tensorboard --logdir {trainer.save_dir}', view at http://localhost:6006/\")\n        except Exception as e:\n            LOGGER.warning(f\"{PREFIX}WARNING  TensorBoard not initialized correctly, not logging this run. {e}\")\ndef on_train_start(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Log TensorBoard graph.\"\"\"\n    if WRITER:\n        _log_tensorboard_graph(trainer)\ndef on_train_epoch_end(trainer):\n    \"\"\"Logs scalar statistics at the end of a training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Logs scalar statistics at the end of a training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ncallbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ncallbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_start\": on_train_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n    }",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_start\": on_train_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n    }\n    if SummaryWriter\n    else {}\n)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initiate and start project if module is present.\"\"\"\n    wb.run or wb.init(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, config=vars(trainer.args))\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model information at the end of an epoch.\"\"\"\n    wb.run.log(trainer.metrics, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    if trainer.epoch == 0:\n        wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model information at the end of an epoch.\"\"\"\n    wb.run.log(trainer.metrics, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    if trainer.epoch == 0:\n        wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)\ndef on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save images at the end of each training epoch.\"\"\"\n    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save images at the end of each training epoch.\"\"\"\n    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=trainer.epoch + 1)\n    wb.run.log(trainer.lr, step=trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_plots(trainer.plots, step=trainer.epoch + 1)\ndef on_train_end(trainer):\n    \"\"\"Save the best model as an artifact at end of training.\"\"\"\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Save the best model as an artifact at end of training.\"\"\"\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    art = wb.Artifact(type=\"model\", name=f\"run_{wb.run.id}_model\")\n    if trainer.best.exists():\n        art.add_file(trainer.best)\n        wb.run.log_artifact(art, aliases=[\"best\"])\n    for curve_name, curve_values in zip(trainer.validator.metrics.curves, trainer.validator.metrics.curves_results):\n        x, y, x_title, y_title = curve_values",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if wb\n    else {}\n)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "check_train_batch_size",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "peekOfCode": "def check_train_batch_size(model, imgsz=640, amp=True):\n    \"\"\"\n    Check YOLO training batch size using the autobatch() function.\n    Args:\n        model (torch.nn.Module): YOLO model to check batch size for.\n        imgsz (int): Image size used for training.\n        amp (bool): If True, use automatic mixed precision (AMP) for training.\n    Returns:\n        (int): Optimal batch size computed using the autobatch() function.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "autobatch",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "peekOfCode": "def autobatch(model, imgsz=640, fraction=0.60, batch_size=DEFAULT_CFG.batch):\n    \"\"\"\n    Automatically estimate the best YOLO batch size to use a fraction of the available CUDA memory.\n    Args:\n        model (torch.nn.module): YOLO model to compute batch size for.\n        imgsz (int, optional): The image size used as input for the YOLO model. Defaults to 640.\n        fraction (float, optional): The fraction of available CUDA memory to use. Defaults to 0.60.\n        batch_size (int, optional): The default batch size to use if an error is detected. Defaults to 16.\n    Returns:\n        (int): The optimal batch size.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "ProfileModels",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "peekOfCode": "class ProfileModels:\n    \"\"\"\n    ProfileModels class for profiling different models on ONNX and TensorRT.\n    This class profiles the performance of different models, returning results such as model speed and FLOPs.\n    Attributes:\n        paths (list): Paths of the models to profile.\n        num_timed_runs (int): Number of timed runs for the profiling. Default is 100.\n        num_warmup_runs (int): Number of warmup runs before profiling. Default is 10.\n        min_time (float): Minimum number of seconds to profile for. Default is 60.\n        imgsz (int): Image size used in the models. Default is 640.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "documentation": {}
    },
    {
        "label": "benchmark",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "peekOfCode": "def benchmark(\n    model=WEIGHTS_DIR / \"yolov8n.pt\", data=None, imgsz=160, half=False, int8=False, device=\"cpu\", verbose=False\n):\n    \"\"\"\n    Benchmark a YOLO model across different formats for speed and accuracy.\n    Args:\n        model (str | Path | optional): Path to the model file or directory. Default is\n            Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.\n        data (str, optional): Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.\n        imgsz (int, optional): Image size for the benchmark. Default is 160.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.benchmarks",
        "documentation": {}
    },
    {
        "label": "parse_requirements",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def parse_requirements(file_path=ROOT.parent / \"requirements.txt\", package=\"\"):\n    \"\"\"\n    Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.\n    Args:\n        file_path (Path): Path to the requirements.txt file.\n        package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.\n    Returns:\n        (List[Dict[str, str]]): List of parsed requirements as dictionaries with `name` and `specifier` keys.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "parse_version",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def parse_version(version=\"0.0.0\") -> tuple:\n    \"\"\"\n    Convert a version string to a tuple of integers, ignoring any extra non-numeric string attached to the version. This\n    function replaces deprecated 'pkg_resources.parse_version(v)'.\n    Args:\n        version (str): Version string, i.e. '2.0.1+cpu'\n    Returns:\n        (tuple): Tuple of integers representing the numeric part of the version and the extra string, i.e. (2, 0, 1)\n    \"\"\"\n    try:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "is_ascii",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def is_ascii(s) -> bool:\n    \"\"\"\n    Check if a string is composed of only ASCII characters.\n    Args:\n        s (str): String to be checked.\n    Returns:\n        (bool): True if the string is composed only of ASCII characters, False otherwise.\n    \"\"\"\n    # Convert list, tuple, None, etc. to string\n    s = str(s)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_imgsz(imgsz, stride=32, min_dim=1, max_dim=2, floor=0):\n    \"\"\"\n    Verify image size is a multiple of the given stride in each dimension. If the image size is not a multiple of the\n    stride, update it to the nearest multiple of the stride that is greater than or equal to the given floor value.\n    Args:\n        imgsz (int | cList[int]): Image size.\n        stride (int): Stride value.\n        min_dim (int): Minimum number of dimensions.\n        max_dim (int): Maximum number of dimensions.\n        floor (int): Minimum allowed value for image size.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_version(\n    current: str = \"0.0.0\",\n    required: str = \"0.0.0\",\n    name: str = \"version\",\n    hard: bool = False,\n    verbose: bool = False,\n    msg: str = \"\",\n) -> bool:\n    \"\"\"\n    Check current version against the required version or range.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_latest_pypi_version",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_latest_pypi_version(package_name=\"ultralytics\"):\n    \"\"\"\n    Returns the latest version of a PyPI package without downloading or installing it.\n    Parameters:\n        package_name (str): The name of the package to find the latest version for.\n    Returns:\n        (str): The latest version of the package.\n    \"\"\"\n    with contextlib.suppress(Exception):\n        requests.packages.urllib3.disable_warnings()  # Disable the InsecureRequestWarning",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_pip_update_available",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_pip_update_available():\n    \"\"\"\n    Checks if a new version of the ultralytics package is available on PyPI.\n    Returns:\n        (bool): True if an update is available, False otherwise.\n    \"\"\"\n    if ONLINE and is_pip_package():\n        with contextlib.suppress(Exception):\n            from ultralytics import __version__\n            latest = check_latest_pypi_version()",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_font",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_font(font=\"Arial.ttf\"):\n    \"\"\"\n    Find font locally or download to user's configuration directory if it does not already exist.\n    Args:\n        font (str): Path or name of font.\n    Returns:\n        file (Path): Resolved font file path.\n    \"\"\"\n    name = Path(font).name\n    # Check USER_CONFIG_DIR",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_python",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_python(minimum: str = \"3.8.0\") -> bool:\n    \"\"\"\n    Check current python version against the required minimum version.\n    Args:\n        minimum (str): Required minimum version of python.\n    Returns:\n        (bool): Whether the installed Python version meets the minimum constraints.\n    \"\"\"\n    return check_version(PYTHON_VERSION, minimum, name=\"Python \", hard=True)\n@TryExcept()",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_requirements(requirements=ROOT.parent / \"requirements.txt\", exclude=(), install=True, cmds=\"\"):\n    \"\"\"\n    Check if installed dependencies meet YOLOv8 requirements and attempt to auto-update if needed.\n    Args:\n        requirements (Union[Path, str, List[str]]): Path to a requirements.txt file, a single package requirement as a\n            string, or a list of package requirements as strings.\n        exclude (Tuple[str]): Tuple of package names to exclude from checking.\n        install (bool): If True, attempt to auto-update packages that don't meet requirements.\n        cmds (str): Additional commands to pass to the pip install command when auto-updating.\n    Example:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_torchvision",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_torchvision():\n    \"\"\"\n    Checks the installed versions of PyTorch and Torchvision to ensure they're compatible.\n    This function checks the installed versions of PyTorch and Torchvision, and warns if they're incompatible according\n    to the provided compatibility table based on:\n    https://github.com/pytorch/vision#installation.\n    The compatibility table is a dictionary where the keys are PyTorch versions and the values are lists of compatible\n    Torchvision versions.\n    \"\"\"\n    import torchvision",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_suffix(file=\"yolov8n.pt\", suffix=\".pt\", msg=\"\"):\n    \"\"\"Check file(s) for acceptable suffix.\"\"\"\n    if file and suffix:\n        if isinstance(suffix, str):\n            suffix = (suffix,)\n        for f in file if isinstance(file, (list, tuple)) else [file]:\n            s = Path(f).suffix.lower().strip()  # file suffix\n            if len(s):\n                assert s in suffix, f\"{msg}{f} acceptable suffix is {suffix}, not {s}\"\ndef check_yolov5u_filename(file: str, verbose: bool = True):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolov5u_filename",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_yolov5u_filename(file: str, verbose: bool = True):\n    \"\"\"Replace legacy YOLOv5 filenames with updated YOLOv5u filenames.\"\"\"\n    if \"yolov3\" in file or \"yolov5\" in file:\n        if \"u.yaml\" in file:\n            file = file.replace(\"u.yaml\", \".yaml\")  # i.e. yolov5nu.yaml -> yolov5n.yaml\n        elif \".pt\" in file and \"u\" not in file:\n            original_file = file\n            file = re.sub(r\"(.*yolov5([nsmlx]))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n.pt -> yolov5nu.pt\n            file = re.sub(r\"(.*yolov5([nsmlx])6)\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n6.pt -> yolov5n6u.pt\n            file = re.sub(r\"(.*yolov3(|-tiny|-spp))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov3-spp.pt -> yolov3-sppu.pt",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_model_file_from_stem",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_model_file_from_stem(model=\"yolov8n\"):\n    \"\"\"Return a model filename from a valid model stem.\"\"\"\n    if model and not Path(model).suffix and Path(model).stem in downloads.GITHUB_ASSETS_STEMS:\n        return Path(model).with_suffix(\".pt\")  # add suffix, i.e. yolov8n -> yolov8n.pt\n    else:\n        return model\ndef check_file(file, suffix=\"\", download=True, hard=True):\n    \"\"\"Search/download file (if necessary) and return path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file).strip()  # convert to string and strip spaces",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_file(file, suffix=\"\", download=True, hard=True):\n    \"\"\"Search/download file (if necessary) and return path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file).strip()  # convert to string and strip spaces\n    file = check_yolov5u_filename(file)  # yolov5n -> yolov5nu\n    if (\n        not file\n        or (\"://\" not in file and Path(file).exists())  # '://' check required in Windows Python<3.10\n        or file.lower().startswith(\"grpc://\")\n    ):  # file exists or gRPC Triton images",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_yaml(file, suffix=(\".yaml\", \".yml\"), hard=True):\n    \"\"\"Search/download YAML file (if necessary) and return path, checking suffix.\"\"\"\n    return check_file(file, suffix, hard=hard)\ndef check_is_path_safe(basedir, path):\n    \"\"\"\n    Check if the resolved path is under the intended directory to prevent path traversal.\n    Args:\n        basedir (Path | str): The intended directory.\n        path (Path | str): The path to check.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_is_path_safe",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_is_path_safe(basedir, path):\n    \"\"\"\n    Check if the resolved path is under the intended directory to prevent path traversal.\n    Args:\n        basedir (Path | str): The intended directory.\n        path (Path | str): The path to check.\n    Returns:\n        (bool): True if the path is safe, False otherwise.\n    \"\"\"\n    base_dir_resolved = Path(basedir).resolve()",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_imshow(warn=False):\n    \"\"\"Check if environment supports image displays.\"\"\"\n    try:\n        if LINUX:\n            assert \"DISPLAY\" in os.environ and not is_docker() and not is_colab() and not is_kaggle()\n        cv2.imshow(\"test\", np.zeros((8, 8, 3), dtype=np.uint8))  # show a small 8-pixel image\n        cv2.waitKey(1)\n        cv2.destroyAllWindows()\n        cv2.waitKey(1)\n        return True",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolo",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_yolo(verbose=True, device=\"\"):\n    \"\"\"Return a human-readable YOLO software and hardware summary.\"\"\"\n    import psutil\n    from ultralytics.utils.torch_utils import select_device\n    if is_jupyter():\n        if check_requirements(\"wandb\", install=False):\n            os.system(\"pip uninstall -y wandb\")  # uninstall wandb: unwanted account creation prompt with infinite hang\n        if is_colab():\n            shutil.rmtree(\"sample_data\", ignore_errors=True)  # remove colab /sample_data directory\n    if verbose:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "collect_system_info",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def collect_system_info():\n    \"\"\"Collect and print relevant system information including OS, Python, RAM, CPU, and CUDA.\"\"\"\n    import psutil\n    from ultralytics.utils import ENVIRONMENT, is_git_dir\n    from ultralytics.utils.torch_utils import get_cpu_info\n    ram_info = psutil.virtual_memory().total / (1024**3)  # Convert bytes to GB\n    check_yolo()\n    LOGGER.info(\n        f\"\\n{'OS':<20}{platform.platform()}\\n\"\n        f\"{'Environment':<20}{ENVIRONMENT}\\n\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_amp",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def check_amp(model):\n    \"\"\"\n    This function checks the PyTorch Automatic Mixed Precision (AMP) functionality of a YOLOv8 model. If the checks\n    fail, it means there are anomalies with AMP on the system that may cause NaN losses or zero-mAP results, so AMP will\n    be disabled during training.\n    Args:\n        model (nn.Module): A YOLOv8 model instance.\n    Example:\n        ```python\n        from ultralytics import YOLO",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "git_describe",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def git_describe(path=ROOT):  # path must be a directory\n    \"\"\"Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe.\"\"\"\n    with contextlib.suppress(Exception):\n        return subprocess.check_output(f\"git -C {path} describe --tags --long --always\", shell=True).decode()[:-1]\n    return \"\"\ndef print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Print function arguments (optional args dict).\"\"\"\n    def strip_auth(v):\n        \"\"\"Clean longer Ultralytics HUB URLs by stripping potential authentication information.\"\"\"\n        return clean_url(v) if (isinstance(v, str) and v.startswith(\"http\") and len(v) > 100) else v",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "print_args",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Print function arguments (optional args dict).\"\"\"\n    def strip_auth(v):\n        \"\"\"Clean longer Ultralytics HUB URLs by stripping potential authentication information.\"\"\"\n        return clean_url(v) if (isinstance(v, str) and v.startswith(\"http\") and len(v) > 100) else v\n    x = inspect.currentframe().f_back  # previous frame\n    file, _, func, _, _ = inspect.getframeinfo(x)\n    if args is None:  # get args automatically\n        args, _, _, frm = inspect.getargvalues(x)\n        args = {k: v for k, v in frm.items() if k in args}",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "cuda_device_count",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def cuda_device_count() -> int:\n    \"\"\"\n    Get the number of NVIDIA GPUs available in the environment.\n    Returns:\n        (int): The number of NVIDIA GPUs available.\n    \"\"\"\n    try:\n        # Run the nvidia-smi command and capture its output\n        output = subprocess.check_output(\n            [\"nvidia-smi\", \"--query-gpu=count\", \"--format=csv,noheader,nounits\"], encoding=\"utf-8\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "cuda_is_available",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "def cuda_is_available() -> bool:\n    \"\"\"\n    Check if CUDA is available in the environment.\n    Returns:\n        (bool): True if one or more NVIDIA GPUs are available, False otherwise.\n    \"\"\"\n    return cuda_device_count() > 0\n# Define constants\nIS_PYTHON_3_12 = PYTHON_VERSION.startswith(\"3.12\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "PYTHON_VERSION = platform.python_version()\ndef parse_requirements(file_path=ROOT.parent / \"requirements.txt\", package=\"\"):\n    \"\"\"\n    Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.\n    Args:\n        file_path (Path): Path to the requirements.txt file.\n        package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.\n    Returns:\n        (List[Dict[str, str]]): List of parsed requirements as dictionaries with `name` and `specifier` keys.\n    Example:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "IS_PYTHON_3_12",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "peekOfCode": "IS_PYTHON_3_12 = PYTHON_VERSION.startswith(\"3.12\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "find_free_network_port",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "peekOfCode": "def find_free_network_port() -> int:\n    \"\"\"\n    Finds a free port on localhost.\n    It is useful in single-node training when we don't want to connect to a real main node but have to set the\n    `MASTER_PORT` environment variable.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]  # port\ndef generate_ddp_file(trainer):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_file",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "peekOfCode": "def generate_ddp_file(trainer):\n    \"\"\"Generates a DDP file and returns its file name.\"\"\"\n    module, name = f\"{trainer.__class__.__module__}.{trainer.__class__.__name__}\".rsplit(\".\", 1)\n    content = f\"\"\"\n# Ultralytics Multi-GPU training temp file (should be automatically deleted after use)\noverrides = {vars(trainer.args)}\nif __name__ == \"__main__\":\n    from {module} import {name}\n    from ultralytics.utils import DEFAULT_CFG_DICT\n    cfg = DEFAULT_CFG_DICT.copy()",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_command",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "peekOfCode": "def generate_ddp_command(world_size, trainer):\n    \"\"\"Generates and returns command for distributed training.\"\"\"\n    import __main__  # noqa local import to avoid https://github.com/Lightning-AI/lightning/issues/15218\n    if not trainer.resume:\n        shutil.rmtree(trainer.save_dir)  # remove the save_dir\n    file = generate_ddp_file(trainer)\n    dist_cmd = \"torch.distributed.run\" if TORCH_1_9 else \"torch.distributed.launch\"\n    port = find_free_network_port()\n    cmd = [sys.executable, \"-m\", dist_cmd, \"--nproc_per_node\", f\"{world_size}\", \"--master_port\", f\"{port}\", file]\n    return cmd, file",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "ddp_cleanup",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "peekOfCode": "def ddp_cleanup(trainer, file):\n    \"\"\"Delete temp file if created.\"\"\"\n    if f\"{id(trainer)}.py\" in file:  # if temp_file suffix in file\n        os.remove(file)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "overrides",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "peekOfCode": "overrides = {vars(trainer.args)}\nif __name__ == \"__main__\":\n    from {module} import {name}\n    from ultralytics.utils import DEFAULT_CFG_DICT\n    cfg = DEFAULT_CFG_DICT.copy()\n    cfg.update(save_dir='')   # handle the extra key 'save_dir'\n    trainer = {name}(cfg=cfg, overrides=overrides)\n    results = trainer.train()\n\"\"\"\n    (USER_CONFIG_DIR / \"DDP\").mkdir(exist_ok=True)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "is_url",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def is_url(url, check=False):\n    \"\"\"\n    Validates if the given string is a URL and optionally checks if the URL exists online.\n    Args:\n        url (str): The string to be validated as a URL.\n        check (bool, optional): If True, performs an additional check to see if the URL exists online.\n            Defaults to True.\n    Returns:\n        (bool): Returns True for a valid URL. If 'check' is True, also returns True if the URL exists online.\n            Returns False otherwise.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "delete_dsstore",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def delete_dsstore(path, files_to_delete=(\".DS_Store\", \"__MACOSX\")):\n    \"\"\"\n    Deletes all \".DS_store\" files under a specified directory.\n    Args:\n        path (str, optional): The directory path where the \".DS_store\" files should be deleted.\n        files_to_delete (tuple): The files to be deleted.\n    Example:\n        ```python\n        from ultralytics.utils.downloads import delete_dsstore\n        delete_dsstore('path/to/dir')",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "zip_directory",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def zip_directory(directory, compress=True, exclude=(\".DS_Store\", \"__MACOSX\"), progress=True):\n    \"\"\"\n    Zips the contents of a directory, excluding files containing strings in the exclude list. The resulting zip file is\n    named after the directory and placed alongside it.\n    Args:\n        directory (str | Path): The path to the directory to be zipped.\n        compress (bool): Whether to compress the files while zipping. Default is True.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').\n        progress (bool, optional): Whether to display a progress bar. Defaults to True.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "unzip_file",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def unzip_file(file, path=None, exclude=(\".DS_Store\", \"__MACOSX\"), exist_ok=False, progress=True):\n    \"\"\"\n    Unzips a *.zip file to the specified path, excluding files containing strings in the exclude list.\n    If the zipfile does not contain a single top-level directory, the function will create a new\n    directory with the same name as the zipfile (without the extension) to extract its contents.\n    If a path is not provided, the function will use the parent directory of the zipfile as the default path.\n    Args:\n        file (str): The path to the zipfile to be extracted.\n        path (str, optional): The path to extract the zipfile to. Defaults to None.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "check_disk_space",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def check_disk_space(url=\"https://ultralytics.com/assets/coco128.zip\", path=Path.cwd(), sf=1.5, hard=True):\n    \"\"\"\n    Check if there is sufficient disk space to download and store a file.\n    Args:\n        url (str, optional): The URL to the file. Defaults to 'https://ultralytics.com/assets/coco128.zip'.\n        path (str | Path, optional): The path or drive to check the available free space on.\n        sf (float, optional): Safety factor, the multiplier for the required free space. Defaults to 2.0.\n        hard (bool, optional): Whether to throw an error or not on insufficient disk space. Defaults to True.\n    Returns:\n        (bool): True if there is sufficient disk space, False otherwise.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_google_drive_file_info",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def get_google_drive_file_info(link):\n    \"\"\"\n    Retrieves the direct download link and filename for a shareable Google Drive file link.\n    Args:\n        link (str): The shareable link of the Google Drive file.\n    Returns:\n        (str): Direct download URL for the Google Drive file.\n        (str): Original filename of the Google Drive file. If filename extraction fails, returns None.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "safe_download",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def safe_download(\n    url,\n    file=None,\n    dir=None,\n    unzip=True,\n    delete=False,\n    curl=False,\n    retry=3,\n    min_bytes=1e0,\n    exist_ok=False,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_github_assets",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def get_github_assets(repo=\"ultralytics/assets\", version=\"latest\", retry=False):\n    \"\"\"\n    Retrieve the specified version's tag and assets from a GitHub repository. If the version is not specified, the\n    function fetches the latest release assets.\n    Args:\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        version (str, optional): The release version to fetch assets from. Defaults to 'latest'.\n        retry (bool, optional): Flag to retry the request in case of a failure. Defaults to False.\n    Returns:\n        (tuple): A tuple containing the release tag and a list of asset names.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def attempt_download_asset(file, repo=\"ultralytics/assets\", release=\"v8.1.0\", **kwargs):\n    \"\"\"\n    Attempt to download a file from GitHub release assets if it is not found locally. The function checks for the file\n    locally first, then tries to download it from the specified GitHub repository release.\n    Args:\n        file (str | Path): The filename or file path to be downloaded.\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        release (str, optional): The specific release version to be downloaded. Defaults to 'v8.1.0'.\n        **kwargs (any): Additional keyword arguments for the download process.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "download",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "def download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3, exist_ok=False):\n    \"\"\"\n    Downloads files from specified URLs to a given directory. Supports concurrent downloads if multiple threads are\n    specified.\n    Args:\n        url (str | list): The URL or list of URLs of the files to be downloaded.\n        dir (Path, optional): The directory where the files will be saved. Defaults to the current working directory.\n        unzip (bool, optional): Flag to unzip the files after downloading. Defaults to True.\n        delete (bool, optional): Flag to delete the zip files after extraction. Defaults to False.\n        curl (bool, optional): Flag to use curl for downloading. Defaults to False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_REPO",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_REPO = \"ultralytics/assets\"\nGITHUB_ASSETS_NAMES = (\n    [f\"yolov8{k}{suffix}.pt\" for k in \"nsmlx\" for suffix in (\"\", \"-cls\", \"-seg\", \"-pose\", \"-obb\")]\n    + [f\"yolov5{k}{resolution}u.pt\" for k in \"nsmlx\" for resolution in (\"\", \"6\")]\n    + [f\"yolov3{k}u.pt\" for k in (\"\", \"-spp\", \"-tiny\")]\n    + [f\"yolov8{k}-world.pt\" for k in \"smlx\"]\n    + [f\"yolov8{k}-worldv2.pt\" for k in \"smlx\"]\n    + [f\"yolov9{k}.pt\" for k in \"ce\"]\n    + [f\"yolo_nas_{k}.pt\" for k in \"sml\"]\n    + [f\"sam_{k}.pt\" for k in \"bl\"]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_NAMES",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_NAMES = (\n    [f\"yolov8{k}{suffix}.pt\" for k in \"nsmlx\" for suffix in (\"\", \"-cls\", \"-seg\", \"-pose\", \"-obb\")]\n    + [f\"yolov5{k}{resolution}u.pt\" for k in \"nsmlx\" for resolution in (\"\", \"6\")]\n    + [f\"yolov3{k}u.pt\" for k in (\"\", \"-spp\", \"-tiny\")]\n    + [f\"yolov8{k}-world.pt\" for k in \"smlx\"]\n    + [f\"yolov8{k}-worldv2.pt\" for k in \"smlx\"]\n    + [f\"yolov9{k}.pt\" for k in \"ce\"]\n    + [f\"yolo_nas_{k}.pt\" for k in \"sml\"]\n    + [f\"sam_{k}.pt\" for k in \"bl\"]\n    + [f\"FastSAM-{k}.pt\" for k in \"sx\"]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_STEMS",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_STEMS = [Path(k).stem for k in GITHUB_ASSETS_NAMES]\ndef is_url(url, check=False):\n    \"\"\"\n    Validates if the given string is a URL and optionally checks if the URL exists online.\n    Args:\n        url (str): The string to be validated as a URL.\n        check (bool, optional): If True, performs an additional check to see if the URL exists online.\n            Defaults to True.\n    Returns:\n        (bool): Returns True for a valid URL. If 'check' is True, also returns True if the URL exists online.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "HUBModelError",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.errors",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.errors",
        "peekOfCode": "class HUBModelError(Exception):\n    \"\"\"\n    Custom exception class for handling errors related to model fetching in Ultralytics YOLO.\n    This exception is raised when a requested model is not found or cannot be retrieved.\n    The message is also processed to include emojis for better user experience.\n    Attributes:\n        message (str): The error message displayed when the exception is raised.\n    Note:\n        The message is automatically processed through the 'emojis' function from the 'ultralytics.utils' package.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.errors",
        "documentation": {}
    },
    {
        "label": "WorkingDirectory",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "class WorkingDirectory(contextlib.ContextDecorator):\n    \"\"\"Usage: @WorkingDirectory(dir) decorator or 'with WorkingDirectory(dir):' context manager.\"\"\"\n    def __init__(self, new_dir):\n        \"\"\"Sets the working directory to 'new_dir' upon instantiation.\"\"\"\n        self.dir = new_dir  # new dir\n        self.cwd = Path.cwd().resolve()  # current dir\n    def __enter__(self):\n        \"\"\"Changes the current directory to the specified directory.\"\"\"\n        os.chdir(self.dir)\n    def __exit__(self, exc_type, exc_val, exc_tb):  # noqa",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "spaces_in_path",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def spaces_in_path(path):\n    \"\"\"\n    Context manager to handle paths with spaces in their names. If a path contains spaces, it replaces them with\n    underscores, copies the file/directory to the new path, executes the context code block, then copies the\n    file/directory back to its original location.\n    Args:\n        path (str | Path): The original path.\n    Yields:\n        (Path): Temporary path with spaces replaced by underscores if spaces were present, otherwise the original path.\n    Example:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def increment_path(path, exist_ok=False, sep=\"\", mkdir=False):\n    \"\"\"\n    Increments a file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.\n    If the path exists and exist_ok is not set to True, the path will be incremented by appending a number and sep to\n    the end of the path. If the path is a file, the file extension will be preserved. If the path is a directory, the\n    number will be appended directly to the end of the path. If mkdir is set to True, the path will be created as a\n    directory if it does not already exist.\n    Args:\n        path (str, pathlib.Path): Path to increment.\n        exist_ok (bool, optional): If True, the path will not be incremented and returned as-is. Defaults to False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_age",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def file_age(path=__file__):\n    \"\"\"Return days since last file update.\"\"\"\n    dt = datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime)  # delta\n    return dt.days  # + dt.seconds / 86400  # fractional days\ndef file_date(path=__file__):\n    \"\"\"Return human-readable file modification date, i.e. '2021-3-26'.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\ndef file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_date",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def file_date(path=__file__):\n    \"\"\"Return human-readable file modification date, i.e. '2021-3-26'.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\ndef file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"\n    if isinstance(path, (str, Path)):\n        mb = 1 << 20  # bytes to MiB (1024 ** 2)\n        path = Path(path)\n        if path.is_file():",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"\n    if isinstance(path, (str, Path)):\n        mb = 1 << 20  # bytes to MiB (1024 ** 2)\n        path = Path(path)\n        if path.is_file():\n            return path.stat().st_size / mb\n        elif path.is_dir():\n            return sum(f.stat().st_size for f in path.glob(\"**/*\") if f.is_file()) / mb\n    return 0.0",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "get_latest_run",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def get_latest_run(search_dir=\".\"):\n    \"\"\"Return path to most recent 'last.pt' in /runs (i.e. to --resume from).\"\"\"\n    last_list = glob.glob(f\"{search_dir}/**/last*.pt\", recursive=True)\n    return max(last_list, key=os.path.getctime) if last_list else \"\"\ndef update_models(model_names=(\"yolov8n.pt\",), source_dir=Path(\".\"), update_names=False):\n    \"\"\"\n    Updates and re-saves specified YOLO models in an 'updated_models' subdirectory.\n    Args:\n        model_names (tuple, optional): Model filenames to update, defaults to (\"yolov8n.pt\").\n        source_dir (Path, optional): Directory containing models and target subdirectory, defaults to current directory.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "update_models",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "peekOfCode": "def update_models(model_names=(\"yolov8n.pt\",), source_dir=Path(\".\"), update_names=False):\n    \"\"\"\n    Updates and re-saves specified YOLO models in an 'updated_models' subdirectory.\n    Args:\n        model_names (tuple, optional): Model filenames to update, defaults to (\"yolov8n.pt\").\n        source_dir (Path, optional): Directory containing models and target subdirectory, defaults to current directory.\n        update_names (bool, optional): Update model names from a data YAML.\n    Example:\n        ```python\n        from ultralytics.utils.files import update_models",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "Bboxes",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "class Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').\n    Note:\n        This class does not handle normalization or denormalization of bounding boxes.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "Instances",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "class Instances:\n    \"\"\"\n    Container for bounding boxes, segments, and keypoints of detected objects in an image.\n    Attributes:\n        _bboxes (Bboxes): Internal object for handling bounding box operations.\n        keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3]. Default is None.\n        normalized (bool): Flag indicating whether the bounding box coordinates are normalized.\n        segments (ndarray): Segments array with shape [N, 1000, 2] after resampling.\n    Args:\n        bboxes (ndarray): An array of bounding boxes with shape [N, 4].",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_2tuple",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "to_2tuple = _ntuple(2)\nto_4tuple = _ntuple(4)\n# `xyxy` means left top and right bottom\n# `xywh` means center x, center y and width, height(YOLO format)\n# `ltwh` means left top and width, height(COCO format)\n_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_4tuple",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "to_4tuple = _ntuple(4)\n# `xyxy` means left top and right bottom\n# `xywh` means center x, center y and width, height(YOLO format)\n# `ltwh` means left top and width, height(COCO format)\n_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "_formats",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "peekOfCode": "__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').\n    Note:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "VarifocalLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class VarifocalLoss(nn.Module):\n    \"\"\"\n    Varifocal loss by Zhang et al.\n    https://arxiv.org/abs/2008.13367.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the VarifocalLoss class.\"\"\"\n        super().__init__()\n    @staticmethod\n    def forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "FocalLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class FocalLoss(nn.Module):\n    \"\"\"Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5).\"\"\"\n    def __init__(self):\n        \"\"\"Initializer for FocalLoss class with no parameters.\"\"\"\n        super().__init__()\n    @staticmethod\n    def forward(pred, label, gamma=1.5, alpha=0.25):\n        \"\"\"Calculates and updates confusion matrix for object detection/classification tasks.\"\"\"\n        loss = F.binary_cross_entropy_with_logits(pred, label, reduction=\"none\")\n        # p_t = torch.exp(-loss)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "BboxLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class BboxLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__()\n        self.reg_max = reg_max\n        self.use_dfl = use_dfl\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "RotatedBboxLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class RotatedBboxLoss(BboxLoss):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__(reg_max, use_dfl)\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n        iou = probiou(pred_bboxes[fg_mask], target_bboxes[fg_mask])\n        loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "KeypointLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class KeypointLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, sigmas) -> None:\n        \"\"\"Initialize the KeypointLoss class.\"\"\"\n        super().__init__()\n        self.sigmas = sigmas\n    def forward(self, pred_kpts, gt_kpts, kpt_mask, area):\n        \"\"\"Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints.\"\"\"\n        d = (pred_kpts[..., 0] - gt_kpts[..., 0]).pow(2) + (pred_kpts[..., 1] - gt_kpts[..., 1]).pow(2)\n        kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8DetectionLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v8DetectionLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model, tal_topk=10):  # model must be de-paralleled\n        \"\"\"Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function.\"\"\"\n        device = next(model.parameters()).device  # get model device\n        h = model.args  # hyperparameters\n        m = model.model[-1]  # Detect() module\n        self.bce = nn.BCEWithLogitsLoss(reduction=\"none\")\n        self.hyp = h\n        self.stride = m.stride  # model strides",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8SegmentationLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v8SegmentationLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument.\"\"\"\n        super().__init__(model)\n        self.overlap = model.args.overlap_mask\n    def __call__(self, preds, batch):\n        \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n        loss = torch.zeros(4, device=self.device)  # box, cls, dfl\n        feats, pred_masks, proto = preds if len(preds) == 3 else preds[1]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8PoseLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v8PoseLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance.\"\"\"\n        super().__init__(model)\n        self.kpt_shape = model.model[-1].kpt_shape\n        self.bce_pose = nn.BCEWithLogitsLoss()\n        is_pose = self.kpt_shape == [17, 3]\n        nkpt = self.kpt_shape[0]  # number of keypoints\n        sigmas = torch.from_numpy(OKS_SIGMA).to(self.device) if is_pose else torch.ones(nkpt, device=self.device) / nkpt",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8ClassificationLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v8ClassificationLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __call__(self, preds, batch):\n        \"\"\"Compute the classification loss between predictions and true labels.\"\"\"\n        loss = torch.nn.functional.cross_entropy(preds, batch[\"cls\"], reduction=\"mean\")\n        loss_items = loss.detach()\n        return loss, loss_items\nclass v8OBBLoss(v8DetectionLoss):\n    def __init__(self, model):\n        \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8OBBLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v8OBBLoss(v8DetectionLoss):\n    def __init__(self, model):\n        \"\"\"\n        Initializes v8OBBLoss with model, assigner, and rotated bbox loss.\n        Note model must be de-paralleled.\n        \"\"\"\n        super().__init__(model)\n        self.assigner = RotatedTaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)\n        self.bbox_loss = RotatedBboxLoss(self.reg_max - 1, use_dfl=self.use_dfl).to(self.device)\n    def preprocess(self, targets, batch_size, scale_tensor):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v10DetectLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "peekOfCode": "class v10DetectLoss:\n    def __init__(self, model):\n        self.one2many = v8DetectionLoss(model, tal_topk=10)\n        self.one2one = v8DetectionLoss(model, tal_topk=1)\n    def __call__(self, preds, batch):\n        one2many = preds[\"one2many\"]\n        loss_one2many = self.one2many(one2many, batch)\n        one2one = preds[\"one2one\"]\n        loss_one2one = self.one2one(one2one, batch)\n        return loss_one2many[0] + loss_one2one[0], torch.cat((loss_one2many[1], loss_one2one[1]))",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class ConfusionMatrix:\n    \"\"\"\n    A class for calculating and updating a confusion matrix for object detection and classification tasks.\n    Attributes:\n        task (str): The type of task, either 'detect' or 'classify'.\n        matrix (np.ndarray): The confusion matrix, with dimensions depending on the task.\n        nc (int): The number of classes.\n        conf (float): The confidence threshold for detections.\n        iou_thres (float): The Intersection over Union threshold.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "Metric",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class Metric(SimpleClass):\n    \"\"\"\n    Class for computing evaluation metrics for YOLOv8 model.\n    Attributes:\n        p (list): Precision for each class. Shape: (nc,).\n        r (list): Recall for each class. Shape: (nc,).\n        f1 (list): F1 score for each class. Shape: (nc,).\n        all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).\n        ap_class_index (list): Index of class for each AP score. Shape: (nc,).\n        nc (int): Number of classes.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "DetMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class DetMetrics(SimpleClass):\n    \"\"\"\n    This class is a utility class for computing detection metrics such as precision, recall, and mean average precision\n    (mAP) of an object detection model.\n    Args:\n        save_dir (Path): A path to the directory where the output plots will be saved. Defaults to current directory.\n        plot (bool): A flag that indicates whether to plot precision-recall curves for each class. Defaults to False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (tuple of str): A tuple of strings that represents the names of the classes. Defaults to an empty tuple.\n    Attributes:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class SegmentMetrics(SimpleClass):\n    \"\"\"\n    Calculates and aggregates detection and segmentation metrics over a given set of classes.\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "PoseMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class PoseMetrics(SegmentMetrics):\n    \"\"\"\n    Calculates and aggregates detection and pose metrics over a given set of classes.\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ClassifyMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class ClassifyMetrics(SimpleClass):\n    \"\"\"\n    Class for computing classification metrics including top-1 and top-5 accuracy.\n    Attributes:\n        top1 (float): The top-1 accuracy.\n        top5 (float): The top-5 accuracy.\n        speed (Dict[str, float]): A dictionary containing the time taken for each step in the pipeline.\n    Properties:\n        fitness (float): The fitness of the model, which is equal to top-5 accuracy.\n        results_dict (Dict[str, Union[float, str]]): A dictionary containing the classification metrics and fitness.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OBBMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "class OBBMetrics(SimpleClass):\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -> None:\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    def process(self, tp, conf, pred_cls, target_cls):\n        \"\"\"Process predicted results for object detection and update metrics.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def bbox_ioa(box1, box2, iou=False, eps=1e-7):\n    \"\"\"\n    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.\n    Args:\n        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.\n        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.\n        iou (bool): Calculate the standard IoU if True else return inter_area/box2_area.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (np.ndarray): A numpy array of shape (n, m) representing the intersection over box2 area.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def box_iou(box1, box2, eps=1e-7):\n    \"\"\"\n    Calculate intersection-over-union (IoU) of boxes. Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n    Based on https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py\n    Args:\n        box1 (torch.Tensor): A tensor of shape (N, 4) representing N bounding boxes.\n        box2 (torch.Tensor): A tensor of shape (M, 4) representing M bounding boxes.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): An NxM tensor containing the pairwise IoU values for every element in box1 and box2.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate Intersection over Union (IoU) of box1(1, 4) to box2(n, 4).\n    Args:\n        box1 (torch.Tensor): A tensor representing a single bounding box with shape (1, 4).\n        box2 (torch.Tensor): A tensor representing n bounding boxes with shape (n, 4).\n        xywh (bool, optional): If True, input boxes are in (x, y, w, h) format. If False, input boxes are in\n                               (x1, y1, x2, y2) format. Defaults to True.\n        GIoU (bool, optional): If True, calculate Generalized IoU. Defaults to False.\n        DIoU (bool, optional): If True, calculate Distance IoU. Defaults to False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "mask_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def mask_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    Calculate masks IoU.\n    Args:\n        mask1 (torch.Tensor): A tensor of shape (N, n) where N is the number of ground truth objects and n is the\n                        product of image width and height.\n        mask2 (torch.Tensor): A tensor of shape (M, n) where M is the number of predicted objects and n is the\n                        product of image width and height.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "kpt_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def kpt_iou(kpt1, kpt2, area, sigma, eps=1e-7):\n    \"\"\"\n    Calculate Object Keypoint Similarity (OKS).\n    Args:\n        kpt1 (torch.Tensor): A tensor of shape (N, 17, 3) representing ground truth keypoints.\n        kpt2 (torch.Tensor): A tensor of shape (M, 17, 3) representing predicted keypoints.\n        area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.\n        sigma (list): A list containing 17 values representing keypoint scales.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "probiou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def probiou(obb1, obb2, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n    Args:\n        obb1 (torch.Tensor): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor): A tensor of shape (N, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): A tensor of shape (N, ) representing obb similarities.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def batch_probiou(obb1, obb2, eps=1e-7):\n    \"\"\"\n    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n    Args:\n        obb1 (torch.Tensor | np.ndarray): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor | np.ndarray): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "smooth_BCE",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def smooth_BCE(eps=0.1):\n    \"\"\"\n    Computes smoothed positive and negative Binary Cross-Entropy targets.\n    This function calculates positive and negative label smoothing BCE targets based on a given epsilon value.\n    For implementation details, refer to https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441.\n    Args:\n        eps (float, optional): The epsilon value for label smoothing. Defaults to 0.1.\n    Returns:\n        (tuple): A tuple containing the positive and negative label smoothing BCE targets.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "smooth",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def smooth(y, f=0.05):\n    \"\"\"Box filter of fraction f.\"\"\"\n    nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)\n    p = np.ones(nf // 2)  # ones padding\n    yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded\n    return np.convolve(yp, np.ones(nf) / nf, mode=\"valid\")  # y-smoothed\n@plt_settings()\ndef plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=(), on_plot=None):\n    \"\"\"Plots a precision-recall curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "plot_pr_curve",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=(), on_plot=None):\n    \"\"\"Plots a precision-recall curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    py = np.stack(py, axis=1)\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py.T):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]} {ap[i, 0]:.3f}\")  # plot(recall, precision)\n    else:\n        ax.plot(px, py, linewidth=1, color=\"grey\")  # plot(recall, precision)\n    ax.plot(px, py.mean(1), linewidth=3, color=\"blue\", label=\"all classes %.3f mAP@0.5\" % ap[:, 0].mean())",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "plot_mc_curve",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def plot_mc_curve(px, py, save_dir=Path(\"mc_curve.png\"), names=(), xlabel=\"Confidence\", ylabel=\"Metric\", on_plot=None):\n    \"\"\"Plots a metric-confidence curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]}\")  # plot(confidence, metric)\n    else:\n        ax.plot(px, py.T, linewidth=1, color=\"grey\")  # plot(confidence, metric)\n    y = smooth(py.mean(0), 0.05)\n    ax.plot(px, y, linewidth=3, color=\"blue\", label=f\"all classes {y.max():.2f} at {px[y.argmax()]:.3f}\")",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "compute_ap",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def compute_ap(recall, precision):\n    \"\"\"\n    Compute the average precision (AP) given the recall and precision curves.\n    Args:\n        recall (list): The recall curve.\n        precision (list): The precision curve.\n    Returns:\n        (float): Average precision.\n        (np.ndarray): Precision envelope curve.\n        (np.ndarray): Modified recall curve with sentinel values added at the beginning and end.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ap_per_class",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "def ap_per_class(\n    tp, conf, pred_cls, target_cls, plot=False, on_plot=None, save_dir=Path(), names=(), eps=1e-16, prefix=\"\"\n):\n    \"\"\"\n    Computes the average precision per class for object detection evaluation.\n    Args:\n        tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).\n        conf (np.ndarray): Array of confidence scores of the detections.\n        pred_cls (np.ndarray): Array of predicted classes of the detections.\n        target_cls (np.ndarray): Array of true classes of the detections.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "peekOfCode": "OKS_SIGMA = (\n    np.array([0.26, 0.25, 0.25, 0.35, 0.35, 0.79, 0.79, 0.72, 0.72, 0.62, 0.62, 1.07, 1.07, 0.87, 0.87, 0.89, 0.89])\n    / 10.0\n)\ndef bbox_ioa(box1, box2, iou=False, eps=1e-7):\n    \"\"\"\n    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.\n    Args:\n        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.\n        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "class Profile(contextlib.ContextDecorator):\n    \"\"\"\n    YOLOv8 Profile class. Use as a decorator with @Profile() or as a context manager with 'with Profile():'.\n    Example:\n        ```python\n        from ultralytics.utils.ops import Profile\n        with Profile(device=device) as dt:\n            pass  # slow operation here\n        print(dt)  # prints \"Elapsed time is 9.5367431640625e-07 s\"\n        ```",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segment2box",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def segment2box(segment, width=640, height=640):\n    \"\"\"\n    Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).\n    Args:\n        segment (torch.Tensor): the segment label\n        width (int): the width of the image. Defaults to 640\n        height (int): The height of the image. Defaults to 640\n    Returns:\n        (np.ndarray): the minimum and maximum x and y values of the segment.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True, xywh=False):\n    \"\"\"\n    Rescales bounding boxes (in the format of xyxy by default) from the shape of the image they were originally\n    specified in (img1_shape) to the shape of a different image (img0_shape).\n    Args:\n        img1_shape (tuple): The shape of the image that the bounding boxes are for, in the format of (height, width).\n        boxes (torch.Tensor): the bounding boxes of the objects in the image, in the format of (x1, y1, x2, y2)\n        img0_shape (tuple): the shape of the target image, in the format of (height, width).\n        ratio_pad (tuple): a tuple of (ratio, pad) for scaling the boxes. If not provided, the ratio and pad will be\n            calculated based on the size difference between the two images.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def make_divisible(x, divisor):\n    \"\"\"\n    Returns the nearest number that is divisible by the given divisor.\n    Args:\n        x (int): The number to make divisible.\n        divisor (int | torch.Tensor): The divisor.\n    Returns:\n        (int): The nearest number divisible by the divisor.\n    \"\"\"\n    if isinstance(divisor, torch.Tensor):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "nms_rotated",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def nms_rotated(boxes, scores, threshold=0.45):\n    \"\"\"\n    NMS for obbs, powered by probiou and fast-nms.\n    Args:\n        boxes (torch.Tensor): (N, 5), xywhr.\n        scores (torch.Tensor): (N, ).\n        threshold (float): IoU threshold.\n    Returns:\n    \"\"\"\n    if len(boxes) == 0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "non_max_suppression",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def non_max_suppression(\n    prediction,\n    conf_thres=0.25,\n    iou_thres=0.45,\n    classes=None,\n    agnostic=False,\n    multi_label=False,\n    labels=(),\n    max_det=300,\n    nc=0,  # number of classes (optional)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clip_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def clip_boxes(boxes, shape):\n    \"\"\"\n    Takes a list of bounding boxes and a shape (height, width) and clips the bounding boxes to the shape.\n    Args:\n        boxes (torch.Tensor): the bounding boxes to clip\n        shape (tuple): the shape of the image\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped boxes\n    \"\"\"\n    if isinstance(boxes, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clip_coords",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def clip_coords(coords, shape):\n    \"\"\"\n    Clip line coordinates to the image boundaries.\n    Args:\n        coords (torch.Tensor | numpy.ndarray): A list of line coordinates.\n        shape (tuple): A tuple of integers representing the size of the image in the format (height, width).\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped coordinates\n    \"\"\"\n    if isinstance(coords, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_image",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def scale_image(masks, im0_shape, ratio_pad=None):\n    \"\"\"\n    Takes a mask, and resizes it to the original image size.\n    Args:\n        masks (np.ndarray): resized and padded masks/images, [h, w, num]/[h, w, 3].\n        im0_shape (tuple): the original image shape\n        ratio_pad (tuple): the ratio of the padding to the original image.\n    Returns:\n        masks (torch.Tensor): The masks that are being returned.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2xywh(x):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xywh2xyxy(x):\n    \"\"\"\n    Convert bounding box coordinates from (x, y, width, height) format to (x1, y1, x2, y2) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x, y, width, height) format.\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x1, y1, x2, y2) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywhn2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):\n    \"\"\"\n    Convert normalized bounding box coordinates to pixel coordinates.\n    Args:\n        x (np.ndarray | torch.Tensor): The bounding box coordinates.\n        w (int): Width of the image. Defaults to 640\n        h (int): Height of the image. Defaults to 640\n        padw (int): Padding width. Defaults to 0\n        padh (int): Padding height. Defaults to 0\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywhn",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height, normalized) format. x, y,\n    width and height are normalized to image dimensions.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n        w (int): The width of the image. Defaults to 640\n        h (int): The height of the image. Defaults to 640\n        clip (bool): If True, the boxes will be clipped to the image boundaries. Defaults to False\n        eps (float): The minimum value of the box's width and height. Defaults to 0.0",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2ltwh",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xywh2ltwh(x):\n    \"\"\"\n    Convert the bounding box format from [x, y, w, h] to [x1, y1, w, h], where x1, y1 are the top-left coordinates.\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding box coordinates in the xywh format\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] - x[..., 2] / 2  # top left x",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2ltwh",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2ltwh(x):\n    \"\"\"\n    Convert nx4 bounding boxes from [x1, y1, x2, y2] to [x1, y1, w, h], where xy1=top-left, xy2=bottom-right.\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding boxes coordinates in the xyxy format\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] - x[..., 0]  # width",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "ltwh2xywh",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def ltwh2xywh(x):\n    \"\"\"\n    Convert nx4 boxes from [x1, y1, w, h] to [x, y, w, h] where xy1=top-left, xy=center.\n    Args:\n        x (torch.Tensor): the input tensor\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xywh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] + x[..., 2] / 2  # center x",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxyxyxy2xywhr",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xyxyxyxy2xywhr(corners):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation]. Rotation values are\n    expected in degrees from 0 to 90.\n    Args:\n        corners (numpy.ndarray | torch.Tensor): Input corners of shape (n, 8).\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted data in [cx, cy, w, h, rotation] format of shape (n, 5).\n    \"\"\"\n    is_torch = isinstance(corners, torch.Tensor)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywhr2xyxyxyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def xywhr2xyxyxyxy(rboxes):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4]. Rotation values should\n    be in degrees from 0 to 90.\n    Args:\n        rboxes (numpy.ndarray | torch.Tensor): Boxes in [cx, cy, w, h, rotation] format of shape (n, 5) or (b, n, 5).\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted corner points of shape (n, 4, 2) or (b, n, 4, 2).\n    \"\"\"\n    is_numpy = isinstance(rboxes, np.ndarray)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "ltwh2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def ltwh2xyxy(x):\n    \"\"\"\n    It converts the bounding box from [x1, y1, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.\n    Args:\n        x (np.ndarray | torch.Tensor): the input image\n    Returns:\n        y (np.ndarray | torch.Tensor): the xyxy coordinates of the bounding boxes.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] + x[..., 0]  # width",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segments2boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def segments2boxes(segments):\n    \"\"\"\n    It converts segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)\n    Args:\n        segments (list): list of segments, each segment is a list of points, each point is a list of x, y coordinates\n    Returns:\n        (np.ndarray): the xywh coordinates of the bounding boxes.\n    \"\"\"\n    boxes = []\n    for s in segments:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "resample_segments",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def resample_segments(segments, n=1000):\n    \"\"\"\n    Inputs a list of segments (n,2) and returns a list of segments (n,2) up-sampled to n points each.\n    Args:\n        segments (list): a list of (n,2) arrays, where n is the number of points in the segment.\n        n (int): number of points to resample the segment to. Defaults to 1000\n    Returns:\n        segments (list): the resampled segments.\n    \"\"\"\n    for i, s in enumerate(segments):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "crop_mask",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def crop_mask(masks, boxes):\n    \"\"\"\n    It takes a mask and a bounding box, and returns a mask that is cropped to the bounding box.\n    Args:\n        masks (torch.Tensor): [n, h, w] tensor of masks\n        boxes (torch.Tensor): [n, 4] tensor of bbox coordinates in relative point form\n    Returns:\n        (torch.Tensor): The masks are being cropped to the bounding box.\n    \"\"\"\n    _, h, w = masks.shape",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask_upsample",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def process_mask_upsample(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Takes the output of the mask head, and applies the mask to the bounding boxes. This produces masks of higher quality\n    but is slower.\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def process_mask(protos, masks_in, bboxes, shape, upsample=False):\n    \"\"\"\n    Apply masks to bounding boxes using the output of the mask head.\n    Args:\n        protos (torch.Tensor): A tensor of shape [mask_dim, mask_h, mask_w].\n        masks_in (torch.Tensor): A tensor of shape [n, mask_dim], where n is the number of masks after NMS.\n        bboxes (torch.Tensor): A tensor of shape [n, 4], where n is the number of masks after NMS.\n        shape (tuple): A tuple of integers representing the size of the input image in the format (h, w).\n        upsample (bool): A flag to indicate whether to upsample the mask to the original image size. Default is False.\n    Returns:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask_native",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def process_mask_native(protos, masks_in, bboxes, shape):\n    \"\"\"\n    It takes the output of the mask head, and crops it after upsampling to the bounding boxes.\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n    Returns:\n        masks (torch.Tensor): The returned masks with dimensions [h, w, n]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_masks",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def scale_masks(masks, shape, padding=True):\n    \"\"\"\n    Rescale segment masks to shape.\n    Args:\n        masks (torch.Tensor): (N, C, H, W).\n        shape (tuple): Height and width.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular\n            rescaling.\n    \"\"\"\n    mh, mw = masks.shape[2:]",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_coords",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None, normalize=False, padding=True):\n    \"\"\"\n    Rescale segment coordinates (xy) from img1_shape to img0_shape.\n    Args:\n        img1_shape (tuple): The shape of the image that the coords are from.\n        coords (torch.Tensor): the coords to be scaled of shape n,2.\n        img0_shape (tuple): the shape of the image that the segmentation is being applied to.\n        ratio_pad (tuple): the ratio of the image size to the padded image size.\n        normalize (bool): If True, the coordinates will be normalized to the range [0, 1]. Defaults to False.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "regularize_rboxes",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def regularize_rboxes(rboxes):\n    \"\"\"\n    Regularize rotated boxes in range [0, pi/2].\n    Args:\n        rboxes (torch.Tensor): (N, 5), xywhr.\n    Returns:\n        (torch.Tensor): The regularized boxes.\n    \"\"\"\n    x, y, w, h, t = rboxes.unbind(dim=-1)\n    # Swap edge and angle if h >= w",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "masks2segments",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def masks2segments(masks, strategy=\"largest\"):\n    \"\"\"\n    It takes a list of masks(n,h,w) and returns a list of segments(n,xy)\n    Args:\n        masks (torch.Tensor): the output of the model, which is a tensor of shape (batch_size, 160, 160)\n        strategy (str): 'concat' or 'largest'. Defaults to largest\n    Returns:\n        segments (List): list of segment masks\n    \"\"\"\n    segments = []",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "convert_torch2numpy_batch",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def convert_torch2numpy_batch(batch: torch.Tensor) -> np.ndarray:\n    \"\"\"\n    Convert a batch of FP32 torch tensors (0.0-1.0) to a NumPy uint8 array (0-255), changing from BCHW to BHWC layout.\n    Args:\n        batch (torch.Tensor): Input tensor batch of shape (Batch, Channels, Height, Width) and dtype torch.float32.\n    Returns:\n        (np.ndarray): Output NumPy array batch of shape (Batch, Height, Width, Channels) and dtype uint8.\n    \"\"\"\n    return (batch.permute(0, 2, 3, 1).contiguous() * 255).clamp(0, 255).to(torch.uint8).cpu().numpy()\ndef clean_str(s):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clean_str",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def clean_str(s):\n    \"\"\"\n    Cleans a string by replacing special characters with underscore _\n    Args:\n        s (str): a string needing special characters replaced\n    Returns:\n        (str): a string with special characters replaced by an underscore _\n    \"\"\"\n    return re.sub(pattern=\"[|@#!$%&()=?^*;:,><+]\", repl=\"_\", string=s)\ndef v10postprocess(preds, max_det, nc=80):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "v10postprocess",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "peekOfCode": "def v10postprocess(preds, max_det, nc=80):\n    assert(4 + nc == preds.shape[-1])\n    boxes, scores = preds.split([4, nc], dim=-1)\n    max_scores = scores.amax(dim=-1)\n    max_scores, index = torch.topk(max_scores, max_det, dim=-1)\n    index = index.unsqueeze(-1)\n    boxes = torch.gather(boxes, dim=1, index=index.repeat(1, 1, boxes.shape[-1]))\n    scores = torch.gather(scores, dim=1, index=index.repeat(1, 1, scores.shape[-1]))\n    scores, index = torch.topk(scores.flatten(1), max_det, dim=-1)\n    labels = index % nc",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "imread",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "def imread(filename: str, flags: int = cv2.IMREAD_COLOR):\n    \"\"\"\n    Read an image from a file.\n    Args:\n        filename (str): Path to the file to read.\n        flags (int, optional): Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.\n    Returns:\n        (np.ndarray): The read image.\n    \"\"\"\n    return cv2.imdecode(np.fromfile(filename, np.uint8), flags)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "def imwrite(filename: str, img: np.ndarray, params=None):\n    \"\"\"\n    Write an image to a file.\n    Args:\n        filename (str): Path to the file to write.\n        img (np.ndarray): Image to write.\n        params (list of ints, optional): Additional parameters. See OpenCV documentation.\n    Returns:\n        (bool): True if the file was written, False otherwise.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "imshow",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "def imshow(winname: str, mat: np.ndarray):\n    \"\"\"\n    Displays an image in the specified window.\n    Args:\n        winname (str): Name of the window.\n        mat (np.ndarray): Image to be shown.\n    \"\"\"\n    _imshow(winname.encode(\"unicode_escape\").decode(), mat)\n# PyTorch functions ----------------------------------------------------------------------------------------------------\n_torch_save = torch.save  # copy to avoid recursion errors",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "torch_save",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "def torch_save(*args, use_dill=True, **kwargs):\n    \"\"\"\n    Optionally use dill to serialize lambda functions where pickle does not, adding robustness with 3 retries and\n    exponential standoff in case of save failure.\n    Args:\n        *args (tuple): Positional arguments to pass to torch.save.\n        use_dill (bool): Whether to try using dill for serialization if available. Defaults to True.\n        **kwargs (any): Keyword arguments to pass to torch.save.\n    \"\"\"\n    try:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "_imshow",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "_imshow = cv2.imshow  # copy to avoid recursion errors\ndef imread(filename: str, flags: int = cv2.IMREAD_COLOR):\n    \"\"\"\n    Read an image from a file.\n    Args:\n        filename (str): Path to the file to read.\n        flags (int, optional): Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.\n    Returns:\n        (np.ndarray): The read image.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "_torch_save",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "peekOfCode": "_torch_save = torch.save  # copy to avoid recursion errors\ndef torch_save(*args, use_dill=True, **kwargs):\n    \"\"\"\n    Optionally use dill to serialize lambda functions where pickle does not, adding robustness with 3 retries and\n    exponential standoff in case of save failure.\n    Args:\n        *args (tuple): Positional arguments to pass to torch.save.\n        use_dill (bool): Whether to try using dill for serialization if available. Defaults to True.\n        **kwargs (any): Keyword arguments to pass to torch.save.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "Colors",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "class Colors:\n    \"\"\"\n    Ultralytics default color palette https://ultralytics.com/.\n    This class provides methods to work with the Ultralytics color palette, including converting hex color codes to\n    RGB values.\n    Attributes:\n        palette (list of tuple): List of RGB color values.\n        n (int): The number of colors in the palette.\n        pose_palette (np.ndarray): A specific color palette array with dtype np.uint8.\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "class Annotator:\n    \"\"\"\n    Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.\n    Attributes:\n        im (Image.Image or numpy array): The image to annotate.\n        pil (bool): Whether to use PIL or cv2 for drawing annotations.\n        font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.\n        lw (float): Line width for drawing.\n        skeleton (List[List[int]]): Skeleton structure for keypoints.\n        limb_color (List[int]): Color palette for limbs.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_labels",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def plot_labels(boxes, cls, names=(), save_dir=Path(\"\"), on_plot=None):\n    \"\"\"Plot training labels including class histograms and box statistics.\"\"\"\n    import pandas as pd\n    import seaborn as sn\n    # Filter matplotlib>=3.7.2 warning and Seaborn use_inf and is_categorical FutureWarnings\n    warnings.filterwarnings(\"ignore\", category=UserWarning, message=\"The figure layout has changed to tight\")\n    warnings.filterwarnings(\"ignore\", category=FutureWarning)\n    # Plot dataset labels\n    LOGGER.info(f\"Plotting labels to {save_dir / 'labels.jpg'}... \")\n    nc = int(cls.max() + 1)  # number of classes",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "save_one_box",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def save_one_box(xyxy, im, file=Path(\"im.jpg\"), gain=1.02, pad=10, square=False, BGR=False, save=True):\n    \"\"\"\n    Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop.\n    This function takes a bounding box and an image, and then saves a cropped portion of the image according\n    to the bounding box. Optionally, the crop can be squared, and the function allows for gain and padding\n    adjustments to the bounding box.\n    Args:\n        xyxy (torch.Tensor or list): A tensor or list representing the bounding box in xyxy format.\n        im (numpy.ndarray): The input image.\n        file (Path, optional): The path where the cropped image will be saved. Defaults to 'im.jpg'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def plot_images(\n    images,\n    batch_idx,\n    cls,\n    bboxes=np.zeros(0, dtype=np.float32),\n    confs=None,\n    masks=np.zeros(0, dtype=np.uint8),\n    kpts=np.zeros((0, 51), dtype=np.float32),\n    paths=None,\n    fname=\"images.jpg\",",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def plot_results(file=\"path/to/results.csv\", dir=\"\", segment=False, pose=False, classify=False, on_plot=None):\n    \"\"\"\n    Plot training results from a results CSV file. The function supports various types of data including segmentation,\n    pose estimation, and classification. Plots are saved as 'results.png' in the directory where the CSV is located.\n    Args:\n        file (str, optional): Path to the CSV file containing the training results. Defaults to 'path/to/results.csv'.\n        dir (str, optional): Directory where the CSV file is located if 'file' is not provided. Defaults to ''.\n        segment (bool, optional): Flag to indicate if the data is for segmentation. Defaults to False.\n        pose (bool, optional): Flag to indicate if the data is for pose estimation. Defaults to False.\n        classify (bool, optional): Flag to indicate if the data is for classification. Defaults to False.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plt_color_scatter",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def plt_color_scatter(v, f, bins=20, cmap=\"viridis\", alpha=0.8, edgecolors=\"none\"):\n    \"\"\"\n    Plots a scatter plot with points colored based on a 2D histogram.\n    Args:\n        v (array-like): Values for the x-axis.\n        f (array-like): Values for the y-axis.\n        bins (int, optional): Number of bins for the histogram. Defaults to 20.\n        cmap (str, optional): Colormap for the scatter plot. Defaults to 'viridis'.\n        alpha (float, optional): Alpha for the scatter plot. Defaults to 0.8.\n        edgecolors (str, optional): Edge colors for the scatter plot. Defaults to 'none'.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_tune_results",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def plot_tune_results(csv_file=\"tune_results.csv\"):\n    \"\"\"\n    Plot the evolution results stored in an 'tune_results.csv' file. The function generates a scatter plot for each key\n    in the CSV, color-coded based on fitness scores. The best-performing configurations are highlighted on the plots.\n    Args:\n        csv_file (str, optional): Path to the CSV file containing the tuning results. Defaults to 'tune_results.csv'.\n    Examples:\n        >>> plot_tune_results('path/to/tune_results.csv')\n    \"\"\"\n    import pandas as pd",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def output_to_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, ops.xyxy2xywh(box), conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\ndef output_to_rotated_target(output, max_det=300):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_rotated_target",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def output_to_rotated_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls, angle = o[:max_det].cpu().split((4, 1, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, box, angle, conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\ndef feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "feature_visualization",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "def feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):\n    \"\"\"\n    Visualize feature maps of a given model module during inference.\n    Args:\n        x (torch.Tensor): Features to be visualized.\n        module_type (str): Module type.\n        stage (int): Module stage within the model.\n        n (int, optional): Maximum number of feature maps to plot. Defaults to 32.\n        save_dir (Path, optional): Directory to save results. Defaults to Path('runs/detect/exp').\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "peekOfCode": "colors = Colors()  # create instance for 'from utils.plots import colors'\nclass Annotator:\n    \"\"\"\n    Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.\n    Attributes:\n        im (Image.Image or numpy array): The image to annotate.\n        pil (bool): Whether to use PIL or cv2 for drawing annotations.\n        font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.\n        lw (float): Line width for drawing.\n        skeleton (List[List[int]]): Skeleton structure for keypoints.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "TaskAlignedAssigner",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "class TaskAlignedAssigner(nn.Module):\n    \"\"\"\n    A task-aligned assigner for object detection.\n    This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both\n    classification and localization information.\n    Attributes:\n        topk (int): The number of top candidates to consider.\n        num_classes (int): The number of object classes.\n        alpha (float): The alpha parameter for the classification component of the task-aligned metric.\n        beta (float): The beta parameter for the localization component of the task-aligned metric.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "RotatedTaskAlignedAssigner",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "class RotatedTaskAlignedAssigner(TaskAlignedAssigner):\n    def iou_calculation(self, gt_bboxes, pd_bboxes):\n        \"\"\"IoU calculation for rotated bounding boxes.\"\"\"\n        return probiou(gt_bboxes, pd_bboxes).squeeze(-1).clamp_(0)\n    @staticmethod\n    def select_candidates_in_gts(xy_centers, gt_bboxes):\n        \"\"\"\n        Select the positive anchor center in gt for rotated bounding boxes.\n        Args:\n            xy_centers (Tensor): shape(h*w, 2)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "def make_anchors(feats, strides, grid_cell_offset=0.5):\n    \"\"\"Generate anchors from features.\"\"\"\n    anchor_points, stride_tensor = [], []\n    assert feats is not None\n    dtype, device = feats[0].dtype, feats[0].device\n    for i, stride in enumerate(strides):\n        _, _, h, w = feats[i].shape\n        sx = torch.arange(end=w, device=device, dtype=dtype) + grid_cell_offset  # shift x\n        sy = torch.arange(end=h, device=device, dtype=dtype) + grid_cell_offset  # shift y\n        sy, sx = torch.meshgrid(sy, sx, indexing=\"ij\") if TORCH_1_10 else torch.meshgrid(sy, sx)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "def dist2bbox(distance, anchor_points, xywh=True, dim=-1):\n    \"\"\"Transform distance(ltrb) to box(xywh or xyxy).\"\"\"\n    assert(distance.shape[dim] == 4)\n    lt, rb = distance.split([2, 2], dim)\n    x1y1 = anchor_points - lt\n    x2y2 = anchor_points + rb\n    if xywh:\n        c_xy = (x1y1 + x2y2) / 2\n        wh = x2y2 - x1y1\n        return torch.cat((c_xy, wh), dim)  # xywh bbox",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "bbox2dist",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "def bbox2dist(anchor_points, bbox, reg_max):\n    \"\"\"Transform bbox(xyxy) to dist(ltrb).\"\"\"\n    x1y1, x2y2 = bbox.chunk(2, -1)\n    return torch.cat((anchor_points - x1y1, x2y2 - anchor_points), -1).clamp_(0, reg_max - 0.01)  # dist (lt, rb)\ndef dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n    Args:\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "def dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n    Args:\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).\n        anchor_points (torch.Tensor): Anchor points, (h*w, 2).\n    Returns:\n        (torch.Tensor): Predicted rotated bounding boxes, (bs, h*w, 4).\n    \"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "TORCH_1_10",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "peekOfCode": "TORCH_1_10 = check_version(torch.__version__, \"1.10.0\")\nclass TaskAlignedAssigner(nn.Module):\n    \"\"\"\n    A task-aligned assigner for object detection.\n    This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both\n    classification and localization information.\n    Attributes:\n        topk (int): The number of top candidates to consider.\n        num_classes (int): The number of object classes.\n        alpha (float): The alpha parameter for the classification component of the task-aligned metric.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "ModelEMA",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "class ModelEMA:\n    \"\"\"Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models\n    Keeps a moving average of everything in the model state_dict (parameters and buffers)\n    For EMA details see https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage\n    To disable EMA set the `enabled` attribute to `False`.\n    \"\"\"\n    def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n        \"\"\"Create EMA.\"\"\"\n        self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n        self.updates = updates  # number of EMA updates",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "EarlyStopping",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "class EarlyStopping:\n    \"\"\"Early stopping class that stops training when a specified number of epochs have passed without improvement.\"\"\"\n    def __init__(self, patience=50):\n        \"\"\"\n        Initialize early stopping object.\n        Args:\n            patience (int, optional): Number of epochs to wait after fitness stops improving before stopping.\n        \"\"\"\n        self.best_fitness = 0.0  # i.e. mAP\n        self.best_epoch = 0",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:\n        dist.barrier(device_ids=[0])\ndef smart_inference_mode():\n    \"\"\"Applies torch.inference_mode() decorator if torch>=1.9.0 else torch.no_grad() decorator.\"\"\"",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def smart_inference_mode():\n    \"\"\"Applies torch.inference_mode() decorator if torch>=1.9.0 else torch.no_grad() decorator.\"\"\"\n    def decorate(fn):\n        \"\"\"Applies appropriate torch decorator for inference mode based on torch version.\"\"\"\n        if TORCH_1_9 and torch.is_inference_mode_enabled():\n            return fn  # already in inference_mode, act as a pass-through\n        else:\n            return (torch.inference_mode if TORCH_1_9 else torch.no_grad)()(fn)\n    return decorate\ndef get_cpu_info():",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_cpu_info",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_cpu_info():\n    \"\"\"Return a string with system CPU information, i.e. 'Apple M2'.\"\"\"\n    import cpuinfo  # pip install py-cpuinfo\n    k = \"brand_raw\", \"hardware_raw\", \"arch_string_raw\"  # info keys sorted by preference (not all keys always available)\n    info = cpuinfo.get_cpu_info()  # info dict\n    string = info.get(k[0] if k[0] in info else k[1] if k[1] in info else k[2], \"unknown\")\n    return string.replace(\"(R)\", \"\").replace(\"CPU \", \"\").replace(\"@ \", \"\")\ndef select_device(device=\"\", batch=0, newline=False, verbose=True):\n    \"\"\"\n    Selects the appropriate PyTorch device based on the provided arguments.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def select_device(device=\"\", batch=0, newline=False, verbose=True):\n    \"\"\"\n    Selects the appropriate PyTorch device based on the provided arguments.\n    The function takes a string specifying the device or a torch.device object and returns a torch.device object\n    representing the selected device. The function also validates the number of available devices and raises an\n    exception if the requested device(s) are not available.\n    Args:\n        device (str | torch.device, optional): Device string or torch.device object.\n            Options are 'None', 'cpu', or 'cuda', or '0' or '0,1,2,3'. Defaults to an empty string, which auto-selects\n            the first available GPU, or CPU if no GPU is available.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "time_sync",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def time_sync():\n    \"\"\"PyTorch-accurate time.\"\"\"\n    if torch.cuda.is_available():\n        torch.cuda.synchronize()\n    return time.time()\ndef fuse_conv_and_bn(conv, bn):\n    \"\"\"Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def fuse_conv_and_bn(conv, bn):\n    \"\"\"Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,\n            conv.out_channels,\n            kernel_size=conv.kernel_size,\n            stride=conv.stride,\n            padding=conv.padding,\n            dilation=conv.dilation,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_deconv_and_bn",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def fuse_deconv_and_bn(deconv, bn):\n    \"\"\"Fuse ConvTranspose2d() and BatchNorm2d() layers.\"\"\"\n    fuseddconv = (\n        nn.ConvTranspose2d(\n            deconv.in_channels,\n            deconv.out_channels,\n            kernel_size=deconv.kernel_size,\n            stride=deconv.stride,\n            padding=deconv.padding,\n            output_padding=deconv.output_padding,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def model_info(model, detailed=False, verbose=True, imgsz=640):\n    \"\"\"\n    Model information.\n    imgsz may be int or list, i.e. imgsz=640 or imgsz=[640, 320].\n    \"\"\"\n    if not verbose:\n        return\n    n_p = get_num_params(model)  # number of parameters\n    n_g = get_num_gradients(model)  # number of gradients\n    n_l = len(list(model.modules()))  # number of layers",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_num_params",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_num_params(model):\n    \"\"\"Return the total number of parameters in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters())\ndef get_num_gradients(model):\n    \"\"\"Return the total number of parameters with gradients in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters() if x.requires_grad)\ndef model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_num_gradients",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_num_gradients(model):\n    \"\"\"Return the total number of parameters with gradients in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters() if x.requires_grad)\ndef model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:\n        YOLOv8n info for loggers\n        ```python\n        results = {'model/parameters': 3151904,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info_for_loggers",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:\n        YOLOv8n info for loggers\n        ```python\n        results = {'model/parameters': 3151904,\n                   'model/GFLOPs': 8.746,\n                   'model/speed_ONNX(ms)': 41.244,\n                   'model/speed_TensorRT(ms)': 3.211,",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_flops",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_flops(model, imgsz=640):\n    \"\"\"Return a YOLO model's FLOPs.\"\"\"\n    if not thop:\n        return 0.0  # if not installed return 0.0 GFLOPs\n    try:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        if not isinstance(imgsz, list):\n            imgsz = [imgsz, imgsz]  # expand if int/float\n        try:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_flops_with_torch_profiler",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_flops_with_torch_profiler(model, imgsz=640):\n    \"\"\"Compute model FLOPs (thop alternative).\"\"\"\n    if TORCH_2_0:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        stride = (max(int(model.stride.max()), 32) if hasattr(model, \"stride\") else 32) * 2  # max stride\n        im = torch.zeros((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n        with torch.profiler.profile(with_flops=True) as prof:\n            model(im)\n        flops = sum(x.flops for x in prof.key_averages()) / 1e9",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "initialize_weights",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def initialize_weights(model):\n    \"\"\"Initialize model weights to random values.\"\"\"\n    for m in model.modules():\n        t = type(m)\n        if t is nn.Conv2d:\n            pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n        elif t is nn.BatchNorm2d:\n            m.eps = 1e-3\n            m.momentum = 0.03\n        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "scale_img",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def scale_img(img, ratio=1.0, same_shape=False, gs=32):\n    \"\"\"Scales and pads an image tensor of shape img(bs,3,y,x) based on given ratio and grid size gs, optionally\n    retaining the original shape.\n    \"\"\"\n    if ratio == 1.0:\n        return img\n    h, w = img.shape[2:]\n    s = (int(h * ratio), int(w * ratio))  # new size\n    img = F.interpolate(img, size=s, mode=\"bilinear\", align_corners=False)  # resize\n    if not same_shape:  # pad/crop img",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def make_divisible(x, divisor):\n    \"\"\"Returns nearest x divisible by divisor.\"\"\"\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor\ndef copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "copy_attr",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue\n        else:\n            setattr(a, k, v)\ndef get_latest_opset():\n    \"\"\"Return second-most (for maturity) recently supported ONNX opset by this version of torch.\"\"\"\n    return max(int(k[14:]) for k in vars(torch.onnx) if \"symbolic_opset\" in k) - 1  # opset",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_opset",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_latest_opset():\n    \"\"\"Return second-most (for maturity) recently supported ONNX opset by this version of torch.\"\"\"\n    return max(int(k[14:]) for k in vars(torch.onnx) if \"symbolic_opset\" in k) - 1  # opset\ndef intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.\"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\ndef is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "intersect_dicts",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.\"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\ndef is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "is_parallel",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "one_cycle",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_seeds",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe\n    # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287\n    if deterministic:\n        if TORCH_2_0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def strip_optimizer(f: Union[str, Path] = \"best.pt\", s: str = \"\") -> None:\n    \"\"\"\n    Strip optimizer from 'f' to finalize training, optionally save as 's'.\n    Args:\n        f (str): file path to model to strip the optimizer from. Default is 'best.pt'.\n        s (str): file path to save the model with stripped optimizer to. If not provided, 'f' will be overwritten.\n    Returns:\n        None\n    Example:\n        ```python",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "profile",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "def profile(input, ops, n=10, device=None):\n    \"\"\"\n    Ultralytics speed, memory and FLOPs profiler.\n    Example:\n        ```python\n        from ultralytics.utils.torch_utils import profile\n        input = torch.randn(16, 3, 640, 640)\n        m1 = lambda x: x * torch.sigmoid(x)\n        m2 = nn.SiLU()\n        profile(input, [m1, m2], n=100)  # profile over 100 iterations",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_9",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_1_9 = check_version(torch.__version__, \"1.9.0\")\nTORCH_1_13 = check_version(torch.__version__, \"1.13.0\")\nTORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_13",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_1_13 = check_version(torch.__version__, \"1.13.0\")\nTORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_2_0",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_10",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_11",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_13",
        "kind": 5,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:\n        dist.barrier(device_ids=[0])",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TritonRemoteModel",
        "kind": 6,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.triton",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.triton",
        "peekOfCode": "class TritonRemoteModel:\n    \"\"\"\n    Client for interacting with a remote Triton Inference Server model.\n    Attributes:\n        endpoint (str): The name of the model on the Triton server.\n        url (str): The URL of the Triton server.\n        triton_client: The Triton client (either HTTP or gRPC).\n        InferInput: The input class for the Triton client.\n        InferRequestedOutput: The output request class for the Triton client.\n        input_formats (List[str]): The data types of the model inputs.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.triton",
        "documentation": {}
    },
    {
        "label": "run_ray_tune",
        "kind": 2,
        "importPath": "Identification.yolov10.build.lib.ultralytics.utils.tuner",
        "description": "Identification.yolov10.build.lib.ultralytics.utils.tuner",
        "peekOfCode": "def run_ray_tune(\n    model, space: dict = None, grace_period: int = 10, gpu_per_trial: int = None, max_samples: int = 10, **train_args\n):\n    \"\"\"\n    Runs hyperparameter tuning using Ray Tune.\n    Args:\n        model (YOLO): Model to run the tuner on.\n        space (dict, optional): The hyperparameter search space. Defaults to None.\n        grace_period (int, optional): The grace period in epochs of the ASHA scheduler. Defaults to 10.\n        gpu_per_trial (int, optional): The number of GPUs to allocate per trial. Defaults to None.",
        "detail": "Identification.yolov10.build.lib.ultralytics.utils.tuner",
        "documentation": {}
    },
    {
        "label": "build_docs",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "def build_docs(clone_repos=True):\n    \"\"\"Build docs using mkdocs.\"\"\"\n    if SITE.exists():\n        print(f\"Removing existing {SITE}\")\n        shutil.rmtree(SITE)\n    # Get hub-sdk repo\n    if clone_repos:\n        repo = \"https://github.com/ultralytics/hub-sdk\"\n        local_dir = DOCS.parent / Path(repo).name\n        if not local_dir.exists():",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "update_page_title",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "def update_page_title(file_path: Path, new_title: str):\n    \"\"\"Update the title of an HTML file.\"\"\"\n    # Read the content of the file\n    with open(file_path, encoding=\"utf-8\") as file:\n        content = file.read()\n    # Replace the existing title with the new title\n    updated_content = re.sub(r\"<title>.*?</title>\", f\"<title>{new_title}</title>\", content)\n    # Write the updated content back to the file\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        file.write(updated_content)",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "update_html_head",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "def update_html_head(script=\"\"):\n    \"\"\"Update the HTML head section of each file.\"\"\"\n    html_files = Path(SITE).rglob(\"*.html\")\n    for html_file in tqdm(html_files, desc=\"Processing HTML files\"):\n        with html_file.open(\"r\", encoding=\"utf-8\") as file:\n            html_content = file.read()\n        if script in html_content:  # script already in HTML file\n            return\n        head_end_index = html_content.lower().rfind(\"</head>\")\n        if head_end_index != -1:",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "update_subdir_edit_links",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "def update_subdir_edit_links(subdir=\"\", docs_url=\"\"):\n    \"\"\"Update the HTML head section of each file.\"\"\"\n    from bs4 import BeautifulSoup\n    if str(subdir[0]) == \"/\":\n        subdir = str(subdir[0])[1:]\n    html_files = (SITE / subdir).rglob(\"*.html\")\n    for html_file in tqdm(html_files, desc=\"Processing subdir files\"):\n        with html_file.open(\"r\", encoding=\"utf-8\") as file:\n            soup = BeautifulSoup(file, \"html.parser\")\n        # Find the anchor tag and update its href attribute",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "def main():\n    \"\"\"Builds docs, updates titles and edit links, and prints local server command.\"\"\"\n    build_docs()\n    # Update titles\n    update_page_title(SITE / \"404.html\", new_title=\"Ultralytics Docs - Not Found\")\n    # Update edit links\n    update_subdir_edit_links(\n        subdir=\"hub/sdk/\",  # do not use leading slash\n        docs_url=\"https://github.com/ultralytics/hub-sdk/tree/develop/docs/\",\n    )",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "DOCS",
        "kind": 5,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "DOCS = Path(__file__).parent.resolve()\nSITE = DOCS.parent / \"site\"\ndef build_docs(clone_repos=True):\n    \"\"\"Build docs using mkdocs.\"\"\"\n    if SITE.exists():\n        print(f\"Removing existing {SITE}\")\n        shutil.rmtree(SITE)\n    # Get hub-sdk repo\n    if clone_repos:\n        repo = \"https://github.com/ultralytics/hub-sdk\"",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "SITE",
        "kind": 5,
        "importPath": "Identification.yolov10.docs.build_docs",
        "description": "Identification.yolov10.docs.build_docs",
        "peekOfCode": "SITE = DOCS.parent / \"site\"\ndef build_docs(clone_repos=True):\n    \"\"\"Build docs using mkdocs.\"\"\"\n    if SITE.exists():\n        print(f\"Removing existing {SITE}\")\n        shutil.rmtree(SITE)\n    # Get hub-sdk repo\n    if clone_repos:\n        repo = \"https://github.com/ultralytics/hub-sdk\"\n        local_dir = DOCS.parent / Path(repo).name",
        "detail": "Identification.yolov10.docs.build_docs",
        "documentation": {}
    },
    {
        "label": "extract_classes_and_functions",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def extract_classes_and_functions(filepath: Path) -> tuple:\n    \"\"\"Extracts class and function names from a given Python file.\"\"\"\n    content = filepath.read_text()\n    class_pattern = r\"(?:^|\\n)class\\s(\\w+)(?:\\(|:)\"\n    func_pattern = r\"(?:^|\\n)def\\s(\\w+)\\(\"\n    classes = re.findall(class_pattern, content)\n    functions = re.findall(func_pattern, content)\n    return classes, functions\ndef create_markdown(py_filepath: Path, module_path: str, classes: list, functions: list):\n    \"\"\"Creates a Markdown file containing the API reference for the given Python module.\"\"\"",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "create_markdown",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def create_markdown(py_filepath: Path, module_path: str, classes: list, functions: list):\n    \"\"\"Creates a Markdown file containing the API reference for the given Python module.\"\"\"\n    md_filepath = py_filepath.with_suffix(\".md\")\n    # Read existing content and keep header content between first two ---\n    header_content = \"\"\n    if md_filepath.exists():\n        existing_content = md_filepath.read_text()\n        header_parts = existing_content.split(\"---\")\n        for part in header_parts:\n            if \"description:\" in part or \"comments:\" in part:",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "nested_dict",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def nested_dict() -> defaultdict:\n    \"\"\"Creates and returns a nested defaultdict.\"\"\"\n    return defaultdict(nested_dict)\ndef sort_nested_dict(d: dict) -> dict:\n    \"\"\"Sorts a nested dictionary recursively.\"\"\"\n    return {key: sort_nested_dict(value) if isinstance(value, dict) else value for key, value in sorted(d.items())}\ndef create_nav_menu_yaml(nav_items: list, save: bool = False):\n    \"\"\"Creates a YAML file for the navigation menu based on the provided list of items.\"\"\"\n    nav_tree = nested_dict()\n    for item_str in nav_items:",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "sort_nested_dict",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def sort_nested_dict(d: dict) -> dict:\n    \"\"\"Sorts a nested dictionary recursively.\"\"\"\n    return {key: sort_nested_dict(value) if isinstance(value, dict) else value for key, value in sorted(d.items())}\ndef create_nav_menu_yaml(nav_items: list, save: bool = False):\n    \"\"\"Creates a YAML file for the navigation menu based on the provided list of items.\"\"\"\n    nav_tree = nested_dict()\n    for item_str in nav_items:\n        item = Path(item_str)\n        parts = item.parts\n        current_level = nav_tree[\"reference\"]",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "create_nav_menu_yaml",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def create_nav_menu_yaml(nav_items: list, save: bool = False):\n    \"\"\"Creates a YAML file for the navigation menu based on the provided list of items.\"\"\"\n    nav_tree = nested_dict()\n    for item_str in nav_items:\n        item = Path(item_str)\n        parts = item.parts\n        current_level = nav_tree[\"reference\"]\n        for part in parts[2:-1]:  # skip the first two parts (docs and reference) and the last part (filename)\n            current_level = current_level[part]\n        md_file_name = parts[-1].replace(\".md\", \"\")",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "def main():\n    \"\"\"Main function to extract class and function names, create Markdown files, and generate a YAML navigation menu.\"\"\"\n    nav_items = []\n    for py_filepath in PACKAGE_DIR.rglob(\"*.py\"):\n        classes, functions = extract_classes_and_functions(py_filepath)\n        if classes or functions:\n            py_filepath_rel = py_filepath.relative_to(PACKAGE_DIR)\n            md_filepath = REFERENCE_DIR / py_filepath_rel\n            module_path = f\"{PACKAGE_DIR.name}.{py_filepath_rel.with_suffix('').as_posix().replace('/', '.')}\"\n            md_rel_filepath = create_markdown(md_filepath, module_path, classes, functions)",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "REFERENCE_DIR",
        "kind": 5,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "REFERENCE_DIR = PACKAGE_DIR.parent / \"docs/en/reference\"\nGITHUB_REPO = \"ultralytics/ultralytics\"\ndef extract_classes_and_functions(filepath: Path) -> tuple:\n    \"\"\"Extracts class and function names from a given Python file.\"\"\"\n    content = filepath.read_text()\n    class_pattern = r\"(?:^|\\n)class\\s(\\w+)(?:\\(|:)\"\n    func_pattern = r\"(?:^|\\n)def\\s(\\w+)\\(\"\n    classes = re.findall(class_pattern, content)\n    functions = re.findall(func_pattern, content)\n    return classes, functions",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "GITHUB_REPO",
        "kind": 5,
        "importPath": "Identification.yolov10.docs.build_reference",
        "description": "Identification.yolov10.docs.build_reference",
        "peekOfCode": "GITHUB_REPO = \"ultralytics/ultralytics\"\ndef extract_classes_and_functions(filepath: Path) -> tuple:\n    \"\"\"Extracts class and function names from a given Python file.\"\"\"\n    content = filepath.read_text()\n    class_pattern = r\"(?:^|\\n)class\\s(\\w+)(?:\\(|:)\"\n    func_pattern = r\"(?:^|\\n)def\\s(\\w+)\\(\"\n    classes = re.findall(class_pattern, content)\n    functions = re.findall(func_pattern, content)\n    return classes, functions\ndef create_markdown(py_filepath: Path, module_path: str, classes: list, functions: list):",
        "detail": "Identification.yolov10.docs.build_reference",
        "documentation": {}
    },
    {
        "label": "YOLOv8",
        "kind": 6,
        "importPath": "Identification.yolov10.examples.YOLOv8-ONNXRuntime.main",
        "description": "Identification.yolov10.examples.YOLOv8-ONNXRuntime.main",
        "peekOfCode": "class YOLOv8:\n    \"\"\"YOLOv8 object detection model class for handling inference and visualization.\"\"\"\n    def __init__(self, onnx_model, input_image, confidence_thres, iou_thres):\n        \"\"\"\n        Initializes an instance of the YOLOv8 class.\n        Args:\n            onnx_model: Path to the ONNX model.\n            input_image: Path to the input image.\n            confidence_thres: Confidence threshold for filtering detections.\n            iou_thres: IoU (Intersection over Union) threshold for non-maximum suppression.",
        "detail": "Identification.yolov10.examples.YOLOv8-ONNXRuntime.main",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "kind": 6,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "peekOfCode": "class LetterBox:\n    def __init__(\n        self, new_shape=(img_width, img_height), auto=False, scaleFill=False, scaleup=True, center=True, stride=32\n    ):\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup\n        self.stride = stride\n        self.center = center  # Put the image in the middle or top-left",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "documentation": {}
    },
    {
        "label": "Yolov8TFLite",
        "kind": 6,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "peekOfCode": "class Yolov8TFLite:\n    def __init__(self, tflite_model, input_image, confidence_thres, iou_thres):\n        \"\"\"\n        Initializes an instance of the Yolov8TFLite class.\n        Args:\n            tflite_model: Path to the TFLite model.\n            input_image: Path to the input image.\n            confidence_thres: Confidence threshold for filtering detections.\n            iou_thres: IoU (Intersection over Union) threshold for non-maximum suppression.\n        \"\"\"",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "documentation": {}
    },
    {
        "label": "img_width",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "peekOfCode": "img_width = 640\nimg_height = 640\nclass LetterBox:\n    def __init__(\n        self, new_shape=(img_width, img_height), auto=False, scaleFill=False, scaleup=True, center=True, stride=32\n    ):\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "documentation": {}
    },
    {
        "label": "img_height",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "peekOfCode": "img_height = 640\nclass LetterBox:\n    def __init__(\n        self, new_shape=(img_width, img_height), auto=False, scaleFill=False, scaleup=True, center=True, stride=32\n    ):\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup\n        self.stride = stride",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-int8-tflite-Python.main",
        "documentation": {}
    },
    {
        "label": "draw_bounding_box",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "peekOfCode": "def draw_bounding_box(img, class_id, confidence, x, y, x_plus_w, y_plus_h):\n    \"\"\"\n    Draws bounding boxes on the input image based on the provided arguments.\n    Args:\n        img (numpy.ndarray): The input image to draw the bounding box on.\n        class_id (int): Class ID of the detected object.\n        confidence (float): Confidence score of the detected object.\n        x (int): X-coordinate of the top-left corner of the bounding box.\n        y (int): Y-coordinate of the top-left corner of the bounding box.\n        x_plus_w (int): X-coordinate of the bottom-right corner of the bounding box.",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "peekOfCode": "def main(onnx_model, input_image):\n    \"\"\"\n    Main function to load ONNX model, perform inference, draw bounding boxes, and display the output image.\n    Args:\n        onnx_model (str): Path to the ONNX model.\n        input_image (str): Path to the input image.\n    Returns:\n        list: List of dictionaries containing detection information such as class_id, class_name, confidence, etc.\n    \"\"\"\n    # Load the ONNX model",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "documentation": {}
    },
    {
        "label": "CLASSES",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "peekOfCode": "CLASSES = yaml_load(check_yaml(\"coco128.yaml\"))[\"names\"]\ncolors = np.random.uniform(0, 255, size=(len(CLASSES), 3))\ndef draw_bounding_box(img, class_id, confidence, x, y, x_plus_w, y_plus_h):\n    \"\"\"\n    Draws bounding boxes on the input image based on the provided arguments.\n    Args:\n        img (numpy.ndarray): The input image to draw the bounding box on.\n        class_id (int): Class ID of the detected object.\n        confidence (float): Confidence score of the detected object.\n        x (int): X-coordinate of the top-left corner of the bounding box.",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "peekOfCode": "colors = np.random.uniform(0, 255, size=(len(CLASSES), 3))\ndef draw_bounding_box(img, class_id, confidence, x, y, x_plus_w, y_plus_h):\n    \"\"\"\n    Draws bounding boxes on the input image based on the provided arguments.\n    Args:\n        img (numpy.ndarray): The input image to draw the bounding box on.\n        class_id (int): Class ID of the detected object.\n        confidence (float): Confidence score of the detected object.\n        x (int): X-coordinate of the top-left corner of the bounding box.\n        y (int): Y-coordinate of the top-left corner of the bounding box.",
        "detail": "Identification.yolov10.examples.YOLOv8-OpenCV-ONNX-Python.main",
        "documentation": {}
    },
    {
        "label": "mouse_callback",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "def mouse_callback(event, x, y, flags, param):\n    \"\"\"\n    Handles mouse events for region manipulation.\n    Parameters:\n        event (int): The mouse event type (e.g., cv2.EVENT_LBUTTONDOWN).\n        x (int): The x-coordinate of the mouse pointer.\n        y (int): The y-coordinate of the mouse pointer.\n        flags (int): Additional flags passed by OpenCV.\n        param: Additional parameters passed to the callback (not used in this function).\n    Global Variables:",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "def run(\n    weights=\"yolov8n.pt\",\n    source=None,\n    device=\"cpu\",\n    view_img=False,\n    save_img=False,\n    exist_ok=False,\n    classes=None,\n    line_thickness=2,\n    track_thickness=2,",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "parse_opt",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "def parse_opt():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=\"yolov8n.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--device\", default=\"\", help=\"cuda device, i.e. 0 or 0,1,2,3 or cpu\")\n    parser.add_argument(\"--source\", type=str, required=True, help=\"video file path\")\n    parser.add_argument(\"--view-img\", action=\"store_true\", help=\"show results\")\n    parser.add_argument(\"--save-img\", action=\"store_true\", help=\"save results\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    parser.add_argument(\"--classes\", nargs=\"+\", type=int, help=\"filter by class: --classes 0, or --classes 0 2 3\")",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "def main(opt):\n    \"\"\"Main function.\"\"\"\n    run(**vars(opt))\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "track_history",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "track_history = defaultdict(list)\ncurrent_region = None\ncounting_regions = [\n    {\n        \"name\": \"YOLOv8 Polygon Region\",\n        \"polygon\": Polygon([(50, 80), (250, 20), (450, 80), (400, 350), (100, 350)]),  # Polygon points\n        \"counts\": 0,\n        \"dragging\": False,\n        \"region_color\": (255, 42, 4),  # BGR Value\n        \"text_color\": (255, 255, 255),  # Region Text Color",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "current_region",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "current_region = None\ncounting_regions = [\n    {\n        \"name\": \"YOLOv8 Polygon Region\",\n        \"polygon\": Polygon([(50, 80), (250, 20), (450, 80), (400, 350), (100, 350)]),  # Polygon points\n        \"counts\": 0,\n        \"dragging\": False,\n        \"region_color\": (255, 42, 4),  # BGR Value\n        \"text_color\": (255, 255, 255),  # Region Text Color\n    },",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "counting_regions",
        "kind": 5,
        "importPath": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "description": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "peekOfCode": "counting_regions = [\n    {\n        \"name\": \"YOLOv8 Polygon Region\",\n        \"polygon\": Polygon([(50, 80), (250, 20), (450, 80), (400, 350), (100, 350)]),  # Polygon points\n        \"counts\": 0,\n        \"dragging\": False,\n        \"region_color\": (255, 42, 4),  # BGR Value\n        \"text_color\": (255, 255, 255),  # Region Text Color\n    },\n    {",
        "detail": "Identification.yolov10.examples.YOLOv8-Region-Counter.yolov8_region_counter",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "description": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "peekOfCode": "def run(weights=\"yolov8n.pt\", source=\"test.mp4\", view_img=False, save_img=False, exist_ok=False):\n    \"\"\"\n    Run object detection on a video using YOLOv8 and SAHI.\n    Args:\n        weights (str): Model weights path.\n        source (str): Video file path.\n        view_img (bool): Show results.\n        save_img (bool): Save results.\n        exist_ok (bool): Overwrite existing files.\n    \"\"\"",
        "detail": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "documentation": {}
    },
    {
        "label": "parse_opt",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "description": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "peekOfCode": "def parse_opt():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--weights\", type=str, default=\"yolov8n.pt\", help=\"initial weights path\")\n    parser.add_argument(\"--source\", type=str, required=True, help=\"video file path\")\n    parser.add_argument(\"--view-img\", action=\"store_true\", help=\"show results\")\n    parser.add_argument(\"--save-img\", action=\"store_true\", help=\"save results\")\n    parser.add_argument(\"--exist-ok\", action=\"store_true\", help=\"existing project/name ok, do not increment\")\n    return parser.parse_args()\ndef main(opt):",
        "detail": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "description": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "peekOfCode": "def main(opt):\n    \"\"\"Main function.\"\"\"\n    run(**vars(opt))\nif __name__ == \"__main__\":\n    opt = parse_opt()\n    main(opt)",
        "detail": "Identification.yolov10.examples.YOLOv8-SAHI-Inference-Video.yolov8_sahi",
        "documentation": {}
    },
    {
        "label": "YOLOv8Seg",
        "kind": 6,
        "importPath": "Identification.yolov10.examples.YOLOv8-Segmentation-ONNXRuntime-Python.main",
        "description": "Identification.yolov10.examples.YOLOv8-Segmentation-ONNXRuntime-Python.main",
        "peekOfCode": "class YOLOv8Seg:\n    \"\"\"YOLOv8 segmentation model.\"\"\"\n    def __init__(self, onnx_model):\n        \"\"\"\n        Initialization.\n        Args:\n            onnx_model (str): Path to the ONNX model.\n        \"\"\"\n        # Build Ort session\n        self.session = ort.InferenceSession(",
        "detail": "Identification.yolov10.examples.YOLOv8-Segmentation-ONNXRuntime-Python.main",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.conftest",
        "description": "Identification.yolov10.tests.conftest",
        "peekOfCode": "def pytest_addoption(parser):\n    \"\"\"\n    Add custom command-line options to pytest.\n    Args:\n        parser (pytest.config.Parser): The pytest parser object.\n    \"\"\"\n    parser.addoption(\"--slow\", action=\"store_true\", default=False, help=\"Run slow tests\")\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"\n    Modify the list of test items to remove tests marked as slow if the --slow option is not provided.",
        "detail": "Identification.yolov10.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_collection_modifyitems",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.conftest",
        "description": "Identification.yolov10.tests.conftest",
        "peekOfCode": "def pytest_collection_modifyitems(config, items):\n    \"\"\"\n    Modify the list of test items to remove tests marked as slow if the --slow option is not provided.\n    Args:\n        config (pytest.config.Config): The pytest config object.\n        items (list): List of test items to be executed.\n    \"\"\"\n    if not config.getoption(\"--slow\"):\n        # Remove the item entirely from the list of test items if it's marked as 'slow'\n        items[:] = [item for item in items if \"slow\" not in item.keywords]",
        "detail": "Identification.yolov10.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.conftest",
        "description": "Identification.yolov10.tests.conftest",
        "peekOfCode": "def pytest_sessionstart(session):\n    \"\"\"\n    Initialize session configurations for pytest.\n    This function is automatically called by pytest after the 'Session' object has been created but before performing\n    test collection. It sets the initial seeds and prepares the temporary directory for the test session.\n    Args:\n        session (pytest.Session): The pytest session object.\n    \"\"\"\n    from ultralytics.utils.torch_utils import init_seeds\n    init_seeds()",
        "detail": "Identification.yolov10.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_terminal_summary",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.conftest",
        "description": "Identification.yolov10.tests.conftest",
        "peekOfCode": "def pytest_terminal_summary(terminalreporter, exitstatus, config):\n    \"\"\"\n    Cleanup operations after pytest session.\n    This function is automatically called by pytest at the end of the entire test session. It removes certain files\n    and directories used during testing.\n    Args:\n        terminalreporter (pytest.terminal.TerminalReporter): The terminal reporter object.\n        exitstatus (int): The exit status of the test run.\n        config (pytest.config.Config): The pytest config object.\n    \"\"\"",
        "detail": "Identification.yolov10.tests.conftest",
        "documentation": {}
    },
    {
        "label": "TMP",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.conftest",
        "description": "Identification.yolov10.tests.conftest",
        "peekOfCode": "TMP = Path(__file__).resolve().parent / \"tmp\"  # temp directory for test files\ndef pytest_addoption(parser):\n    \"\"\"\n    Add custom command-line options to pytest.\n    Args:\n        parser (pytest.config.Parser): The pytest parser object.\n    \"\"\"\n    parser.addoption(\"--slow\", action=\"store_true\", default=False, help=\"Run slow tests\")\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"",
        "detail": "Identification.yolov10.tests.conftest",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def run(cmd):\n    \"\"\"Execute a shell command using subprocess.\"\"\"\n    subprocess.run(cmd.split(), check=True)\ndef test_special_modes():\n    \"\"\"Test various special command modes of YOLO.\"\"\"\n    run(\"yolo help\")\n    run(\"yolo checks\")\n    run(\"yolo version\")\n    run(\"yolo settings reset\")\n    run(\"yolo cfg\")",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_special_modes",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_special_modes():\n    \"\"\"Test various special command modes of YOLO.\"\"\"\n    run(\"yolo help\")\n    run(\"yolo checks\")\n    run(\"yolo version\")\n    run(\"yolo settings reset\")\n    run(\"yolo cfg\")\n@pytest.mark.parametrize(\"task,model,data\", TASK_ARGS)\ndef test_train(task, model, data):\n    \"\"\"Test YOLO training for a given task, model, and data.\"\"\"",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_train",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_train(task, model, data):\n    \"\"\"Test YOLO training for a given task, model, and data.\"\"\"\n    run(f\"yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 cache=disk\")\n@pytest.mark.parametrize(\"task,model,data\", TASK_ARGS)\ndef test_val(task, model, data):\n    \"\"\"Test YOLO validation for a given task, model, and data.\"\"\"\n    run(f\"yolo val {task} model={WEIGHTS_DIR / model}.pt data={data} imgsz=32 save_txt save_json\")\n@pytest.mark.parametrize(\"task,model,data\", TASK_ARGS)\ndef test_predict(task, model, data):\n    \"\"\"Test YOLO prediction on sample assets for a given task and model.\"\"\"",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_val",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_val(task, model, data):\n    \"\"\"Test YOLO validation for a given task, model, and data.\"\"\"\n    run(f\"yolo val {task} model={WEIGHTS_DIR / model}.pt data={data} imgsz=32 save_txt save_json\")\n@pytest.mark.parametrize(\"task,model,data\", TASK_ARGS)\ndef test_predict(task, model, data):\n    \"\"\"Test YOLO prediction on sample assets for a given task and model.\"\"\"\n    run(f\"yolo predict model={WEIGHTS_DIR / model}.pt source={ASSETS} imgsz=32 save save_crop save_txt\")\n@pytest.mark.parametrize(\"model,format\", EXPORT_ARGS)\ndef test_export(model, format):\n    \"\"\"Test exporting a YOLO model to different formats.\"\"\"",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_predict",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_predict(task, model, data):\n    \"\"\"Test YOLO prediction on sample assets for a given task and model.\"\"\"\n    run(f\"yolo predict model={WEIGHTS_DIR / model}.pt source={ASSETS} imgsz=32 save save_crop save_txt\")\n@pytest.mark.parametrize(\"model,format\", EXPORT_ARGS)\ndef test_export(model, format):\n    \"\"\"Test exporting a YOLO model to different formats.\"\"\"\n    run(f\"yolo export model={WEIGHTS_DIR / model}.pt format={format} imgsz=32\")\ndef test_rtdetr(task=\"detect\", model=\"yolov8n-rtdetr.yaml\", data=\"coco8.yaml\"):\n    \"\"\"Test the RTDETR functionality with the Ultralytics framework.\"\"\"\n    # Warning: MUST use imgsz=640",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_export",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_export(model, format):\n    \"\"\"Test exporting a YOLO model to different formats.\"\"\"\n    run(f\"yolo export model={WEIGHTS_DIR / model}.pt format={format} imgsz=32\")\ndef test_rtdetr(task=\"detect\", model=\"yolov8n-rtdetr.yaml\", data=\"coco8.yaml\"):\n    \"\"\"Test the RTDETR functionality with the Ultralytics framework.\"\"\"\n    # Warning: MUST use imgsz=640\n    run(f\"yolo train {task} model={model} data={data} --imgsz= 160 epochs =1, cache = disk\")  # add coma, spaces to args\n    run(f\"yolo predict {task} model={model} source={ASSETS / 'bus.jpg'} imgsz=160 save save_crop save_txt\")\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"MobileSAM with CLIP is not supported in Python 3.12\")\ndef test_fastsam(task=\"segment\", model=WEIGHTS_DIR / \"FastSAM-s.pt\", data=\"coco8-seg.yaml\"):",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_rtdetr",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_rtdetr(task=\"detect\", model=\"yolov8n-rtdetr.yaml\", data=\"coco8.yaml\"):\n    \"\"\"Test the RTDETR functionality with the Ultralytics framework.\"\"\"\n    # Warning: MUST use imgsz=640\n    run(f\"yolo train {task} model={model} data={data} --imgsz= 160 epochs =1, cache = disk\")  # add coma, spaces to args\n    run(f\"yolo predict {task} model={model} source={ASSETS / 'bus.jpg'} imgsz=160 save save_crop save_txt\")\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"MobileSAM with CLIP is not supported in Python 3.12\")\ndef test_fastsam(task=\"segment\", model=WEIGHTS_DIR / \"FastSAM-s.pt\", data=\"coco8-seg.yaml\"):\n    \"\"\"Test FastSAM segmentation functionality within Ultralytics.\"\"\"\n    source = ASSETS / \"bus.jpg\"\n    run(f\"yolo segment val {task} model={model} data={data} imgsz=32\")",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_fastsam",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_fastsam(task=\"segment\", model=WEIGHTS_DIR / \"FastSAM-s.pt\", data=\"coco8-seg.yaml\"):\n    \"\"\"Test FastSAM segmentation functionality within Ultralytics.\"\"\"\n    source = ASSETS / \"bus.jpg\"\n    run(f\"yolo segment val {task} model={model} data={data} imgsz=32\")\n    run(f\"yolo segment predict model={model} source={source} imgsz=32 save save_crop save_txt\")\n    from ultralytics import FastSAM\n    from ultralytics.models.fastsam import FastSAMPrompt\n    from ultralytics.models.sam import Predictor\n    # Create a FastSAM model\n    sam_model = FastSAM(model)  # or FastSAM-x.pt",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_mobilesam",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_mobilesam():\n    \"\"\"Test MobileSAM segmentation functionality using Ultralytics.\"\"\"\n    from ultralytics import SAM\n    # Load the model\n    model = SAM(WEIGHTS_DIR / \"mobile_sam.pt\")\n    # Source\n    source = ASSETS / \"zidane.jpg\"\n    # Predict a segment based on a point prompt\n    model.predict(source, points=[900, 370], labels=[1])\n    # Predict a segment based on a box prompt",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_train_gpu",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "def test_train_gpu(task, model, data):\n    \"\"\"Test YOLO training on GPU(s) for various tasks and models.\"\"\"\n    run(f\"yolo train {task} model={model}.yaml data={data} imgsz=32 epochs=1 device=0\")  # single GPU\n    run(f\"yolo train {task} model={model}.pt data={data} imgsz=32 epochs=1 device=0,1\")  # multi GPU",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "CUDA_IS_AVAILABLE",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "CUDA_IS_AVAILABLE = checks.cuda_is_available()\nCUDA_DEVICE_COUNT = checks.cuda_device_count()\nTASK_ARGS = [\n    (\"detect\", \"yolov8n\", \"coco8.yaml\"),\n    (\"segment\", \"yolov8n-seg\", \"coco8-seg.yaml\"),\n    (\"classify\", \"yolov8n-cls\", \"imagenet10\"),\n    (\"pose\", \"yolov8n-pose\", \"coco8-pose.yaml\"),\n    (\"obb\", \"yolov8n-obb\", \"dota8.yaml\"),\n]  # (task, model, data)\nEXPORT_ARGS = [",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "CUDA_DEVICE_COUNT",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "CUDA_DEVICE_COUNT = checks.cuda_device_count()\nTASK_ARGS = [\n    (\"detect\", \"yolov8n\", \"coco8.yaml\"),\n    (\"segment\", \"yolov8n-seg\", \"coco8-seg.yaml\"),\n    (\"classify\", \"yolov8n-cls\", \"imagenet10\"),\n    (\"pose\", \"yolov8n-pose\", \"coco8-pose.yaml\"),\n    (\"obb\", \"yolov8n-obb\", \"dota8.yaml\"),\n]  # (task, model, data)\nEXPORT_ARGS = [\n    (\"yolov8n\", \"torchscript\"),",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "TASK_ARGS",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "TASK_ARGS = [\n    (\"detect\", \"yolov8n\", \"coco8.yaml\"),\n    (\"segment\", \"yolov8n-seg\", \"coco8-seg.yaml\"),\n    (\"classify\", \"yolov8n-cls\", \"imagenet10\"),\n    (\"pose\", \"yolov8n-pose\", \"coco8-pose.yaml\"),\n    (\"obb\", \"yolov8n-obb\", \"dota8.yaml\"),\n]  # (task, model, data)\nEXPORT_ARGS = [\n    (\"yolov8n\", \"torchscript\"),\n    (\"yolov8n-seg\", \"torchscript\"),",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "EXPORT_ARGS",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cli",
        "description": "Identification.yolov10.tests.test_cli",
        "peekOfCode": "EXPORT_ARGS = [\n    (\"yolov8n\", \"torchscript\"),\n    (\"yolov8n-seg\", \"torchscript\"),\n    (\"yolov8n-cls\", \"torchscript\"),\n    (\"yolov8n-pose\", \"torchscript\"),\n    (\"yolov8n-obb\", \"torchscript\"),\n]  # (model, format)\ndef run(cmd):\n    \"\"\"Execute a shell command using subprocess.\"\"\"\n    subprocess.run(cmd.split(), check=True)",
        "detail": "Identification.yolov10.tests.test_cli",
        "documentation": {}
    },
    {
        "label": "test_checks",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_train():\n    \"\"\"Test model training on a minimal dataset.\"\"\"\n    device = 0 if CUDA_DEVICE_COUNT == 1 else [0, 1]\n    YOLO(MODEL).train(data=DATA, imgsz=64, epochs=1, device=device)  # requires imgsz>=64\n@pytest.mark.slow",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_train",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_train():\n    \"\"\"Test model training on a minimal dataset.\"\"\"\n    device = 0 if CUDA_DEVICE_COUNT == 1 else [0, 1]\n    YOLO(MODEL).train(data=DATA, imgsz=64, epochs=1, device=device)  # requires imgsz>=64\n@pytest.mark.slow\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_predict_multiple_devices():\n    \"\"\"Validate model prediction on multiple devices.\"\"\"\n    model = YOLO(\"yolov8n.pt\")\n    model = model.cpu()",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_predict_multiple_devices",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_predict_multiple_devices():\n    \"\"\"Validate model prediction on multiple devices.\"\"\"\n    model = YOLO(\"yolov8n.pt\")\n    model = model.cpu()\n    assert str(model.device) == \"cpu\"\n    _ = model(BUS)  # CPU inference\n    assert str(model.device) == \"cpu\"\n    model = model.to(\"cuda:0\")\n    assert str(model.device) == \"cuda:0\"\n    _ = model(BUS)  # CUDA inference",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_autobatch",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_autobatch():\n    \"\"\"Check batch size for YOLO model using autobatch.\"\"\"\n    from ultralytics.utils.autobatch import check_train_batch_size\n    check_train_batch_size(YOLO(MODEL).model.cuda(), imgsz=128, amp=True)\n@pytest.mark.slow\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_utils_benchmarks():\n    \"\"\"Profile YOLO models for performance benchmarks.\"\"\"\n    from ultralytics.utils.benchmarks import ProfileModels\n    # Pre-export a dynamic engine model to use dynamic inference",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_utils_benchmarks",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_utils_benchmarks():\n    \"\"\"Profile YOLO models for performance benchmarks.\"\"\"\n    from ultralytics.utils.benchmarks import ProfileModels\n    # Pre-export a dynamic engine model to use dynamic inference\n    YOLO(MODEL).export(format=\"engine\", imgsz=32, dynamic=True, batch=1)\n    ProfileModels([MODEL], imgsz=32, half=False, min_time=1, num_timed_runs=3, num_warmup_runs=1).profile()\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_predict_sam():\n    \"\"\"Test SAM model prediction with various prompts.\"\"\"\n    from ultralytics import SAM",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_predict_sam",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "def test_predict_sam():\n    \"\"\"Test SAM model prediction with various prompts.\"\"\"\n    from ultralytics import SAM\n    from ultralytics.models.sam import Predictor as SAMPredictor\n    # Load a model\n    model = SAM(WEIGHTS_DIR / \"sam_b.pt\")\n    # Display model information (optional)\n    model.info()\n    # Run inference\n    model(BUS, device=0)",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "CUDA_IS_AVAILABLE",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "CUDA_IS_AVAILABLE = checks.cuda_is_available()\nCUDA_DEVICE_COUNT = checks.cuda_device_count()\nMODEL = WEIGHTS_DIR / \"path with spaces\" / \"yolov8n.pt\"  # test spaces in path\nDATA = \"coco8.yaml\"\nBUS = ASSETS / \"bus.jpg\"\ndef test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "CUDA_DEVICE_COUNT",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "CUDA_DEVICE_COUNT = checks.cuda_device_count()\nMODEL = WEIGHTS_DIR / \"path with spaces\" / \"yolov8n.pt\"  # test spaces in path\nDATA = \"coco8.yaml\"\nBUS = ASSETS / \"bus.jpg\"\ndef test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_train():",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "MODEL = WEIGHTS_DIR / \"path with spaces\" / \"yolov8n.pt\"  # test spaces in path\nDATA = \"coco8.yaml\"\nBUS = ASSETS / \"bus.jpg\"\ndef test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_train():\n    \"\"\"Test model training on a minimal dataset.\"\"\"",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "DATA",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "DATA = \"coco8.yaml\"\nBUS = ASSETS / \"bus.jpg\"\ndef test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_train():\n    \"\"\"Test model training on a minimal dataset.\"\"\"\n    device = 0 if CUDA_DEVICE_COUNT == 1 else [0, 1]",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "BUS",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_cuda",
        "description": "Identification.yolov10.tests.test_cuda",
        "peekOfCode": "BUS = ASSETS / \"bus.jpg\"\ndef test_checks():\n    \"\"\"Validate CUDA settings against torch CUDA functions.\"\"\"\n    assert torch.cuda.is_available() == CUDA_IS_AVAILABLE\n    assert torch.cuda.device_count() == CUDA_DEVICE_COUNT\n@pytest.mark.skipif(not CUDA_IS_AVAILABLE, reason=\"CUDA is not available\")\ndef test_train():\n    \"\"\"Test model training on a minimal dataset.\"\"\"\n    device = 0 if CUDA_DEVICE_COUNT == 1 else [0, 1]\n    YOLO(MODEL).train(data=DATA, imgsz=64, epochs=1, device=device)  # requires imgsz>=64",
        "detail": "Identification.yolov10.tests.test_cuda",
        "documentation": {}
    },
    {
        "label": "test_func",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "def test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()\n    exporter.add_callback(\"on_export_start\", test_func)\n    assert test_func in exporter.callbacks[\"on_export_start\"], \"callback test failed\"\n    f = exporter(model=YOLO(CFG_DET).model)\n    YOLO(f)(ASSETS)  # exported model inference",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "test_export",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "def test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()\n    exporter.add_callback(\"on_export_start\", test_func)\n    assert test_func in exporter.callbacks[\"on_export_start\"], \"callback test failed\"\n    f = exporter(model=YOLO(CFG_DET).model)\n    YOLO(f)(ASSETS)  # exported model inference\ndef test_detect():\n    \"\"\"Test object detection functionality.\"\"\"\n    overrides = {\"data\": \"coco8.yaml\", \"model\": CFG_DET, \"imgsz\": 32, \"epochs\": 1, \"save\": False}",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "test_detect",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "def test_detect():\n    \"\"\"Test object detection functionality.\"\"\"\n    overrides = {\"data\": \"coco8.yaml\", \"model\": CFG_DET, \"imgsz\": 32, \"epochs\": 1, \"save\": False}\n    CFG.data = \"coco8.yaml\"\n    CFG.imgsz = 32\n    # Trainer\n    trainer = detect.DetectionTrainer(overrides=overrides)\n    trainer.add_callback(\"on_train_start\", test_func)\n    assert test_func in trainer.callbacks[\"on_train_start\"], \"callback test failed\"\n    trainer.train()",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "test_segment",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "def test_segment():\n    \"\"\"Test image segmentation functionality.\"\"\"\n    overrides = {\"data\": \"coco8-seg.yaml\", \"model\": CFG_SEG, \"imgsz\": 32, \"epochs\": 1, \"save\": False}\n    CFG.data = \"coco8-seg.yaml\"\n    CFG.imgsz = 32\n    # YOLO(CFG_SEG).train(**overrides)  # works\n    # Trainer\n    trainer = segment.SegmentationTrainer(overrides=overrides)\n    trainer.add_callback(\"on_train_start\", test_func)\n    assert test_func in trainer.callbacks[\"on_train_start\"], \"callback test failed\"",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "test_classify",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "def test_classify():\n    \"\"\"Test image classification functionality.\"\"\"\n    overrides = {\"data\": \"imagenet10\", \"model\": CFG_CLS, \"imgsz\": 32, \"epochs\": 1, \"save\": False}\n    CFG.data = \"imagenet10\"\n    CFG.imgsz = 32\n    # YOLO(CFG_SEG).train(**overrides)  # works\n    # Trainer\n    trainer = classify.ClassificationTrainer(overrides=overrides)\n    trainer.add_callback(\"on_train_start\", test_func)\n    assert test_func in trainer.callbacks[\"on_train_start\"], \"callback test failed\"",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "CFG_DET",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "CFG_DET = \"yolov8n.yaml\"\nCFG_SEG = \"yolov8n-seg.yaml\"\nCFG_CLS = \"yolov8n-cls.yaml\"  # or 'squeezenet1_0'\nCFG = get_cfg(DEFAULT_CFG)\nMODEL = WEIGHTS_DIR / \"yolov8n\"\ndef test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "CFG_SEG",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "CFG_SEG = \"yolov8n-seg.yaml\"\nCFG_CLS = \"yolov8n-cls.yaml\"  # or 'squeezenet1_0'\nCFG = get_cfg(DEFAULT_CFG)\nMODEL = WEIGHTS_DIR / \"yolov8n\"\ndef test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "CFG_CLS",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "CFG_CLS = \"yolov8n-cls.yaml\"  # or 'squeezenet1_0'\nCFG = get_cfg(DEFAULT_CFG)\nMODEL = WEIGHTS_DIR / \"yolov8n\"\ndef test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()\n    exporter.add_callback(\"on_export_start\", test_func)",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "CFG",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "CFG = get_cfg(DEFAULT_CFG)\nMODEL = WEIGHTS_DIR / \"yolov8n\"\ndef test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()\n    exporter.add_callback(\"on_export_start\", test_func)\n    assert test_func in exporter.callbacks[\"on_export_start\"], \"callback test failed\"",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_engine",
        "description": "Identification.yolov10.tests.test_engine",
        "peekOfCode": "MODEL = WEIGHTS_DIR / \"yolov8n\"\ndef test_func(*args):  # noqa\n    \"\"\"Test function callback.\"\"\"\n    print(\"callback test passed\")\ndef test_export():\n    \"\"\"Test model exporting functionality.\"\"\"\n    exporter = Exporter()\n    exporter.add_callback(\"on_export_start\", test_func)\n    assert test_func in exporter.callbacks[\"on_export_start\"], \"callback test failed\"\n    f = exporter(model=YOLO(CFG_DET).model)",
        "detail": "Identification.yolov10.tests.test_engine",
        "documentation": {}
    },
    {
        "label": "test_similarity",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_explorer",
        "description": "Identification.yolov10.tests.test_explorer",
        "peekOfCode": "def test_similarity():\n    \"\"\"Test similarity calculations and SQL queries for correctness and response length.\"\"\"\n    exp = Explorer()\n    exp.create_embeddings_table()\n    similar = exp.get_similar(idx=1)\n    assert len(similar) == 25\n    similar = exp.get_similar(img=ASSETS / \"zidane.jpg\")\n    assert len(similar) == 25\n    similar = exp.get_similar(idx=[1, 2], limit=10)\n    assert len(similar) == 10",
        "detail": "Identification.yolov10.tests.test_explorer",
        "documentation": {}
    },
    {
        "label": "test_det",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_explorer",
        "description": "Identification.yolov10.tests.test_explorer",
        "peekOfCode": "def test_det():\n    \"\"\"Test detection functionalities and ensure the embedding table has bounding boxes.\"\"\"\n    exp = Explorer(data=\"coco8.yaml\", model=\"yolov8n.pt\")\n    exp.create_embeddings_table(force=True)\n    assert len(exp.table.head()[\"bboxes\"]) > 0\n    similar = exp.get_similar(idx=[1, 2], limit=10)\n    assert len(similar) > 0\n    # This is a loose test, just checks errors not correctness\n    similar = exp.plot_similar(idx=[1, 2], limit=10)\n    assert isinstance(similar, PIL.Image.Image)",
        "detail": "Identification.yolov10.tests.test_explorer",
        "documentation": {}
    },
    {
        "label": "test_seg",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_explorer",
        "description": "Identification.yolov10.tests.test_explorer",
        "peekOfCode": "def test_seg():\n    \"\"\"Test segmentation functionalities and verify the embedding table includes masks.\"\"\"\n    exp = Explorer(data=\"coco8-seg.yaml\", model=\"yolov8n-seg.pt\")\n    exp.create_embeddings_table(force=True)\n    assert len(exp.table.head()[\"masks\"]) > 0\n    similar = exp.get_similar(idx=[1, 2], limit=10)\n    assert len(similar) > 0\n    similar = exp.plot_similar(idx=[1, 2], limit=10)\n    assert isinstance(similar, PIL.Image.Image)\n@pytest.mark.slow",
        "detail": "Identification.yolov10.tests.test_explorer",
        "documentation": {}
    },
    {
        "label": "test_pose",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_explorer",
        "description": "Identification.yolov10.tests.test_explorer",
        "peekOfCode": "def test_pose():\n    \"\"\"Test pose estimation functionalities and check the embedding table for keypoints.\"\"\"\n    exp = Explorer(data=\"coco8-pose.yaml\", model=\"yolov8n-pose.pt\")\n    exp.create_embeddings_table(force=True)\n    assert len(exp.table.head()[\"keypoints\"]) > 0\n    similar = exp.get_similar(idx=[1, 2], limit=10)\n    assert len(similar) > 0\n    similar = exp.plot_similar(idx=[1, 2], limit=10)\n    assert isinstance(similar, PIL.Image.Image)",
        "detail": "Identification.yolov10.tests.test_explorer",
        "documentation": {}
    },
    {
        "label": "test_model_ray_tune",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "def test_model_ray_tune():\n    \"\"\"Tune YOLO model with Ray optimization library.\"\"\"\n    YOLO(\"yolov8n-cls.yaml\").tune(\n        use_ray=True, data=\"imagenet10\", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device=\"cpu\"\n    )\n@pytest.mark.skipif(not check_requirements(\"mlflow\", install=False), reason=\"mlflow not installed\")\ndef test_mlflow():\n    \"\"\"Test training with MLflow tracking enabled.\"\"\"\n    SETTINGS[\"mlflow\"] = True\n    YOLO(\"yolov8n-cls.yaml\").train(data=\"imagenet10\", imgsz=32, epochs=3, plots=False, device=\"cpu\")",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "test_mlflow",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "def test_mlflow():\n    \"\"\"Test training with MLflow tracking enabled.\"\"\"\n    SETTINGS[\"mlflow\"] = True\n    YOLO(\"yolov8n-cls.yaml\").train(data=\"imagenet10\", imgsz=32, epochs=3, plots=False, device=\"cpu\")\n@pytest.mark.skipif(True, reason=\"Test failing in scheduled CI https://github.com/ultralytics/ultralytics/pull/8868\")\n@pytest.mark.skipif(not check_requirements(\"mlflow\", install=False), reason=\"mlflow not installed\")\ndef test_mlflow_keep_run_active():\n    import os\n    import mlflow\n    \"\"\"Test training with MLflow tracking enabled.\"\"\"",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "test_mlflow_keep_run_active",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "def test_mlflow_keep_run_active():\n    import os\n    import mlflow\n    \"\"\"Test training with MLflow tracking enabled.\"\"\"\n    SETTINGS[\"mlflow\"] = True\n    run_name = \"Test Run\"\n    os.environ[\"MLFLOW_RUN\"] = run_name\n    # Test with MLFLOW_KEEP_RUN_ACTIVE=True\n    os.environ[\"MLFLOW_KEEP_RUN_ACTIVE\"] = \"True\"\n    YOLO(\"yolov8n-cls.yaml\").train(data=\"imagenet10\", imgsz=32, epochs=1, plots=False, device=\"cpu\")",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "test_triton",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "def test_triton():\n    \"\"\"Test NVIDIA Triton Server functionalities.\"\"\"\n    check_requirements(\"tritonclient[all]\")\n    import subprocess\n    import time\n    from tritonclient.http import InferenceServerClient  # noqa\n    # Create variables\n    model_name = \"yolo\"\n    triton_repo = TMP / \"triton_repo\"  # Triton repo path\n    triton_model = triton_repo / model_name  # Triton model path",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "test_pycocotools",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "def test_pycocotools():\n    \"\"\"Validate model predictions using pycocotools.\"\"\"\n    from ultralytics.models.yolo.detect import DetectionValidator\n    from ultralytics.models.yolo.pose import PoseValidator\n    from ultralytics.models.yolo.segment import SegmentationValidator\n    # Download annotations after each dataset downloads first\n    url = \"https://github.com/ultralytics/assets/releases/download/v8.1.0/\"\n    args = {\"model\": \"yolov8n.pt\", \"data\": \"coco8.yaml\", \"save_json\": True, \"imgsz\": 64}\n    validator = DetectionValidator(args=args)\n    validator()",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "MODEL = WEIGHTS_DIR / \"path with spaces\" / \"yolov8n.pt\"  # test spaces in path\nCFG = \"yolov8n.yaml\"\nSOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\n@pytest.mark.skipif(not check_requirements(\"ray\", install=False), reason=\"ray[tune] not installed\")\ndef test_model_ray_tune():\n    \"\"\"Tune YOLO model with Ray optimization library.\"\"\"\n    YOLO(\"yolov8n-cls.yaml\").tune(\n        use_ray=True, data=\"imagenet10\", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device=\"cpu\"\n    )",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "CFG",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "CFG = \"yolov8n.yaml\"\nSOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\n@pytest.mark.skipif(not check_requirements(\"ray\", install=False), reason=\"ray[tune] not installed\")\ndef test_model_ray_tune():\n    \"\"\"Tune YOLO model with Ray optimization library.\"\"\"\n    YOLO(\"yolov8n-cls.yaml\").tune(\n        use_ray=True, data=\"imagenet10\", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device=\"cpu\"\n    )\n@pytest.mark.skipif(not check_requirements(\"mlflow\", install=False), reason=\"mlflow not installed\")",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "SOURCE",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "SOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\n@pytest.mark.skipif(not check_requirements(\"ray\", install=False), reason=\"ray[tune] not installed\")\ndef test_model_ray_tune():\n    \"\"\"Tune YOLO model with Ray optimization library.\"\"\"\n    YOLO(\"yolov8n-cls.yaml\").tune(\n        use_ray=True, data=\"imagenet10\", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device=\"cpu\"\n    )\n@pytest.mark.skipif(not check_requirements(\"mlflow\", install=False), reason=\"mlflow not installed\")\ndef test_mlflow():",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "TMP",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_integrations",
        "description": "Identification.yolov10.tests.test_integrations",
        "peekOfCode": "TMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\n@pytest.mark.skipif(not check_requirements(\"ray\", install=False), reason=\"ray[tune] not installed\")\ndef test_model_ray_tune():\n    \"\"\"Tune YOLO model with Ray optimization library.\"\"\"\n    YOLO(\"yolov8n-cls.yaml\").tune(\n        use_ray=True, data=\"imagenet10\", grace_period=1, iterations=1, imgsz=32, epochs=1, plots=False, device=\"cpu\"\n    )\n@pytest.mark.skipif(not check_requirements(\"mlflow\", install=False), reason=\"mlflow not installed\")\ndef test_mlflow():\n    \"\"\"Test training with MLflow tracking enabled.\"\"\"",
        "detail": "Identification.yolov10.tests.test_integrations",
        "documentation": {}
    },
    {
        "label": "test_model_forward",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"\n    model = YOLO(MODEL)\n    # Model methods\n    model.info(verbose=True, detailed=True)\n    model = model.reset_weights()",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_model_methods",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"\n    model = YOLO(MODEL)\n    # Model methods\n    model.info(verbose=True, detailed=True)\n    model = model.reset_weights()\n    model = model.load(MODEL)\n    model.to(\"cpu\")\n    model.fuse()\n    model.clear_callback(\"on_train_start\")",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_model_profile",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_model_profile():\n    \"\"\"Test profiling of the YOLO model with 'profile=True' argument.\"\"\"\n    from ultralytics.nn.tasks import DetectionModel\n    model = DetectionModel()  # build model\n    im = torch.randn(1, 3, 64, 64)  # requires min imgsz=64\n    _ = model.predict(im, profile=True)\n@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason=\"directory is not writeable\")\ndef test_predict_txt():\n    \"\"\"Test YOLO predictions with sources (file, dir, glob, recursive glob) specified in a text file.\"\"\"\n    txt_file = TMP / \"sources.txt\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_predict_txt",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_predict_txt():\n    \"\"\"Test YOLO predictions with sources (file, dir, glob, recursive glob) specified in a text file.\"\"\"\n    txt_file = TMP / \"sources.txt\"\n    with open(txt_file, \"w\") as f:\n        for x in [ASSETS / \"bus.jpg\", ASSETS, ASSETS / \"*\", ASSETS / \"**/*.jpg\"]:\n            f.write(f\"{x}\\n\")\n    _ = YOLO(MODEL)(source=txt_file, imgsz=32)\ndef test_predict_img():\n    \"\"\"Test YOLO prediction on various types of image sources.\"\"\"\n    model = YOLO(MODEL)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_predict_img",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_predict_img():\n    \"\"\"Test YOLO prediction on various types of image sources.\"\"\"\n    model = YOLO(MODEL)\n    seg_model = YOLO(WEIGHTS_DIR / \"yolov8n-seg.pt\")\n    cls_model = YOLO(WEIGHTS_DIR / \"yolov8n-cls.pt\")\n    pose_model = YOLO(WEIGHTS_DIR / \"yolov8n-pose.pt\")\n    obb_model = YOLO(WEIGHTS_DIR / \"yolov8n-obb.pt\")\n    im = cv2.imread(str(SOURCE))\n    assert len(model(source=Image.open(SOURCE), save=True, verbose=True, imgsz=32)) == 1  # PIL\n    assert len(model(source=im, save=True, save_txt=True, imgsz=32)) == 1  # ndarray",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_predict_grey_and_4ch",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_predict_grey_and_4ch():\n    \"\"\"Test YOLO prediction on SOURCE converted to greyscale and 4-channel images.\"\"\"\n    im = Image.open(SOURCE)\n    directory = TMP / \"im4\"\n    directory.mkdir(parents=True, exist_ok=True)\n    source_greyscale = directory / \"greyscale.jpg\"\n    source_rgba = directory / \"4ch.png\"\n    source_non_utf = directory / \"non_UTF__tst_image.jpg\"\n    source_spaces = directory / \"image with spaces.jpg\"\n    im.convert(\"L\").save(source_greyscale)  # greyscale",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_youtube",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_youtube():\n    \"\"\"\n    Test YouTube inference.\n    Marked --slow to reduce YouTube API rate limits risk.\n    \"\"\"\n    model = YOLO(MODEL)\n    model.predict(\"https://youtu.be/G17sBkb38XQ\", imgsz=96, save=True)\n@pytest.mark.skipif(not ONLINE, reason=\"environment is offline\")\n@pytest.mark.skipif(not IS_TMP_WRITEABLE, reason=\"directory is not writeable\")\ndef test_track_stream():",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_track_stream",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_track_stream():\n    \"\"\"\n    Test streaming tracking (short 10 frame video) with non-default ByteTrack tracker.\n    Note imgsz=160 required for tracking for higher confidence and better matches\n    \"\"\"\n    video_url = \"https://ultralytics.com/assets/decelera_portrait_min.mov\"\n    model = YOLO(MODEL)\n    model.track(video_url, imgsz=160, tracker=\"bytetrack.yaml\")\n    model.track(video_url, imgsz=160, tracker=\"botsort.yaml\", save_frames=True)  # test frame saving also\n    # Test Global Motion Compensation (GMC) methods",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_val",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_val():\n    \"\"\"Test the validation mode of the YOLO model.\"\"\"\n    YOLO(MODEL).val(data=\"coco8.yaml\", imgsz=32, save_hybrid=True)\ndef test_train_scratch():\n    \"\"\"Test training the YOLO model from scratch.\"\"\"\n    model = YOLO(CFG)\n    model.train(data=\"coco8.yaml\", epochs=2, imgsz=32, cache=\"disk\", batch=-1, close_mosaic=1, name=\"model\")\n    model(SOURCE)\ndef test_train_pretrained():\n    \"\"\"Test training the YOLO model from a pre-trained state.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_train_scratch",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_train_scratch():\n    \"\"\"Test training the YOLO model from scratch.\"\"\"\n    model = YOLO(CFG)\n    model.train(data=\"coco8.yaml\", epochs=2, imgsz=32, cache=\"disk\", batch=-1, close_mosaic=1, name=\"model\")\n    model(SOURCE)\ndef test_train_pretrained():\n    \"\"\"Test training the YOLO model from a pre-trained state.\"\"\"\n    model = YOLO(WEIGHTS_DIR / \"yolov8n-seg.pt\")\n    model.train(data=\"coco8-seg.yaml\", epochs=1, imgsz=32, cache=\"ram\", copy_paste=0.5, mixup=0.5, name=0)\n    model(SOURCE)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_train_pretrained",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_train_pretrained():\n    \"\"\"Test training the YOLO model from a pre-trained state.\"\"\"\n    model = YOLO(WEIGHTS_DIR / \"yolov8n-seg.pt\")\n    model.train(data=\"coco8-seg.yaml\", epochs=1, imgsz=32, cache=\"ram\", copy_paste=0.5, mixup=0.5, name=0)\n    model(SOURCE)\ndef test_export_torchscript():\n    \"\"\"Test exporting the YOLO model to TorchScript format.\"\"\"\n    f = YOLO(MODEL).export(format=\"torchscript\", optimize=False)\n    YOLO(f)(SOURCE)  # exported model inference\ndef test_export_onnx():",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_torchscript",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_torchscript():\n    \"\"\"Test exporting the YOLO model to TorchScript format.\"\"\"\n    f = YOLO(MODEL).export(format=\"torchscript\", optimize=False)\n    YOLO(f)(SOURCE)  # exported model inference\ndef test_export_onnx():\n    \"\"\"Test exporting the YOLO model to ONNX format.\"\"\"\n    f = YOLO(MODEL).export(format=\"onnx\", dynamic=True)\n    YOLO(f)(SOURCE)  # exported model inference\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"OpenVINO not supported in Python 3.12\")\n@pytest.mark.skipif(not TORCH_1_13, reason=\"OpenVINO requires torch>=1.13\")",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_onnx",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_onnx():\n    \"\"\"Test exporting the YOLO model to ONNX format.\"\"\"\n    f = YOLO(MODEL).export(format=\"onnx\", dynamic=True)\n    YOLO(f)(SOURCE)  # exported model inference\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"OpenVINO not supported in Python 3.12\")\n@pytest.mark.skipif(not TORCH_1_13, reason=\"OpenVINO requires torch>=1.13\")\ndef test_export_openvino():\n    \"\"\"Test exporting the YOLO model to OpenVINO format.\"\"\"\n    f = YOLO(MODEL).export(format=\"openvino\")\n    YOLO(f)(SOURCE)  # exported model inference",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_openvino",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_openvino():\n    \"\"\"Test exporting the YOLO model to OpenVINO format.\"\"\"\n    f = YOLO(MODEL).export(format=\"openvino\")\n    YOLO(f)(SOURCE)  # exported model inference\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"CoreML not supported in Python 3.12\")\ndef test_export_coreml():\n    \"\"\"Test exporting the YOLO model to CoreML format.\"\"\"\n    if not WINDOWS:  # RuntimeError: BlobWriter not loaded with coremltools 7.0 on windows\n        if MACOS:\n            f = YOLO(MODEL).export(format=\"coreml\")",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_coreml",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_coreml():\n    \"\"\"Test exporting the YOLO model to CoreML format.\"\"\"\n    if not WINDOWS:  # RuntimeError: BlobWriter not loaded with coremltools 7.0 on windows\n        if MACOS:\n            f = YOLO(MODEL).export(format=\"coreml\")\n            YOLO(f)(SOURCE)  # model prediction only supported on macOS for nms=False models\n        else:\n            YOLO(MODEL).export(format=\"coreml\", nms=True)\ndef test_export_tflite(enabled=False):\n    \"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_tflite",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_tflite(enabled=False):\n    \"\"\"\n    Test exporting the YOLO model to TFLite format.\n    Note TF suffers from install conflicts on Windows and macOS.\n    \"\"\"\n    if enabled and LINUX:\n        model = YOLO(MODEL)\n        f = model.export(format=\"tflite\")\n        YOLO(f)(SOURCE)\ndef test_export_pb(enabled=False):",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_pb",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_pb(enabled=False):\n    \"\"\"\n    Test exporting the YOLO model to *.pb format.\n    Note TF suffers from install conflicts on Windows and macOS.\n    \"\"\"\n    if enabled and LINUX:\n        model = YOLO(MODEL)\n        f = model.export(format=\"pb\")\n        YOLO(f)(SOURCE)\ndef test_export_paddle(enabled=False):",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_paddle",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_paddle(enabled=False):\n    \"\"\"\n    Test exporting the YOLO model to Paddle format.\n    Note Paddle protobuf requirements conflicting with onnx protobuf requirements.\n    \"\"\"\n    if enabled:\n        YOLO(MODEL).export(format=\"paddle\")\n@pytest.mark.slow\ndef test_export_ncnn():\n    \"\"\"Test exporting the YOLO model to NCNN format.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_export_ncnn",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_export_ncnn():\n    \"\"\"Test exporting the YOLO model to NCNN format.\"\"\"\n    f = YOLO(MODEL).export(format=\"ncnn\")\n    YOLO(f)(SOURCE)  # exported model inference\ndef test_all_model_yamls():\n    \"\"\"Test YOLO model creation for all available YAML configurations.\"\"\"\n    for m in (ROOT / \"cfg\" / \"models\").rglob(\"*.yaml\"):\n        if \"rtdetr\" in m.name:\n            if TORCH_1_9:  # torch<=1.8 issue - TypeError: __init__() got an unexpected keyword argument 'batch_first'\n                _ = RTDETR(m.name)(SOURCE, imgsz=640)  # must be 640",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_all_model_yamls",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_all_model_yamls():\n    \"\"\"Test YOLO model creation for all available YAML configurations.\"\"\"\n    for m in (ROOT / \"cfg\" / \"models\").rglob(\"*.yaml\"):\n        if \"rtdetr\" in m.name:\n            if TORCH_1_9:  # torch<=1.8 issue - TypeError: __init__() got an unexpected keyword argument 'batch_first'\n                _ = RTDETR(m.name)(SOURCE, imgsz=640)  # must be 640\n        else:\n            YOLO(m.name)\ndef test_workflow():\n    \"\"\"Test the complete workflow including training, validation, prediction, and exporting.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_workflow",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_workflow():\n    \"\"\"Test the complete workflow including training, validation, prediction, and exporting.\"\"\"\n    model = YOLO(MODEL)\n    model.train(data=\"coco8.yaml\", epochs=1, imgsz=32, optimizer=\"SGD\")\n    model.val(imgsz=32)\n    model.predict(SOURCE, imgsz=32)\n    model.export(format=\"onnx\")  # export a model to ONNX format\ndef test_predict_callback_and_setup():\n    \"\"\"Test callback functionality during YOLO prediction.\"\"\"\n    def on_predict_batch_end(predictor):",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_predict_callback_and_setup",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_predict_callback_and_setup():\n    \"\"\"Test callback functionality during YOLO prediction.\"\"\"\n    def on_predict_batch_end(predictor):\n        \"\"\"Callback function that handles operations at the end of a prediction batch.\"\"\"\n        path, im0s, _ = predictor.batch\n        im0s = im0s if isinstance(im0s, list) else [im0s]\n        bs = [predictor.dataset.bs for _ in range(len(path))]\n        predictor.results = zip(predictor.results, im0s, bs)  # results is List[batch_size]\n    model = YOLO(MODEL)\n    model.add_callback(\"on_predict_batch_end\", on_predict_batch_end)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_results",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_results():\n    \"\"\"Test various result formats for the YOLO model.\"\"\"\n    for m in \"yolov8n-pose.pt\", \"yolov8n-seg.pt\", \"yolov8n.pt\", \"yolov8n-cls.pt\":\n        results = YOLO(WEIGHTS_DIR / m)([SOURCE, SOURCE], imgsz=160)\n        for r in results:\n            r = r.cpu().numpy()\n            r = r.to(device=\"cpu\", dtype=torch.float32)\n            r.save_txt(txt_file=TMP / \"runs/tests/label.txt\", save_conf=True)\n            r.save_crop(save_dir=TMP / \"runs/tests/crops/\")\n            r.tojson(normalize=True)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_labels_and_crops",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_labels_and_crops():\n    \"\"\"Test output from prediction args for saving detection labels and crops.\"\"\"\n    imgs = [SOURCE, ASSETS / \"zidane.jpg\"]\n    results = YOLO(WEIGHTS_DIR / \"yolov8n.pt\")(imgs, imgsz=160, save_txt=True, save_crop=True)\n    save_path = Path(results[0].save_dir)\n    for r in results:\n        im_name = Path(r.path).stem\n        cls_idxs = r.boxes.cls.int().tolist()\n        # Check label path\n        labels = save_path / f\"labels/{im_name}.txt\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_data_utils",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_data_utils():\n    \"\"\"Test utility functions in ultralytics/data/utils.py.\"\"\"\n    from ultralytics.data.utils import HUBDatasetStats, autosplit\n    from ultralytics.utils.downloads import zip_directory\n    # from ultralytics.utils.files import WorkingDirectory\n    # with WorkingDirectory(ROOT.parent / 'tests'):\n    for task in \"detect\", \"segment\", \"pose\", \"classify\":\n        file = Path(TASK2DATA[task]).with_suffix(\".zip\")  # i.e. coco8.zip\n        download(f\"https://github.com/ultralytics/hub/raw/main/example_datasets/{file}\", unzip=False, dir=TMP)\n        stats = HUBDatasetStats(TMP / file, task=task)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_data_converter",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_data_converter():\n    \"\"\"Test dataset converters.\"\"\"\n    from ultralytics.data.converter import coco80_to_coco91_class, convert_coco\n    file = \"instances_val2017.json\"\n    download(f\"https://github.com/ultralytics/yolov5/releases/download/v1.0/{file}\", dir=TMP)\n    convert_coco(labels_dir=TMP, save_dir=TMP / \"yolo_labels\", use_segments=True, use_keypoints=False, cls91to80=True)\n    coco80_to_coco91_class()\ndef test_data_annotator():\n    \"\"\"Test automatic data annotation.\"\"\"\n    from ultralytics.data.annotator import auto_annotate",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_data_annotator",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_data_annotator():\n    \"\"\"Test automatic data annotation.\"\"\"\n    from ultralytics.data.annotator import auto_annotate\n    auto_annotate(\n        ASSETS,\n        det_model=WEIGHTS_DIR / \"yolov8n.pt\",\n        sam_model=WEIGHTS_DIR / \"mobile_sam.pt\",\n        output_dir=TMP / \"auto_annotate_labels\",\n    )\ndef test_events():",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_events",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_events():\n    \"\"\"Test event sending functionality.\"\"\"\n    from ultralytics.hub.utils import Events\n    events = Events()\n    events.enabled = True\n    cfg = copy(DEFAULT_CFG)  # does not require deepcopy\n    cfg.mode = \"test\"\n    events(cfg)\ndef test_cfg_init():\n    \"\"\"Test configuration initialization utilities.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_cfg_init",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_cfg_init():\n    \"\"\"Test configuration initialization utilities.\"\"\"\n    from ultralytics.cfg import check_dict_alignment, copy_default_cfg, smart_value\n    with contextlib.suppress(SyntaxError):\n        check_dict_alignment({\"a\": 1}, {\"b\": 2})\n    copy_default_cfg()\n    (Path.cwd() / DEFAULT_CFG_PATH.name.replace(\".yaml\", \"_copy.yaml\")).unlink(missing_ok=False)\n    [smart_value(x) for x in [\"none\", \"true\", \"false\"]]\ndef test_utils_init():\n    \"\"\"Test initialization utilities.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_init",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_init():\n    \"\"\"Test initialization utilities.\"\"\"\n    from ultralytics.utils import get_git_branch, get_git_origin_url, get_ubuntu_version, is_github_action_running\n    get_ubuntu_version()\n    is_github_action_running()\n    get_git_origin_url()\n    get_git_branch()\ndef test_utils_checks():\n    \"\"\"Test various utility checks.\"\"\"\n    checks.check_yolov5u_filename(\"yolov5n.pt\")",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_checks",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_checks():\n    \"\"\"Test various utility checks.\"\"\"\n    checks.check_yolov5u_filename(\"yolov5n.pt\")\n    checks.git_describe(ROOT)\n    checks.check_requirements()  # check requirements.txt\n    checks.check_imgsz([600, 600], max_dim=1)\n    checks.check_imshow()\n    checks.check_version(\"ultralytics\", \"8.0.0\")\n    checks.print_args()\n    # checks.check_imshow(warn=True)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_benchmarks",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_benchmarks():\n    \"\"\"Test model benchmarking.\"\"\"\n    from ultralytics.utils.benchmarks import ProfileModels\n    ProfileModels([\"yolov8n.yaml\"], imgsz=32, min_time=1, num_timed_runs=3, num_warmup_runs=1).profile()\ndef test_utils_torchutils():\n    \"\"\"Test Torch utility functions.\"\"\"\n    from ultralytics.nn.modules.conv import Conv\n    from ultralytics.utils.torch_utils import get_flops_with_torch_profiler, profile, time_sync\n    x = torch.randn(1, 64, 20, 20)\n    m = Conv(64, 64, k=1, s=2)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_torchutils",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_torchutils():\n    \"\"\"Test Torch utility functions.\"\"\"\n    from ultralytics.nn.modules.conv import Conv\n    from ultralytics.utils.torch_utils import get_flops_with_torch_profiler, profile, time_sync\n    x = torch.randn(1, 64, 20, 20)\n    m = Conv(64, 64, k=1, s=2)\n    profile(x, [m], n=3)\n    get_flops_with_torch_profiler(m)\n    time_sync()\n@pytest.mark.slow",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_downloads",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_downloads():\n    \"\"\"Test file download utilities.\"\"\"\n    from ultralytics.utils.downloads import get_google_drive_file_info\n    get_google_drive_file_info(\"https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link\")\ndef test_utils_ops():\n    \"\"\"Test various operations utilities.\"\"\"\n    from ultralytics.utils.ops import (\n        ltwh2xywh,\n        ltwh2xyxy,\n        make_divisible,",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_ops",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_ops():\n    \"\"\"Test various operations utilities.\"\"\"\n    from ultralytics.utils.ops import (\n        ltwh2xywh,\n        ltwh2xyxy,\n        make_divisible,\n        xywh2ltwh,\n        xywh2xyxy,\n        xywhn2xyxy,\n        xywhr2xyxyxyxy,",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_files",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_files():\n    \"\"\"Test file handling utilities.\"\"\"\n    from ultralytics.utils.files import file_age, file_date, get_latest_run, spaces_in_path\n    file_age(SOURCE)\n    file_date(SOURCE)\n    get_latest_run(ROOT / \"runs\")\n    path = TMP / \"path/with spaces\"\n    path.mkdir(parents=True, exist_ok=True)\n    with spaces_in_path(path) as new_path:\n        print(new_path)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_utils_patches_torch_save",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_utils_patches_torch_save():\n    \"\"\"Test torch_save backoff when _torch_save throws RuntimeError.\"\"\"\n    from unittest.mock import patch, MagicMock\n    from ultralytics.utils.patches import torch_save\n    mock = MagicMock(side_effect=RuntimeError)\n    with patch(\"ultralytics.utils.patches._torch_save\", new=mock):\n        with pytest.raises(RuntimeError):\n            torch_save(torch.zeros(1), TMP / \"test.pt\")\n    assert mock.call_count == 4, \"torch_save was not attempted the expected number of times\"\ndef test_nn_modules_conv():",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_nn_modules_conv",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_nn_modules_conv():\n    \"\"\"Test Convolutional Neural Network modules.\"\"\"\n    from ultralytics.nn.modules.conv import CBAM, Conv2, ConvTranspose, DWConvTranspose2d, Focus\n    c1, c2 = 8, 16  # input and output channels\n    x = torch.zeros(4, c1, 10, 10)  # BCHW\n    # Run all modules not otherwise covered in tests\n    DWConvTranspose2d(c1, c2)(x)\n    ConvTranspose(c1, c2)(x)\n    Focus(c1, c2)(x)\n    CBAM(c1)(x)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_nn_modules_block",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_nn_modules_block():\n    \"\"\"Test Neural Network block modules.\"\"\"\n    from ultralytics.nn.modules.block import C1, C3TR, BottleneckCSP, C3Ghost, C3x\n    c1, c2 = 8, 16  # input and output channels\n    x = torch.zeros(4, c1, 10, 10)  # BCHW\n    # Run all modules not otherwise covered in tests\n    C1(c1, c2)(x)\n    C3x(c1, c2)(x)\n    C3TR(c1, c2)(x)\n    C3Ghost(c1, c2)(x)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_hub",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_hub():\n    \"\"\"Test Ultralytics HUB functionalities.\"\"\"\n    from ultralytics.hub import export_fmts_hub, logout\n    from ultralytics.hub.utils import smart_request\n    export_fmts_hub()\n    logout()\n    smart_request(\"GET\", \"https://github.com\", progress=True)\n@pytest.fixture\ndef image():\n    \"\"\"Loads an image from a predefined source using OpenCV.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def image():\n    \"\"\"Loads an image from a predefined source using OpenCV.\"\"\"\n    return cv2.imread(str(SOURCE))\n@pytest.mark.parametrize(\n    \"auto_augment, erasing, force_color_jitter\",\n    [\n        (None, 0.0, False),\n        (\"randaugment\", 0.5, True),\n        (\"augmix\", 0.2, False),\n        (\"autoaugment\", 0.0, True),",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_classify_transforms_train",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_classify_transforms_train(image, auto_augment, erasing, force_color_jitter):\n    \"\"\"Tests classification transforms during training with various augmentation settings.\"\"\"\n    import torchvision.transforms as T\n    from ultralytics.data.augment import classify_augmentations\n    transform = classify_augmentations(\n        size=224,\n        mean=(0.5, 0.5, 0.5),\n        std=(0.5, 0.5, 0.5),\n        scale=(0.08, 1.0),\n        ratio=(3.0 / 4.0, 4.0 / 3.0),",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_model_tune",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_model_tune():\n    \"\"\"Tune YOLO model for performance.\"\"\"\n    YOLO(\"yolov8n-pose.pt\").tune(data=\"coco8-pose.yaml\", plots=False, imgsz=32, epochs=1, iterations=2, device=\"cpu\")\n    YOLO(\"yolov8n-cls.pt\").tune(data=\"imagenet10\", plots=False, imgsz=32, epochs=1, iterations=2, device=\"cpu\")\ndef test_model_embeddings():\n    \"\"\"Test YOLO model embeddings.\"\"\"\n    model_detect = YOLO(MODEL)\n    model_segment = YOLO(WEIGHTS_DIR / \"yolov8n-seg.pt\")\n    for batch in [SOURCE], [SOURCE, SOURCE]:  # test batch size 1 and 2\n        assert len(model_detect.embed(source=batch, imgsz=32)) == len(batch)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_model_embeddings",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_model_embeddings():\n    \"\"\"Test YOLO model embeddings.\"\"\"\n    model_detect = YOLO(MODEL)\n    model_segment = YOLO(WEIGHTS_DIR / \"yolov8n-seg.pt\")\n    for batch in [SOURCE], [SOURCE, SOURCE]:  # test batch size 1 and 2\n        assert len(model_detect.embed(source=batch, imgsz=32)) == len(batch)\n        assert len(model_segment.embed(source=batch, imgsz=32)) == len(batch)\n@pytest.mark.skipif(checks.IS_PYTHON_3_12, reason=\"YOLOWorld with CLIP is not supported in Python 3.12\")\ndef test_yolo_world():\n    model = YOLO(\"yolov8s-world.pt\")  # no YOLOv8n-world model yet",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "test_yolo_world",
        "kind": 2,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "def test_yolo_world():\n    model = YOLO(\"yolov8s-world.pt\")  # no YOLOv8n-world model yet\n    model.set_classes([\"tree\", \"window\"])\n    model(ASSETS / \"bus.jpg\", conf=0.01)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "MODEL",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "MODEL = WEIGHTS_DIR / \"path with spaces\" / \"yolov8n.pt\"  # test spaces in path\nCFG = \"yolov8n.yaml\"\nSOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\nIS_TMP_WRITEABLE = is_dir_writeable(TMP)\ndef test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "CFG",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "CFG = \"yolov8n.yaml\"\nSOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\nIS_TMP_WRITEABLE = is_dir_writeable(TMP)\ndef test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "SOURCE",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "SOURCE = ASSETS / \"bus.jpg\"\nTMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\nIS_TMP_WRITEABLE = is_dir_writeable(TMP)\ndef test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"\n    model = YOLO(MODEL)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "TMP",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "TMP = (ROOT / \"../tests/tmp\").resolve()  # temp directory for test files\nIS_TMP_WRITEABLE = is_dir_writeable(TMP)\ndef test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"\n    model = YOLO(MODEL)\n    # Model methods",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "IS_TMP_WRITEABLE",
        "kind": 5,
        "importPath": "Identification.yolov10.tests.test_python",
        "description": "Identification.yolov10.tests.test_python",
        "peekOfCode": "IS_TMP_WRITEABLE = is_dir_writeable(TMP)\ndef test_model_forward():\n    \"\"\"Test the forward pass of the YOLO model.\"\"\"\n    model = YOLO(CFG)\n    model(source=None, imgsz=32, augment=True)  # also test no source and augment\ndef test_model_methods():\n    \"\"\"Test various methods and properties of the YOLO model.\"\"\"\n    model = YOLO(MODEL)\n    # Model methods\n    model.info(verbose=True, detailed=True)",
        "detail": "Identification.yolov10.tests.test_python",
        "documentation": {}
    },
    {
        "label": "init_explorer_form",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def init_explorer_form():\n    \"\"\"Initializes an Explorer instance and creates embeddings table with progress tracking.\"\"\"\n    datasets = ROOT / \"cfg\" / \"datasets\"\n    ds = [d.name for d in datasets.glob(\"*.yaml\")]\n    models = [\n        \"yolov8n.pt\",\n        \"yolov8s.pt\",\n        \"yolov8m.pt\",\n        \"yolov8l.pt\",\n        \"yolov8x.pt\",",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "query_form",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def query_form():\n    \"\"\"Sets up a form in Streamlit to initialize Explorer with dataset and model selection.\"\"\"\n    with st.form(\"query_form\"):\n        col1, col2 = st.columns([0.8, 0.2])\n        with col1:\n            st.text_input(\n                \"Query\",\n                \"WHERE labels LIKE '%person%' AND labels LIKE '%dog%'\",\n                label_visibility=\"collapsed\",\n                key=\"query\",",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "ai_query_form",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def ai_query_form():\n    \"\"\"Sets up a Streamlit form for user input to initialize Explorer with dataset and model selection.\"\"\"\n    with st.form(\"ai_query_form\"):\n        col1, col2 = st.columns([0.8, 0.2])\n        with col1:\n            st.text_input(\"Query\", \"Show images with 1 person and 1 dog\", label_visibility=\"collapsed\", key=\"ai_query\")\n        with col2:\n            st.form_submit_button(\"Ask AI\", on_click=run_ai_query)\ndef find_similar_imgs(imgs):\n    \"\"\"Initializes a Streamlit form for AI-based image querying with custom input.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "find_similar_imgs",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def find_similar_imgs(imgs):\n    \"\"\"Initializes a Streamlit form for AI-based image querying with custom input.\"\"\"\n    exp = st.session_state[\"explorer\"]\n    similar = exp.get_similar(img=imgs, limit=st.session_state.get(\"limit\"), return_type=\"arrow\")\n    paths = similar.to_pydict()[\"im_file\"]\n    st.session_state[\"imgs\"] = paths\n    st.session_state[\"res\"] = similar\ndef similarity_form(selected_imgs):\n    \"\"\"Initializes a form for AI-based image querying with custom input in Streamlit.\"\"\"\n    st.write(\"Similarity Search\")",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "similarity_form",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def similarity_form(selected_imgs):\n    \"\"\"Initializes a form for AI-based image querying with custom input in Streamlit.\"\"\"\n    st.write(\"Similarity Search\")\n    with st.form(\"similarity_form\"):\n        subcol1, subcol2 = st.columns([1, 1])\n        with subcol1:\n            st.number_input(\n                \"limit\", min_value=None, max_value=None, value=25, label_visibility=\"collapsed\", key=\"limit\"\n            )\n        with subcol2:",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "run_sql_query",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def run_sql_query():\n    \"\"\"Executes an SQL query and returns the results.\"\"\"\n    st.session_state[\"error\"] = None\n    query = st.session_state.get(\"query\")\n    if query.rstrip().lstrip():\n        exp = st.session_state[\"explorer\"]\n        res = exp.sql_query(query, return_type=\"arrow\")\n        st.session_state[\"imgs\"] = res.to_pydict()[\"im_file\"]\n        st.session_state[\"res\"] = res\ndef run_ai_query():",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "run_ai_query",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def run_ai_query():\n    \"\"\"Execute SQL query and update session state with query results.\"\"\"\n    if not SETTINGS[\"openai_api_key\"]:\n        st.session_state[\"error\"] = (\n            'OpenAI API key not found in settings. Please run yolo settings openai_api_key=\"...\"'\n        )\n        return\n    st.session_state[\"error\"] = None\n    query = st.session_state.get(\"ai_query\")\n    if query.rstrip().lstrip():",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "reset_explorer",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def reset_explorer():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    st.session_state[\"explorer\"] = None\n    st.session_state[\"imgs\"] = None\n    st.session_state[\"error\"] = None\ndef utralytics_explorer_docs_callback():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    with st.container(border=True):\n        st.image(\n            \"https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Original.svg\",",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "utralytics_explorer_docs_callback",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def utralytics_explorer_docs_callback():\n    \"\"\"Resets the explorer to its initial state by clearing session variables.\"\"\"\n    with st.container(border=True):\n        st.image(\n            \"https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Original.svg\",\n            width=100,\n        )\n        st.markdown(\n            \"<p>This demo is built using Ultralytics Explorer API. Visit <a href='https://docs.ultralytics.com/datasets/explorer/'>API docs</a> to try examples & learn more</p>\",\n            unsafe_allow_html=True,",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "layout",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "description": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "peekOfCode": "def layout():\n    \"\"\"Resets explorer session variables and provides documentation with a link to API docs.\"\"\"\n    st.set_page_config(layout=\"wide\", initial_sidebar_state=\"collapsed\")\n    st.markdown(\"<h1 style='text-align: center;'>Ultralytics Explorer Demo</h1>\", unsafe_allow_html=True)\n    if st.session_state.get(\"explorer\") is None:\n        init_explorer_form()\n        return\n    st.button(\":arrow_backward: Select Dataset\", on_click=reset_explorer)\n    exp = st.session_state.get(\"explorer\")\n    col1, col2 = st.columns([0.75, 0.25], gap=\"small\")",
        "detail": "Identification.yolov10.ultralytics.data.explorer.gui.dash",
        "documentation": {}
    },
    {
        "label": "ExplorerDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "description": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "peekOfCode": "class ExplorerDataset(YOLODataset):\n    def __init__(self, *args, data: dict = None, **kwargs) -> None:\n        super().__init__(*args, data=data, **kwargs)\n    def load_image(self, i: int) -> Union[Tuple[np.ndarray, Tuple[int, int], Tuple[int, int]], Tuple[None, None, None]]:\n        \"\"\"Loads 1 image from dataset index 'i' without any resize ops.\"\"\"\n        im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]\n        if im is None:  # not cached in RAM\n            if fn.exists():  # load npy\n                im = np.load(fn)\n            else:  # read image",
        "detail": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "documentation": {}
    },
    {
        "label": "Explorer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "description": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "peekOfCode": "class Explorer:\n    def __init__(\n        self,\n        data: Union[str, Path] = \"coco128.yaml\",\n        model: str = \"yolov8n.pt\",\n        uri: str = USER_CONFIG_DIR / \"explorer\",\n    ) -> None:\n        # Note duckdb==0.10.0 bug https://github.com/ultralytics/ultralytics/pull/8181\n        checks.check_requirements([\"lancedb>=0.4.3\", \"duckdb<=0.9.2\"])\n        import lancedb",
        "detail": "Identification.yolov10.ultralytics.data.explorer.explorer",
        "documentation": {}
    },
    {
        "label": "get_table_schema",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.ultralytics.data.explorer.utils",
        "peekOfCode": "def get_table_schema(vector_size):\n    \"\"\"Extracts and returns the schema of a database table.\"\"\"\n    from lancedb.pydantic import LanceModel, Vector\n    class Schema(LanceModel):\n        im_file: str\n        labels: List[str]\n        cls: List[int]\n        bboxes: List[List[float]]\n        masks: List[List[List[int]]]\n        keypoints: List[List[List[float]]]",
        "detail": "Identification.yolov10.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "get_sim_index_schema",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.ultralytics.data.explorer.utils",
        "peekOfCode": "def get_sim_index_schema():\n    \"\"\"Returns a LanceModel schema for a database table with specified vector size.\"\"\"\n    from lancedb.pydantic import LanceModel\n    class Schema(LanceModel):\n        idx: int\n        im_file: str\n        count: int\n        sim_im_files: List[str]\n    return Schema\ndef sanitize_batch(batch, dataset_info):",
        "detail": "Identification.yolov10.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "sanitize_batch",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.ultralytics.data.explorer.utils",
        "peekOfCode": "def sanitize_batch(batch, dataset_info):\n    \"\"\"Sanitizes input batch for inference, ensuring correct format and dimensions.\"\"\"\n    batch[\"cls\"] = batch[\"cls\"].flatten().int().tolist()\n    box_cls_pair = sorted(zip(batch[\"bboxes\"].tolist(), batch[\"cls\"]), key=lambda x: x[1])\n    batch[\"bboxes\"] = [box for box, _ in box_cls_pair]\n    batch[\"cls\"] = [cls for _, cls in box_cls_pair]\n    batch[\"labels\"] = [dataset_info[\"names\"][i] for i in batch[\"cls\"]]\n    batch[\"masks\"] = batch[\"masks\"].tolist() if \"masks\" in batch else [[[]]]\n    batch[\"keypoints\"] = batch[\"keypoints\"].tolist() if \"keypoints\" in batch else [[[]]]\n    return batch",
        "detail": "Identification.yolov10.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "plot_query_result",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.ultralytics.data.explorer.utils",
        "peekOfCode": "def plot_query_result(similar_set, plot_labels=True):\n    \"\"\"\n    Plot images from the similar set.\n    Args:\n        similar_set (list): Pyarrow or pandas object containing the similar data points\n        plot_labels (bool): Whether to plot labels or not\n    \"\"\"\n    similar_set = (\n        similar_set.to_dict(orient=\"list\") if isinstance(similar_set, pd.DataFrame) else similar_set.to_pydict()\n    )",
        "detail": "Identification.yolov10.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "prompt_sql_query",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.explorer.utils",
        "description": "Identification.yolov10.ultralytics.data.explorer.utils",
        "peekOfCode": "def prompt_sql_query(query):\n    \"\"\"Plots images with optional labels from a similar data set.\"\"\"\n    check_requirements(\"openai>=1.6.1\")\n    from openai import OpenAI\n    if not SETTINGS[\"openai_api_key\"]:\n        logger.warning(\"OpenAI API key not found in settings. Please enter your API key below.\")\n        openai_api_key = getpass.getpass(\"OpenAI API key: \")\n        SETTINGS.update({\"openai_api_key\": openai_api_key})\n    openai = OpenAI(api_key=SETTINGS[\"openai_api_key\"])\n    messages = [",
        "detail": "Identification.yolov10.ultralytics.data.explorer.utils",
        "documentation": {}
    },
    {
        "label": "auto_annotate",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.annotator",
        "description": "Identification.yolov10.ultralytics.data.annotator",
        "peekOfCode": "def auto_annotate(data, det_model=\"yolov8x.pt\", sam_model=\"sam_b.pt\", device=\"\", output_dir=None):\n    \"\"\"\n    Automatically annotates images using a YOLO object detection model and a SAM segmentation model.\n    Args:\n        data (str): Path to a folder containing images to be annotated.\n        det_model (str, optional): Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'.\n        sam_model (str, optional): Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'.\n        device (str, optional): Device to run the models on. Defaults to an empty string (CPU or GPU, if available).\n        output_dir (str | None | optional): Directory to save the annotated results.\n            Defaults to a 'labels' folder in the same directory as 'data'.",
        "detail": "Identification.yolov10.ultralytics.data.annotator",
        "documentation": {}
    },
    {
        "label": "BaseTransform",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.\n        apply_image: Applies image transformation to labels.\n        apply_instances: Applies transformations to object instances in labels.\n        apply_semantic: Applies semantic segmentation to an image.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Compose",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class Compose:\n    \"\"\"Class for composing multiple image transformations.\"\"\"\n    def __init__(self, transforms):\n        \"\"\"Initializes the Compose object with a list of transforms.\"\"\"\n        self.transforms = transforms\n    def __call__(self, data):\n        \"\"\"Applies a series of transformations to input data.\"\"\"\n        for t in self.transforms:\n            data = t(data)\n        return data",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "BaseMixTransform",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class BaseMixTransform:\n    \"\"\"\n    Class for base mix (MixUp/Mosaic) transformations.\n    This implementation is from mmyolo.\n    \"\"\"\n    def __init__(self, dataset, pre_transform=None, p=0.0) -> None:\n        \"\"\"Initializes the BaseMixTransform object with dataset, pre_transform, and probability.\"\"\"\n        self.dataset = dataset\n        self.pre_transform = pre_transform\n        self.p = p",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Mosaic",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class Mosaic(BaseMixTransform):\n    \"\"\"\n    Mosaic augmentation.\n    This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image.\n    The augmentation is applied to a dataset with a given probability.\n    Attributes:\n        dataset: The dataset on which the mosaic augmentation is applied.\n        imgsz (int, optional): Image size (height and width) after mosaic pipeline of a single image. Default to 640.\n        p (float, optional): Probability of applying the mosaic augmentation. Must be in the range 0-1. Default to 1.0.\n        n (int, optional): The grid size, either 4 (for 2x2) or 9 (for 3x3).",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "MixUp",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class MixUp(BaseMixTransform):\n    \"\"\"Class for applying MixUp augmentation to the dataset.\"\"\"\n    def __init__(self, dataset, pre_transform=None, p=0.0) -> None:\n        \"\"\"Initializes MixUp object with dataset, pre_transform, and probability of applying MixUp.\"\"\"\n        super().__init__(dataset=dataset, pre_transform=pre_transform, p=p)\n    def get_indexes(self):\n        \"\"\"Get a random index from the dataset.\"\"\"\n        return random.randint(0, len(self.dataset) - 1)\n    def _mix_transform(self, labels):\n        \"\"\"Applies MixUp augmentation as per https://arxiv.org/pdf/1710.09412.pdf.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomPerspective",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class RandomPerspective:\n    \"\"\"\n    Implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and\n    keypoints. These transformations include rotation, translation, scaling, and shearing. The class also offers the\n    option to apply these transformations conditionally with a specified probability.\n    Attributes:\n        degrees (float): Degree range for random rotations.\n        translate (float): Fraction of total width and height for random translation.\n        scale (float): Scaling factor interval, e.g., a scale factor of 0.1 allows a resize between 90%-110%.\n        shear (float): Shear intensity (angle in degrees).",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomHSV",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class RandomHSV:\n    \"\"\"\n    This class is responsible for performing random adjustments to the Hue, Saturation, and Value (HSV) channels of an\n    image.\n    The adjustments are random but within limits set by hgain, sgain, and vgain.\n    \"\"\"\n    def __init__(self, hgain=0.5, sgain=0.5, vgain=0.5) -> None:\n        \"\"\"\n        Initialize RandomHSV class with gains for each HSV channel.\n        Args:",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "RandomFlip",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class RandomFlip:\n    \"\"\"\n    Applies a random horizontal or vertical flip to an image with a given probability.\n    Also updates any instances (bounding boxes, keypoints, etc.) accordingly.\n    \"\"\"\n    def __init__(self, p=0.5, direction=\"horizontal\", flip_idx=None) -> None:\n        \"\"\"\n        Initializes the RandomFlip class with probability and direction.\n        Args:\n            p (float, optional): The probability of applying the flip. Must be between 0 and 1. Default is 0.5.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "LetterBox",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class LetterBox:\n    \"\"\"Resize image and padding for detection, instance segmentation, pose.\"\"\"\n    def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):\n        \"\"\"Initialize LetterBox object with specific parameters.\"\"\"\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup\n        self.stride = stride\n        self.center = center  # Put the image in the middle or top-left",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "CopyPaste",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class CopyPaste:\n    \"\"\"\n    Implements the Copy-Paste augmentation as described in the paper https://arxiv.org/abs/2012.07177. This class is\n    responsible for applying the Copy-Paste augmentation on images and their corresponding instances.\n    \"\"\"\n    def __init__(self, p=0.5) -> None:\n        \"\"\"\n        Initializes the CopyPaste class with a given probability.\n        Args:\n            p (float, optional): The probability of applying the Copy-Paste augmentation. Must be between 0 and 1.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Albumentations",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class Albumentations:\n    \"\"\"\n    Albumentations transformations.\n    Optional, uninstall package to disable. Applies Blur, Median Blur, convert to grayscale, Contrast Limited Adaptive\n    Histogram Equalization, random change of brightness and contrast, RandomGamma and lowering of image quality by\n    compression.\n    \"\"\"\n    def __init__(self, p=1.0):\n        \"\"\"Initialize the transform object for YOLO bbox formatted params.\"\"\"\n        self.p = p",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class Format:\n    \"\"\"\n    Formats image annotations for object detection, instance segmentation, and pose estimation tasks. The class\n    standardizes the image and instance annotations to be used by the `collate_fn` in PyTorch DataLoader.\n    Attributes:\n        bbox_format (str): Format for bounding boxes. Default is 'xywh'.\n        normalize (bool): Whether to normalize bounding boxes. Default is True.\n        return_mask (bool): Return instance masks for segmentation. Default is False.\n        return_keypoint (bool): Return keypoints for pose estimation. Default is False.\n        mask_ratio (int): Downsample ratio for masks. Default is 4.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "ClassifyLetterBox",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class ClassifyLetterBox:\n    \"\"\"\n    YOLOv8 LetterBox class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([LetterBox(size), ToTensor()]).\n    Attributes:\n        h (int): Target height of the image.\n        w (int): Target width of the image.\n        auto (bool): If True, automatically solves for short side using stride.\n        stride (int): The stride value, used when 'auto' is True.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "CenterCrop",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class CenterCrop:\n    \"\"\"YOLOv8 CenterCrop class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([CenterCrop(size), ToTensor()]).\n    \"\"\"\n    def __init__(self, size=640):\n        \"\"\"Converts an image from numpy array to PyTorch tensor.\"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n    def __call__(self, im):\n        \"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "ToTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "class ToTensor:\n    \"\"\"YOLOv8 ToTensor class for image preprocessing, i.e., T.Compose([LetterBox(size), ToTensor()]).\"\"\"\n    def __init__(self, half=False):\n        \"\"\"Initialize YOLOv8 ToTensor object with optional half-precision support.\"\"\"\n        super().__init__()\n        self.half = half\n    def __call__(self, im):\n        \"\"\"\n        Transforms an image from a numpy array to a PyTorch tensor, applying optional half-precision and normalization.\n        Args:",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "v8_transforms",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "def v8_transforms(dataset, imgsz, hyp, stretch=False):\n    \"\"\"Convert images to a size suitable for YOLOv8 training.\"\"\"\n    pre_transform = Compose(\n        [\n            Mosaic(dataset, imgsz=imgsz, p=hyp.mosaic),\n            CopyPaste(p=hyp.copy_paste),\n            RandomPerspective(\n                degrees=hyp.degrees,\n                translate=hyp.translate,\n                scale=hyp.scale,",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_transforms",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "def classify_transforms(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    interpolation: T.InterpolationMode = T.InterpolationMode.BILINEAR,\n    crop_fraction: float = DEFAULT_CROP_FTACTION,\n):\n    \"\"\"\n    Classification transforms for evaluation/inference. Inspired by timm/data/transforms_factory.py.\n    Args:",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "classify_augmentations",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "def classify_augmentations(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    scale=None,\n    ratio=None,\n    hflip=0.5,\n    vflip=0.0,\n    auto_augment=None,\n    hsv_h=0.015,  # image HSV-Hue augmentation (fraction)",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MEAN",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_MEAN = (0.0, 0.0, 0.0)\nDEFAULT_STD = (1.0, 1.0, 1.0)\nDEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_STD",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_STD = (1.0, 1.0, 1.0)\nDEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CROP_FTACTION",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.augment",
        "description": "Identification.yolov10.ultralytics.data.augment",
        "peekOfCode": "DEFAULT_CROP_FTACTION = 1.0\n# TODO: we might need a BaseTransform to make all these augments be compatible with both classification and semantic\nclass BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n    Methods:\n        __init__: Initializes the BaseTransform object.\n        apply_image: Applies image transformation to labels.",
        "detail": "Identification.yolov10.ultralytics.data.augment",
        "documentation": {}
    },
    {
        "label": "BaseDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.base",
        "description": "Identification.yolov10.ultralytics.data.base",
        "peekOfCode": "class BaseDataset(Dataset):\n    \"\"\"\n    Base dataset class for loading and processing image data.\n    Args:\n        img_path (str): Path to the folder containing images.\n        imgsz (int, optional): Image size. Defaults to 640.\n        cache (bool, optional): Cache images to RAM or disk during training. Defaults to False.\n        augment (bool, optional): If True, data augmentation is applied. Defaults to True.\n        hyp (dict, optional): Hyperparameters to apply data augmentation. Defaults to None.\n        prefix (str, optional): Prefix to print in log messages. Defaults to ''.",
        "detail": "Identification.yolov10.ultralytics.data.base",
        "documentation": {}
    },
    {
        "label": "InfiniteDataLoader",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "class InfiniteDataLoader(dataloader.DataLoader):\n    \"\"\"\n    Dataloader that reuses workers.\n    Uses same syntax as vanilla DataLoader.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"Dataloader that infinitely recycles workers, inherits from DataLoader.\"\"\"\n        super().__init__(*args, **kwargs)\n        object.__setattr__(self, \"batch_sampler\", _RepeatSampler(self.batch_sampler))\n        self.iterator = super().__iter__()",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "_RepeatSampler",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "class _RepeatSampler:\n    \"\"\"\n    Sampler that repeats forever.\n    Args:\n        sampler (Dataset.sampler): The sampler to repeat.\n    \"\"\"\n    def __init__(self, sampler):\n        \"\"\"Initializes an object that repeats a given sampler indefinitely.\"\"\"\n        self.sampler = sampler\n    def __iter__(self):",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "seed_worker",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "def seed_worker(worker_id):  # noqa\n    \"\"\"Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader.\"\"\"\n    worker_seed = torch.initial_seed() % 2**32\n    np.random.seed(worker_seed)\n    random.seed(worker_seed)\ndef build_yolo_dataset(cfg, img_path, batch, data, mode=\"train\", rect=False, stride=32):\n    \"\"\"Build YOLO Dataset.\"\"\"\n    return YOLODataset(\n        img_path=img_path,\n        imgsz=cfg.imgsz,",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "build_yolo_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "def build_yolo_dataset(cfg, img_path, batch, data, mode=\"train\", rect=False, stride=32):\n    \"\"\"Build YOLO Dataset.\"\"\"\n    return YOLODataset(\n        img_path=img_path,\n        imgsz=cfg.imgsz,\n        batch_size=batch,\n        augment=mode == \"train\",  # augmentation\n        hyp=cfg,  # TODO: probably add a get_hyps_from_cfg function\n        rect=cfg.rect or rect,  # rectangular batches\n        cache=cfg.cache or None,",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "build_dataloader",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "def build_dataloader(dataset, batch, workers, shuffle=True, rank=-1):\n    \"\"\"Return an InfiniteDataLoader or DataLoader for training or validation set.\"\"\"\n    batch = min(batch, len(dataset))\n    nd = torch.cuda.device_count()  # number of CUDA devices\n    nw = min([os.cpu_count() // max(nd, 1), workers])  # number of workers\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return InfiniteDataLoader(\n        dataset=dataset,",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "check_source",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "def check_source(source):\n    \"\"\"Check source type and return corresponding flag values.\"\"\"\n    webcam, screenshot, from_img, in_memory, tensor = False, False, False, False, False\n    if isinstance(source, (str, int, Path)):  # int for local usb camera\n        source = str(source)\n        is_file = Path(source).suffix[1:] in (IMG_FORMATS | VID_FORMATS)\n        is_url = source.lower().startswith((\"https://\", \"http://\", \"rtsp://\", \"rtmp://\", \"tcp://\"))\n        webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n        screenshot = source.lower() == \"screen\"\n        if is_url and is_file:",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "load_inference_source",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.build",
        "description": "Identification.yolov10.ultralytics.data.build",
        "peekOfCode": "def load_inference_source(source=None, batch=1, vid_stride=1, buffer=False):\n    \"\"\"\n    Loads an inference source for object detection and applies necessary transformations.\n    Args:\n        source (str, Path, Tensor, PIL.Image, np.ndarray): The input source for inference.\n        batch (int, optional): Batch size for dataloaders. Default is 1.\n        vid_stride (int, optional): The frame interval for video sources. Default is 1.\n        buffer (bool, optional): Determined whether stream frames will be buffered. Default is False.\n    Returns:\n        dataset (Dataset): A dataset object for the specified input source.",
        "detail": "Identification.yolov10.ultralytics.data.build",
        "documentation": {}
    },
    {
        "label": "coco91_to_coco80_class",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def coco91_to_coco80_class():\n    \"\"\"\n    Converts 91-index COCO class IDs to 80-index COCO class IDs.\n    Returns:\n        (list): A list of 91 class IDs where the index represents the 80-index class ID and the value is the\n            corresponding 91-index class ID.\n    \"\"\"\n    return [\n        0,\n        1,",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "coco80_to_coco91_class",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def coco80_to_coco91_class():\n    \"\"\"\n    Converts 80-index (val2014) to 91-index (paper).\n    For details see https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/.\n    Example:\n        ```python\n        import numpy as np\n        a = np.loadtxt('data/coco.names', dtype='str', delimiter='\\n')\n        b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\\n')\n        x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "convert_coco",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def convert_coco(\n    labels_dir=\"../coco/annotations/\",\n    save_dir=\"coco_converted/\",\n    use_segments=False,\n    use_keypoints=False,\n    cls91to80=True,\n):\n    \"\"\"\n    Converts COCO dataset annotations to a YOLO annotation format  suitable for training YOLO models.\n    Args:",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "convert_dota_to_yolo_obb",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def convert_dota_to_yolo_obb(dota_root_path: str):\n    \"\"\"\n    Converts DOTA dataset annotations to YOLO OBB (Oriented Bounding Box) format.\n    The function processes images in the 'train' and 'val' folders of the DOTA dataset. For each image, it reads the\n    associated label from the original labels directory and writes new labels in YOLO OBB format to a new directory.\n    Args:\n        dota_root_path (str): The root directory path of the DOTA dataset.\n    Example:\n        ```python\n        from ultralytics.data.converter import convert_dota_to_yolo_obb",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "min_index",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def min_index(arr1, arr2):\n    \"\"\"\n    Find a pair of indexes with the shortest distance between two arrays of 2D points.\n    Args:\n        arr1 (np.ndarray): A NumPy array of shape (N, 2) representing N 2D points.\n        arr2 (np.ndarray): A NumPy array of shape (M, 2) representing M 2D points.\n    Returns:\n        (tuple): A tuple containing the indexes of the points with the shortest distance in arr1 and arr2 respectively.\n    \"\"\"\n    dis = ((arr1[:, None, :] - arr2[None, :, :]) ** 2).sum(-1)",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "merge_multi_segment",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def merge_multi_segment(segments):\n    \"\"\"\n    Merge multiple segments into one list by connecting the coordinates with the minimum distance between each segment.\n    This function connects these coordinates with a thin line to merge all segments into one.\n    Args:\n        segments (List[List]): Original segmentations in COCO's JSON file.\n                               Each element is a list of coordinates, like [segmentation1, segmentation2,...].\n    Returns:\n        s (List[np.ndarray]): A list of connected segments represented as NumPy arrays.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "yolo_bbox2segment",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.converter",
        "description": "Identification.yolov10.ultralytics.data.converter",
        "peekOfCode": "def yolo_bbox2segment(im_dir, save_dir=None, sam_model=\"sam_b.pt\"):\n    \"\"\"\n    Converts existing object detection dataset (bounding boxes) to segmentation dataset or oriented bounding box (OBB)\n    in YOLO format. Generates segmentation data using SAM auto-annotator as needed.\n    Args:\n        im_dir (str | Path): Path to image directory to convert.\n        save_dir (str | Path): Path to save the generated labels, labels will be saved\n            into `labels-segment` in the same directory level of `im_dir` if save_dir is None. Default: None.\n        sam_model (str): Segmentation model to use for intermediate segmentation data; optional.\n    Notes:",
        "detail": "Identification.yolov10.ultralytics.data.converter",
        "documentation": {}
    },
    {
        "label": "YOLODataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "class YOLODataset(BaseDataset):\n    \"\"\"\n    Dataset class for loading object detection and/or segmentation labels in YOLO format.\n    Args:\n        data (dict, optional): A dataset YAML dictionary. Defaults to None.\n        task (str): An explicit arg to point current task, Defaults to 'detect'.\n    Returns:\n        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.\n    \"\"\"\n    def __init__(self, *args, data=None, task=\"detect\", **kwargs):",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "ClassificationDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "class ClassificationDataset(torchvision.datasets.ImageFolder):\n    \"\"\"\n    Extends torchvision ImageFolder to support YOLO classification tasks, offering functionalities like image\n    augmentation, caching, and verification. It's designed to efficiently handle large datasets for training deep\n    learning models, with optional image transformations and caching mechanisms to speed up training.\n    This class allows for augmentations using both torchvision and Albumentations libraries, and supports caching images\n    in RAM or on disk to reduce IO overhead during training. Additionally, it implements a robust verification process\n    to ensure data integrity and consistency.\n    Attributes:\n        cache_ram (bool): Indicates if caching in RAM is enabled.",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "SemanticDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "class SemanticDataset(BaseDataset):\n    \"\"\"\n    Semantic Segmentation Dataset.\n    This class is responsible for handling datasets used for semantic segmentation tasks. It inherits functionalities\n    from the BaseDataset class.\n    Note:\n        This class is currently a placeholder and needs to be populated with methods and attributes for supporting\n        semantic segmentation tasks.\n    \"\"\"\n    def __init__(self):",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "load_dataset_cache_file",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "def load_dataset_cache_file(path):\n    \"\"\"Load an Ultralytics *.cache dictionary from path.\"\"\"\n    import gc\n    gc.disable()  # reduce pickle load time https://github.com/ultralytics/ultralytics/pull/1585\n    cache = np.load(str(path), allow_pickle=True).item()  # load dict\n    gc.enable()\n    return cache\ndef save_dataset_cache_file(prefix, path, x):\n    \"\"\"Save an Ultralytics dataset *.cache dictionary x to path.\"\"\"\n    x[\"version\"] = DATASET_CACHE_VERSION  # add cache version",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "save_dataset_cache_file",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "def save_dataset_cache_file(prefix, path, x):\n    \"\"\"Save an Ultralytics dataset *.cache dictionary x to path.\"\"\"\n    x[\"version\"] = DATASET_CACHE_VERSION  # add cache version\n    if is_dir_writeable(path.parent):\n        if path.exists():\n            path.unlink()  # remove *.cache file if exists\n        np.save(str(path), x)  # save cache for next time\n        path.with_suffix(\".cache.npy\").rename(path)  # remove .npy suffix\n        LOGGER.info(f\"{prefix}New cache created: {path}\")\n    else:",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "DATASET_CACHE_VERSION",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.dataset",
        "description": "Identification.yolov10.ultralytics.data.dataset",
        "peekOfCode": "DATASET_CACHE_VERSION = \"1.0.3\"\nclass YOLODataset(BaseDataset):\n    \"\"\"\n    Dataset class for loading object detection and/or segmentation labels in YOLO format.\n    Args:\n        data (dict, optional): A dataset YAML dictionary. Defaults to None.\n        task (str): An explicit arg to point current task, Defaults to 'detect'.\n    Returns:\n        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.dataset",
        "documentation": {}
    },
    {
        "label": "SourceTypes",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class SourceTypes:\n    \"\"\"Class to represent various types of input sources for predictions.\"\"\"\n    stream: bool = False\n    screenshot: bool = False\n    from_img: bool = False\n    tensor: bool = False\nclass LoadStreams:\n    \"\"\"\n    Stream Loader for various types of video streams, Supports RTSP, RTMP, HTTP, and TCP streams.\n    Attributes:",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadStreams",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class LoadStreams:\n    \"\"\"\n    Stream Loader for various types of video streams, Supports RTSP, RTMP, HTTP, and TCP streams.\n    Attributes:\n        sources (str): The source input paths or URLs for the video streams.\n        vid_stride (int): Video frame-rate stride, defaults to 1.\n        buffer (bool): Whether to buffer input streams, defaults to False.\n        running (bool): Flag to indicate if the streaming thread is running.\n        mode (str): Set to 'stream' indicating real-time capture.\n        imgs (list): List of image frames for each stream.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadScreenshots",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class LoadScreenshots:\n    \"\"\"\n    YOLOv8 screenshot dataloader.\n    This class manages the loading of screenshot images for processing with YOLOv8.\n    Suitable for use with `yolo predict source=screen`.\n    Attributes:\n        source (str): The source input indicating which screen to capture.\n        screen (int): The screen number to capture.\n        left (int): The left coordinate for screen capture area.\n        top (int): The top coordinate for screen capture area.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadImagesAndVideos",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class LoadImagesAndVideos:\n    \"\"\"\n    YOLOv8 image/video dataloader.\n    This class manages the loading and pre-processing of image and video data for YOLOv8. It supports loading from\n    various formats, including single image files, video files, and lists of image and video paths.\n    Attributes:\n        files (list): List of image and video file paths.\n        nf (int): Total number of files (images and videos).\n        video_flag (list): Flags indicating whether a file is a video (True) or an image (False).\n        mode (str): Current mode, 'image' or 'video'.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadPilAndNumpy",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class LoadPilAndNumpy:\n    \"\"\"\n    Load images from PIL and Numpy arrays for batch processing.\n    This class is designed to manage loading and pre-processing of image data from both PIL and Numpy formats.\n    It performs basic validation and format conversion to ensure that the images are in the required format for\n    downstream processing.\n    Attributes:\n        paths (list): List of image paths or autogenerated filenames.\n        im0 (list): List of images stored as Numpy arrays.\n        mode (str): Type of data being processed, defaults to 'image'.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LoadTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "class LoadTensor:\n    \"\"\"\n    Load images from torch.Tensor data.\n    This class manages the loading and pre-processing of image data from PyTorch tensors for further processing.\n    Attributes:\n        im0 (torch.Tensor): The input tensor containing the image(s).\n        bs (int): Batch size, inferred from the shape of `im0`.\n        mode (str): Current mode, set to 'image'.\n        paths (list): List of image paths or filenames.\n        count (int): Counter for iteration, initialized at 0 during `__iter__()`.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "autocast_list",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "def autocast_list(source):\n    \"\"\"Merges a list of source of different types into a list of numpy arrays or PIL images.\"\"\"\n    files = []\n    for im in source:\n        if isinstance(im, (str, Path)):  # filename or uri\n            files.append(Image.open(requests.get(im, stream=True).raw if str(im).startswith(\"http\") else im))\n        elif isinstance(im, (Image.Image, np.ndarray)):  # PIL or np Image\n            files.append(im)\n        else:\n            raise TypeError(",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "get_best_youtube_url",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "def get_best_youtube_url(url, use_pafy=True):\n    \"\"\"\n    Retrieves the URL of the best quality MP4 video stream from a given YouTube video.\n    This function uses the pafy or yt_dlp library to extract the video info from YouTube. It then finds the highest\n    quality MP4 format that has video codec but no audio codec, and returns the URL of this video stream.\n    Args:\n        url (str): The URL of the YouTube video.\n        use_pafy (bool): Use the pafy package, default=True, otherwise use yt_dlp package.\n    Returns:\n        (str): The URL of the best quality MP4 video stream, or None if no suitable stream is found.",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "LOADERS",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.loaders",
        "description": "Identification.yolov10.ultralytics.data.loaders",
        "peekOfCode": "LOADERS = (LoadStreams, LoadPilAndNumpy, LoadImagesAndVideos, LoadScreenshots)",
        "detail": "Identification.yolov10.ultralytics.data.loaders",
        "documentation": {}
    },
    {
        "label": "bbox_iof",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def bbox_iof(polygon1, bbox2, eps=1e-6):\n    \"\"\"\n    Calculate iofs between bbox1 and bbox2.\n    Args:\n        polygon1 (np.ndarray): Polygon coordinates, (n, 8).\n        bbox2 (np.ndarray): Bounding boxes, (n ,4).\n    \"\"\"\n    polygon1 = polygon1.reshape(-1, 4, 2)\n    lt_point = np.min(polygon1, axis=-2)\n    rb_point = np.max(polygon1, axis=-2)",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "load_yolo_dota",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def load_yolo_dota(data_root, split=\"train\"):\n    \"\"\"\n    Load DOTA dataset.\n    Args:\n        data_root (str): Data root.\n        split (str): The split data set, could be train or val.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "get_windows",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def get_windows(im_size, crop_sizes=[1024], gaps=[200], im_rate_thr=0.6, eps=0.01):\n    \"\"\"\n    Get the coordinates of windows.\n    Args:\n        im_size (tuple): Original image size, (h, w).\n        crop_sizes (List(int)): Crop size of windows.\n        gaps (List(int)): Gap between crops.\n        im_rate_thr (float): Threshold of windows areas divided by image ares.\n    \"\"\"\n    h, w = im_size",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "get_window_obj",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def get_window_obj(anno, windows, iof_thr=0.7):\n    \"\"\"Get objects for each window.\"\"\"\n    h, w = anno[\"ori_size\"]\n    label = anno[\"label\"]\n    if len(label):\n        label[:, 1::2] *= w\n        label[:, 2::2] *= h\n        iofs = bbox_iof(label[:, 1:], windows)\n        # Unnormalized and misaligned coordinates\n        return [(label[iofs[:, i] >= iof_thr]) for i in range(len(windows))]  # window_anns",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "crop_and_save",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def crop_and_save(anno, windows, window_objs, im_dir, lb_dir):\n    \"\"\"\n    Crop images and save new labels.\n    Args:\n        anno (dict): Annotation dict, including `filepath`, `label`, `ori_size` as its keys.\n        windows (list): A list of windows coordinates.\n        window_objs (list): A list of labels inside each window.\n        im_dir (str): The output directory path of images.\n        lb_dir (str): The output directory path of labels.\n    Notes:",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_images_and_labels",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def split_images_and_labels(data_root, save_dir, split=\"train\", crop_sizes=[1024], gaps=[200]):\n    \"\"\"\n    Split both images and labels.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - split\n                - labels\n                    - split",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_trainval",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def split_trainval(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split train and val set of DOTA.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - train\n                    - val\n                - labels",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "split_test",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.split_dota",
        "description": "Identification.yolov10.ultralytics.data.split_dota",
        "peekOfCode": "def split_test(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split test set of DOTA, labels are not included within this set.\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - test\n        and the output directory structure is:\n            - save_dir",
        "detail": "Identification.yolov10.ultralytics.data.split_dota",
        "documentation": {}
    },
    {
        "label": "HUBDatasetStats",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "class HUBDatasetStats:\n    \"\"\"\n    A class for generating HUB dataset JSON and `-hub` dataset directory.\n    Args:\n        path (str): Path to data.yaml or data.zip (with data.yaml inside data.zip). Default is 'coco8.yaml'.\n        task (str): Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Default is 'detect'.\n        autodownload (bool): Attempt to download dataset if not found locally. Default is False.\n    Example:\n        Download *.zip files from https://github.com/ultralytics/hub/tree/main/example_datasets\n            i.e. https://github.com/ultralytics/hub/raw/main/example_datasets/coco8.zip for coco8.zip.",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "img2label_paths",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "get_hash",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash\ndef exif_size(img: Image.Image):\n    \"\"\"Returns exif-corrected PIL size.\"\"\"\n    s = img.size  # (width, height)\n    if img.format == \"JPEG\":  # only support JPEG images",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "exif_size",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def exif_size(img: Image.Image):\n    \"\"\"Returns exif-corrected PIL size.\"\"\"\n    s = img.size  # (width, height)\n    if img.format == \"JPEG\":  # only support JPEG images\n        with contextlib.suppress(Exception):\n            exif = img.getexif()\n            if exif:\n                rotation = exif.get(274, None)  # the EXIF key for the orientation tag is 274\n                if rotation in [6, 8]:  # rotation 270 or 90\n                    s = s[1], s[0]",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "verify_image",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def verify_image(args):\n    \"\"\"Verify one image.\"\"\"\n    (im_file, cls), prefix = args\n    # Number (found, corrupt), message\n    nf, nc, msg = 0, 0, \"\"\n    try:\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size\n        shape = (shape[1], shape[0])  # hw",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "verify_image_label",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def verify_image_label(args):\n    \"\"\"Verify one image-label pair.\"\"\"\n    im_file, lb_file, prefix, keypoint, num_cls, nkpt, ndim = args\n    # Number (missing, found, empty, corrupt), message, segments, keypoints\n    nm, nf, ne, nc, msg, segments, keypoints = 0, 0, 0, 0, \"\", [], None\n    try:\n        # Verify images\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygon2mask",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def polygon2mask(imgsz, polygons, color=1, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a binary mask of the specified image size.\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int, optional): The color value to fill in the polygons on the mask. Defaults to 1.\n        downsample_ratio (int, optional): Factor by which to downsample the mask. Defaults to 1.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygons2masks",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def polygons2masks(imgsz, polygons, color, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a set of binary masks of the specified image size.\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int): The color value to fill in the polygons on the masks.\n        downsample_ratio (int, optional): Factor by which to downsample each mask. Defaults to 1.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "polygons2masks_overlap",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def polygons2masks_overlap(imgsz, segments, downsample_ratio=1):\n    \"\"\"Return a (640, 640) overlap mask.\"\"\"\n    masks = np.zeros(\n        (imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio),\n        dtype=np.int32 if len(segments) > 255 else np.uint8,\n    )\n    areas = []\n    ms = []\n    for si in range(len(segments)):\n        mask = polygon2mask(imgsz, [segments[si].reshape(-1)], downsample_ratio=downsample_ratio, color=1)",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "find_dataset_yaml",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def find_dataset_yaml(path: Path) -> Path:\n    \"\"\"\n    Find and return the YAML file associated with a Detect, Segment or Pose dataset.\n    This function searches for a YAML file at the root level of the provided directory first, and if not found, it\n    performs a recursive search. It prefers YAML files that have the same stem as the provided path. An AssertionError\n    is raised if no YAML file is found or if multiple YAML files are found.\n    Args:\n        path (Path): The directory path to search for the YAML file.\n    Returns:\n        (Path): The path of the found YAML file.",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_det_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def check_det_dataset(dataset, autodownload=True):\n    \"\"\"\n    Download, verify, and/or unzip a dataset if not found locally.\n    This function checks the availability of a specified dataset, and if not found, it has the option to download and\n    unzip the dataset. It then reads and parses the accompanying YAML data, ensuring key requirements are met and also\n    resolves paths related to the dataset.\n    Args:\n        dataset (str): Path to the dataset or dataset descriptor (like a YAML file).\n        autodownload (bool, optional): Whether to automatically download the dataset if not found. Defaults to True.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "check_cls_dataset",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def check_cls_dataset(dataset, split=\"\"):\n    \"\"\"\n    Checks a classification dataset such as Imagenet.\n    This function accepts a `dataset` name and attempts to retrieve the corresponding dataset information.\n    If the dataset is not found locally, it attempts to download the dataset from the internet and save it locally.\n    Args:\n        dataset (str | Path): The name of the dataset.\n        split (str, optional): The split of the dataset. Either 'val', 'test', or ''. Defaults to ''.\n    Returns:\n        (dict): A dictionary containing the following keys:",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "compress_one_image",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def compress_one_image(f, f_new=None, max_dim=1920, quality=50):\n    \"\"\"\n    Compresses a single image file to reduced size while preserving its aspect ratio and quality using either the Python\n    Imaging Library (PIL) or OpenCV library. If the input image is smaller than the maximum dimension, it will not be\n    resized.\n    Args:\n        f (str): The path to the input image file.\n        f_new (str, optional): The path to the output image file. If not specified, the input file will be overwritten.\n        max_dim (int, optional): The maximum dimension (width or height) of the output image. Default is 1920 pixels.\n        quality (int, optional): The image compression quality as a percentage. Default is 50%.",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "autosplit",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "def autosplit(path=DATASETS_DIR / \"coco8/images\", weights=(0.9, 0.1, 0.0), annotated_only=False):\n    \"\"\"\n    Automatically split a dataset into train/val/test splits and save the resulting splits into autosplit_*.txt files.\n    Args:\n        path (Path, optional): Path to images directory. Defaults to DATASETS_DIR / 'coco8/images'.\n        weights (list | tuple, optional): Train, validation, and test split fractions. Defaults to (0.9, 0.1, 0.0).\n        annotated_only (bool, optional): If True, only images with an associated txt file are used. Defaults to False.\n    Example:\n        ```python\n        from ultralytics.data.utils import autosplit",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "HELP_URL",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "HELP_URL = \"See https://docs.ultralytics.com/datasets/detect for dataset formatting guidance.\"\nIMG_FORMATS = {\"bmp\", \"dng\", \"jpeg\", \"jpg\", \"mpo\", \"png\", \"tif\", \"tiff\", \"webp\", \"pfm\"}  # image suffixes\nVID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "IMG_FORMATS",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "IMG_FORMATS = {\"bmp\", \"dng\", \"jpeg\", \"jpg\", \"mpo\", \"png\", \"tif\", \"tiff\", \"webp\", \"pfm\"}  # image suffixes\nVID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "VID_FORMATS",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "VID_FORMATS = {\"asf\", \"avi\", \"gif\", \"m4v\", \"mkv\", \"mov\", \"mp4\", \"mpeg\", \"mpg\", \"ts\", \"wmv\", \"webm\"}  # video suffixes\nPIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "PIN_MEMORY",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.data.utils",
        "description": "Identification.yolov10.ultralytics.data.utils",
        "peekOfCode": "PIN_MEMORY = str(os.getenv(\"PIN_MEMORY\", True)).lower() == \"true\"  # global pin_memory for dataloaders\ndef img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\ndef get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths",
        "detail": "Identification.yolov10.ultralytics.data.utils",
        "documentation": {}
    },
    {
        "label": "Exporter",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.exporter",
        "description": "Identification.yolov10.ultralytics.engine.exporter",
        "peekOfCode": "class Exporter:\n    \"\"\"\n    A class for exporting a model.\n    Attributes:\n        args (SimpleNamespace): Configuration for the exporter.\n        callbacks (list, optional): List of callback functions. Defaults to None.\n    \"\"\"\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the Exporter class.",
        "detail": "Identification.yolov10.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "IOSDetectModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.exporter",
        "description": "Identification.yolov10.ultralytics.engine.exporter",
        "peekOfCode": "class IOSDetectModel(torch.nn.Module):\n    \"\"\"Wrap an Ultralytics YOLO model for Apple iOS CoreML export.\"\"\"\n    def __init__(self, model, im):\n        \"\"\"Initialize the IOSDetectModel class with a YOLO model and example image.\"\"\"\n        super().__init__()\n        _, _, h, w = im.shape  # batch, channel, height, width\n        self.model = model\n        self.nc = len(model.names)  # number of classes\n        if w == h:\n            self.normalize = 1.0 / w  # scalar",
        "detail": "Identification.yolov10.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "export_formats",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.engine.exporter",
        "description": "Identification.yolov10.ultralytics.engine.exporter",
        "peekOfCode": "def export_formats():\n    \"\"\"YOLOv8 export formats.\"\"\"\n    import pandas\n    x = [\n        [\"PyTorch\", \"-\", \".pt\", True, True],\n        [\"TorchScript\", \"torchscript\", \".torchscript\", True, True],\n        [\"ONNX\", \"onnx\", \".onnx\", True, True],\n        [\"OpenVINO\", \"openvino\", \"_openvino_model\", True, False],\n        [\"TensorRT\", \"engine\", \".engine\", False, True],\n        [\"CoreML\", \"coreml\", \".mlpackage\", True, False],",
        "detail": "Identification.yolov10.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "gd_outputs",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.engine.exporter",
        "description": "Identification.yolov10.ultralytics.engine.exporter",
        "peekOfCode": "def gd_outputs(gd):\n    \"\"\"TensorFlow GraphDef model output node names.\"\"\"\n    name_list, input_list = [], []\n    for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n        name_list.append(node.name)\n        input_list.extend(node.input)\n    return sorted(f\"{x}:0\" for x in list(set(name_list) - set(input_list)) if not x.startswith(\"NoOp\"))\ndef try_export(inner_func):\n    \"\"\"YOLOv8 export decorator, i..e @try_export.\"\"\"\n    inner_args = get_default_args(inner_func)",
        "detail": "Identification.yolov10.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "try_export",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.engine.exporter",
        "description": "Identification.yolov10.ultralytics.engine.exporter",
        "peekOfCode": "def try_export(inner_func):\n    \"\"\"YOLOv8 export decorator, i..e @try_export.\"\"\"\n    inner_args = get_default_args(inner_func)\n    def outer_func(*args, **kwargs):\n        \"\"\"Export a model.\"\"\"\n        prefix = inner_args[\"prefix\"]\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f\"{prefix} export success  {dt.t:.1f}s, saved as '{f}' ({file_size(f):.1f} MB)\")",
        "detail": "Identification.yolov10.ultralytics.engine.exporter",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.model",
        "description": "Identification.yolov10.ultralytics.engine.model",
        "peekOfCode": "class Model(nn.Module):\n    \"\"\"\n    A base class for implementing YOLO models, unifying APIs across different model types.\n    This class provides a common interface for various operations related to YOLO models, such as training,\n    validation, prediction, exporting, and benchmarking. It handles different types of models, including those\n    loaded from local files, Ultralytics HUB, or Triton Server. The class is designed to be flexible and\n    extendable for different tasks and model configurations.\n    Args:\n        model (Union[str, Path], optional): Path or name of the model to load or create. This can be a local file\n            path, a model name from Ultralytics HUB, or a Triton Server model. Defaults to 'yolov8n.pt'.",
        "detail": "Identification.yolov10.ultralytics.engine.model",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.predictor",
        "description": "Identification.yolov10.ultralytics.engine.predictor",
        "peekOfCode": "class BasePredictor:\n    \"\"\"\n    BasePredictor.\n    A base class for creating predictors.\n    Attributes:\n        args (SimpleNamespace): Configuration for the predictor.\n        save_dir (Path): Directory to save results.\n        done_warmup (bool): Whether the predictor has finished setup.\n        model (nn.Module): Model used for prediction.\n        data (dict): Data configuration.",
        "detail": "Identification.yolov10.ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "STREAM_WARNING",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.engine.predictor",
        "description": "Identification.yolov10.ultralytics.engine.predictor",
        "peekOfCode": "STREAM_WARNING = \"\"\"\nWARNING  inference results will accumulate in RAM unless `stream=True` is passed, causing potential out-of-memory\nerrors for large sources or long-running streams and videos. See https://docs.ultralytics.com/modes/predict/ for help.\nExample:\n    results = model(source=..., stream=True)  # generator of Results objects\n    for r in results:\n        boxes = r.boxes  # Boxes object for bbox outputs\n        masks = r.masks  # Masks object for segment masks outputs\n        probs = r.probs  # Class probabilities for classification outputs\n\"\"\"",
        "detail": "Identification.yolov10.ultralytics.engine.predictor",
        "documentation": {}
    },
    {
        "label": "BaseTensor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class BaseTensor(SimpleClass):\n    \"\"\"Base tensor class with additional methods for easy manipulation and device handling.\"\"\"\n    def __init__(self, data, orig_shape) -> None:\n        \"\"\"\n        Initialize BaseTensor with data and original shape.\n        Args:\n            data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.\n            orig_shape (tuple): Original shape of image.\n        \"\"\"\n        assert isinstance(data, (torch.Tensor, np.ndarray))",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Results",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class Results(SimpleClass):\n    \"\"\"\n    A class for storing and manipulating inference results.\n    Attributes:\n        orig_img (numpy.ndarray): Original image as a numpy array.\n        orig_shape (tuple): Original image shape in (height, width) format.\n        boxes (Boxes, optional): Object containing detection bounding boxes.\n        masks (Masks, optional): Object containing detection masks.\n        probs (Probs, optional): Object containing class probabilities for classification tasks.\n        keypoints (Keypoints, optional): Object containing detected keypoints for each object.",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Boxes",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class Boxes(BaseTensor):\n    \"\"\"\n    Manages detection boxes, providing easy access and manipulation of box coordinates, confidence scores, class\n    identifiers, and optional tracking IDs. Supports multiple formats for box coordinates, including both absolute and\n    normalized forms.\n    Attributes:\n        data (torch.Tensor): The raw tensor containing detection boxes and their associated data.\n        orig_shape (tuple): The original image size as a tuple (height, width), used for normalization.\n        is_track (bool): Indicates whether tracking IDs are included in the box data.\n    Properties:",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Masks",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class Masks(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection masks.\n    Attributes:\n        xy (list): A list of segments in pixel coordinates.\n        xyn (list): A list of normalized segments.\n    Methods:\n        cpu(): Returns the masks tensor on CPU memory.\n        numpy(): Returns the masks tensor as a numpy array.\n        cuda(): Returns the masks tensor on GPU memory.",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Keypoints",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class Keypoints(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection keypoints.\n    Attributes:\n        xy (torch.Tensor): A collection of keypoints containing x, y coordinates for each detection.\n        xyn (torch.Tensor): A normalized version of xy with coordinates in the range [0, 1].\n        conf (torch.Tensor): Confidence values associated with keypoints if available, otherwise None.\n    Methods:\n        cpu(): Returns a copy of the keypoints tensor on CPU memory.\n        numpy(): Returns a copy of the keypoints tensor as a numpy array.",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "Probs",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class Probs(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating classification predictions.\n    Attributes:\n        top1 (int): Index of the top 1 class.\n        top5 (list[int]): Indices of the top 5 classes.\n        top1conf (torch.Tensor): Confidence of the top 1 class.\n        top5conf (torch.Tensor): Confidences of the top 5 classes.\n    Methods:\n        cpu(): Returns a copy of the probs tensor on CPU memory.",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "OBB",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.results",
        "description": "Identification.yolov10.ultralytics.engine.results",
        "peekOfCode": "class OBB(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating Oriented Bounding Boxes (OBB).\n    Args:\n        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,\n            with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values.\n            If present, the third last column contains track IDs, and the fifth column from the left contains rotation.\n        orig_shape (tuple): Original image size, in the format (height, width).\n    Attributes:\n        xywhr (torch.Tensor | numpy.ndarray): The boxes in [x_center, y_center, width, height, rotation] format.",
        "detail": "Identification.yolov10.ultralytics.engine.results",
        "documentation": {}
    },
    {
        "label": "BaseTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.trainer",
        "description": "Identification.yolov10.ultralytics.engine.trainer",
        "peekOfCode": "class BaseTrainer:\n    \"\"\"\n    BaseTrainer.\n    A base class for creating trainers.\n    Attributes:\n        args (SimpleNamespace): Configuration for the trainer.\n        validator (BaseValidator): Validator instance.\n        model (nn.Module): Model instance.\n        callbacks (defaultdict): Dictionary of callbacks.\n        save_dir (Path): Directory to save results.",
        "detail": "Identification.yolov10.ultralytics.engine.trainer",
        "documentation": {}
    },
    {
        "label": "Tuner",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.tuner",
        "description": "Identification.yolov10.ultralytics.engine.tuner",
        "peekOfCode": "class Tuner:\n    \"\"\"\n    Class responsible for hyperparameter tuning of YOLO models.\n    The class evolves YOLO model hyperparameters over a given number of iterations\n    by mutating them according to the search space and retraining the model to evaluate their performance.\n    Attributes:\n        space (dict): Hyperparameter search space containing bounds and scaling factors for mutation.\n        tune_dir (Path): Directory where evolution logs and results will be saved.\n        tune_csv (Path): Path to the CSV file where evolution logs are saved.\n    Methods:",
        "detail": "Identification.yolov10.ultralytics.engine.tuner",
        "documentation": {}
    },
    {
        "label": "BaseValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.engine.validator",
        "description": "Identification.yolov10.ultralytics.engine.validator",
        "peekOfCode": "class BaseValidator:\n    \"\"\"\n    BaseValidator.\n    A base class for creating validators.\n    Attributes:\n        args (SimpleNamespace): Configuration for the validator.\n        dataloader (DataLoader): Dataloader to use for validation.\n        pbar (tqdm): Progress bar to update during validation.\n        model (nn.Module): Model to validate.\n        data (dict): Data dictionary.",
        "detail": "Identification.yolov10.ultralytics.engine.validator",
        "documentation": {}
    },
    {
        "label": "Auth",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.hub.auth",
        "description": "Identification.yolov10.ultralytics.hub.auth",
        "peekOfCode": "class Auth:\n    \"\"\"\n    Manages authentication processes including API key handling, cookie-based authentication, and header generation.\n    The class supports different methods of authentication:\n    1. Directly using an API key.\n    2. Authenticating using browser cookies (specifically in Google Colab).\n    3. Prompting the user to enter an API key.\n    Attributes:\n        id_token (str or bool): Token used for identity verification, initialized as False.\n        api_key (str or bool): API key for authentication, initialized as False.",
        "detail": "Identification.yolov10.ultralytics.hub.auth",
        "documentation": {}
    },
    {
        "label": "API_KEY_URL",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.auth",
        "description": "Identification.yolov10.ultralytics.hub.auth",
        "peekOfCode": "API_KEY_URL = f\"{HUB_WEB_ROOT}/settings?tab=api+keys\"\nclass Auth:\n    \"\"\"\n    Manages authentication processes including API key handling, cookie-based authentication, and header generation.\n    The class supports different methods of authentication:\n    1. Directly using an API key.\n    2. Authenticating using browser cookies (specifically in Google Colab).\n    3. Prompting the user to enter an API key.\n    Attributes:\n        id_token (str or bool): Token used for identity verification, initialized as False.",
        "detail": "Identification.yolov10.ultralytics.hub.auth",
        "documentation": {}
    },
    {
        "label": "HUBTrainingSession",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.hub.session",
        "description": "Identification.yolov10.ultralytics.hub.session",
        "peekOfCode": "class HUBTrainingSession:\n    \"\"\"\n    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.\n    Attributes:\n        agent_id (str): Identifier for the instance communicating with the server.\n        model_id (str): Identifier for the YOLO model being trained.\n        model_url (str): URL for the model in Ultralytics HUB.\n        api_url (str): API URL for the model in Ultralytics HUB.\n        auth_header (dict): Authentication header for the Ultralytics HUB API requests.\n        rate_limits (dict): Rate limits for different API calls (in seconds).",
        "detail": "Identification.yolov10.ultralytics.hub.session",
        "documentation": {}
    },
    {
        "label": "AGENT_NAME",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.session",
        "description": "Identification.yolov10.ultralytics.hub.session",
        "peekOfCode": "AGENT_NAME = f\"python-{__version__}-colab\" if is_colab() else f\"python-{__version__}-local\"\nclass HUBTrainingSession:\n    \"\"\"\n    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.\n    Attributes:\n        agent_id (str): Identifier for the instance communicating with the server.\n        model_id (str): Identifier for the YOLO model being trained.\n        model_url (str): URL for the model in Ultralytics HUB.\n        api_url (str): API URL for the model in Ultralytics HUB.\n        auth_header (dict): Authentication header for the Ultralytics HUB API requests.",
        "detail": "Identification.yolov10.ultralytics.hub.session",
        "documentation": {}
    },
    {
        "label": "Events",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "class Events:\n    \"\"\"\n    A class for collecting anonymous event analytics. Event analytics are enabled when sync=True in settings and\n    disabled when sync=False. Run 'yolo settings' to see and update settings YAML file.\n    Attributes:\n        url (str): The URL to send anonymous events.\n        rate_limit (float): The rate limit in seconds for sending events.\n        metadata (dict): A dictionary containing metadata about the environment.\n        enabled (bool): A flag to enable or disable Events based on certain conditions.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "request_with_credentials",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "def request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:\n        OSError: If the function is not run in a Google Colab environment.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "requests_with_progress",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "def requests_with_progress(method, url, **kwargs):\n    \"\"\"\n    Make an HTTP request using the specified method and URL, with an optional progress bar.\n    Args:\n        method (str): The HTTP method to use (e.g. 'GET', 'POST').\n        url (str): The URL to send the request to.\n        **kwargs (any): Additional keyword arguments to pass to the underlying `requests.request` function.\n    Returns:\n        (requests.Response): The response object from the HTTP request.\n    Note:",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "smart_request",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "def smart_request(method, url, retry=3, timeout=30, thread=True, code=-1, verbose=True, progress=False, **kwargs):\n    \"\"\"\n    Makes an HTTP request using the 'requests' library, with exponential backoff retries up to a specified timeout.\n    Args:\n        method (str): The HTTP method to use for the request. Choices are 'post' and 'get'.\n        url (str): The URL to make the request to.\n        retry (int, optional): Number of retries to attempt before giving up. Default is 3.\n        timeout (int, optional): Timeout in seconds after which the function will give up retrying. Default is 30.\n        thread (bool, optional): Whether to execute the request in a separate daemon thread. Default is True.\n        code (int, optional): An identifier for the request, used for logging purposes. Default is -1.",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_API_ROOT",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "HUB_API_ROOT = os.environ.get(\"ULTRALYTICS_HUB_API\", \"https://api.ultralytics.com\")\nHUB_WEB_ROOT = os.environ.get(\"ULTRALYTICS_HUB_WEB\", \"https://hub.ultralytics.com\")\nPREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HUB_WEB_ROOT",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "HUB_WEB_ROOT = os.environ.get(\"ULTRALYTICS_HUB_WEB\", \"https://hub.ultralytics.com\")\nPREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "PREFIX",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "PREFIX = colorstr(\"Ultralytics HUB: \")\nHELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "HELP_MSG",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "HELP_MSG = \"If this issue persists please visit https://github.com/ultralytics/hub/issues for assistance.\"\ndef request_with_credentials(url: str) -> any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n    Args:\n        url (str): The URL to make the request to.\n    Returns:\n        (any): The response data from the AJAX request.\n    Raises:\n        OSError: If the function is not run in a Google Colab environment.",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "events",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.hub.utils",
        "description": "Identification.yolov10.ultralytics.hub.utils",
        "peekOfCode": "events = Events()",
        "detail": "Identification.yolov10.ultralytics.hub.utils",
        "documentation": {}
    },
    {
        "label": "FastSAM",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.model",
        "description": "Identification.yolov10.ultralytics.models.fastsam.model",
        "peekOfCode": "class FastSAM(Model):\n    \"\"\"\n    FastSAM model interface.\n    Example:\n        ```python\n        from ultralytics import FastSAM\n        model = FastSAM('last.pt')\n        results = model.predict('ultralytics/assets/bus.jpg')\n        ```\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.model",
        "documentation": {}
    },
    {
        "label": "FastSAMPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.predict",
        "description": "Identification.yolov10.ultralytics.models.fastsam.predict",
        "peekOfCode": "class FastSAMPredictor(DetectionPredictor):\n    \"\"\"\n    FastSAMPredictor is specialized for fast SAM (Segment Anything Model) segmentation prediction tasks in Ultralytics\n    YOLO framework.\n    This class extends the DetectionPredictor, customizing the prediction pipeline specifically for fast SAM.\n    It adjusts post-processing steps to incorporate mask prediction and non-max suppression while optimizing\n    for single-class segmentation.\n    Attributes:\n        cfg (dict): Configuration parameters for prediction.\n        overrides (dict, optional): Optional parameter overrides for custom behavior.",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.predict",
        "documentation": {}
    },
    {
        "label": "FastSAMPrompt",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.prompt",
        "description": "Identification.yolov10.ultralytics.models.fastsam.prompt",
        "peekOfCode": "class FastSAMPrompt:\n    \"\"\"\n    Fast Segment Anything Model class for image annotation and visualization.\n    Attributes:\n        device (str): Computing device ('cuda' or 'cpu').\n        results: Object detection or segmentation results.\n        source: Source image or image path.\n        clip: CLIP model for linear assignment.\n    \"\"\"\n    def __init__(self, source, results, device=\"cuda\") -> None:",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.prompt",
        "documentation": {}
    },
    {
        "label": "adjust_bboxes_to_image_border",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "description": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "peekOfCode": "def adjust_bboxes_to_image_border(boxes, image_shape, threshold=20):\n    \"\"\"\n    Adjust bounding boxes to stick to image border if they are within a certain threshold.\n    Args:\n        boxes (torch.Tensor): (n, 4)\n        image_shape (tuple): (height, width)\n        threshold (int): pixel threshold\n    Returns:\n        adjusted_boxes (torch.Tensor): adjusted bounding boxes\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "description": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "peekOfCode": "def bbox_iou(box1, boxes, iou_thres=0.9, image_shape=(640, 640), raw_output=False):\n    \"\"\"\n    Compute the Intersection-Over-Union of a bounding box with respect to an array of other bounding boxes.\n    Args:\n        box1 (torch.Tensor): (4, )\n        boxes (torch.Tensor): (n, 4)\n        iou_thres (float): IoU threshold\n        image_shape (tuple): (height, width)\n        raw_output (bool): If True, return the raw IoU values instead of the indices\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.utils",
        "documentation": {}
    },
    {
        "label": "FastSAMValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.fastsam.val",
        "description": "Identification.yolov10.ultralytics.models.fastsam.val",
        "peekOfCode": "class FastSAMValidator(SegmentationValidator):\n    \"\"\"\n    Custom validation class for fast SAM (Segment Anything Model) segmentation in Ultralytics YOLO framework.\n    Extends the SegmentationValidator class, customizing the validation process specifically for fast SAM. This class\n    sets the task to 'segment' and uses the SegmentMetrics for evaluation. Additionally, plotting features are disabled\n    to avoid errors during validation.\n    Attributes:\n        dataloader: The data loader object used for validation.\n        save_dir (str): The directory where validation results will be saved.\n        pbar: A progress bar object.",
        "detail": "Identification.yolov10.ultralytics.models.fastsam.val",
        "documentation": {}
    },
    {
        "label": "NAS",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.nas.model",
        "description": "Identification.yolov10.ultralytics.models.nas.model",
        "peekOfCode": "class NAS(Model):\n    \"\"\"\n    YOLO NAS model for object detection.\n    This class provides an interface for the YOLO-NAS models and extends the `Model` class from Ultralytics engine.\n    It is designed to facilitate the task of object detection using pre-trained or custom-trained YOLO-NAS models.\n    Example:\n        ```python\n        from ultralytics import NAS\n        model = NAS('yolo_nas_s')\n        results = model.predict('ultralytics/assets/bus.jpg')",
        "detail": "Identification.yolov10.ultralytics.models.nas.model",
        "documentation": {}
    },
    {
        "label": "NASPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.nas.predict",
        "description": "Identification.yolov10.ultralytics.models.nas.predict",
        "peekOfCode": "class NASPredictor(BasePredictor):\n    \"\"\"\n    Ultralytics YOLO NAS Predictor for object detection.\n    This class extends the `BasePredictor` from Ultralytics engine and is responsible for post-processing the\n    raw predictions generated by the YOLO NAS models. It applies operations like non-maximum suppression and\n    scaling the bounding boxes to fit the original image dimensions.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.models.nas.predict",
        "documentation": {}
    },
    {
        "label": "NASValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.nas.val",
        "description": "Identification.yolov10.ultralytics.models.nas.val",
        "peekOfCode": "class NASValidator(DetectionValidator):\n    \"\"\"\n    Ultralytics YOLO NAS Validator for object detection.\n    Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions\n    generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes,\n    ultimately producing the final detections.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.\n        lb (torch.Tensor): Optional tensor for multilabel NMS.\n    Example:",
        "detail": "Identification.yolov10.ultralytics.models.nas.val",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.nas.val",
        "description": "Identification.yolov10.ultralytics.models.nas.val",
        "peekOfCode": "__all__ = [\"NASValidator\"]\nclass NASValidator(DetectionValidator):\n    \"\"\"\n    Ultralytics YOLO NAS Validator for object detection.\n    Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions\n    generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes,\n    ultimately producing the final detections.\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.\n        lb (torch.Tensor): Optional tensor for multilabel NMS.",
        "detail": "Identification.yolov10.ultralytics.models.nas.val",
        "documentation": {}
    },
    {
        "label": "RTDETR",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.model",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.model",
        "peekOfCode": "class RTDETR(Model):\n    \"\"\"\n    Interface for Baidu's RT-DETR model. This Vision Transformer-based object detector provides real-time performance\n    with high accuracy. It supports efficient hybrid encoding, IoU-aware query selection, and adaptable inference speed.\n    Attributes:\n        model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.\n    \"\"\"\n    def __init__(self, model=\"rtdetr-l.pt\") -> None:\n        \"\"\"\n        Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.model",
        "documentation": {}
    },
    {
        "label": "RTDETRPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.predict",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.predict",
        "peekOfCode": "class RTDETRPredictor(BasePredictor):\n    \"\"\"\n    RT-DETR (Real-Time Detection Transformer) Predictor extending the BasePredictor class for making predictions using\n    Baidu's RT-DETR model.\n    This class leverages the power of Vision Transformers to provide real-time object detection while maintaining\n    high accuracy. It supports key features like efficient hybrid encoding and IoU-aware query selection.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.rtdetr import RTDETRPredictor",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.predict",
        "documentation": {}
    },
    {
        "label": "RTDETRTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.train",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.train",
        "peekOfCode": "class RTDETRTrainer(DetectionTrainer):\n    \"\"\"\n    Trainer class for the RT-DETR model developed by Baidu for real-time object detection. Extends the DetectionTrainer\n    class for YOLO to adapt to the specific features and architecture of RT-DETR. This model leverages Vision\n    Transformers and has capabilities like IoU-aware query selection and adaptable inference speed.\n    Notes:\n        - F.grid_sample used in RT-DETR does not support the `deterministic=True` argument.\n        - AMP training can lead to NaN outputs and may produce errors during bipartite graph matching.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.train",
        "documentation": {}
    },
    {
        "label": "RTDETRDataset",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "peekOfCode": "class RTDETRDataset(YOLODataset):\n    \"\"\"\n    Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.\n    This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for\n    real-time detection and tracking tasks.\n    \"\"\"\n    def __init__(self, *args, data=None, **kwargs):\n        \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n        super().__init__(*args, data=data, **kwargs)\n    # NOTE: add stretch version load_image for RTDETR mosaic",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "RTDETRValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "peekOfCode": "class RTDETRValidator(DetectionValidator):\n    \"\"\"\n    RTDETRValidator extends the DetectionValidator class to provide validation capabilities specifically tailored for\n    the RT-DETR (Real-Time DETR) object detection model.\n    The class allows building of an RTDETR-specific dataset for validation, applies Non-maximum suppression for\n    post-processing, and updates evaluation metrics accordingly.\n    Example:\n        ```python\n        from ultralytics.models.rtdetr import RTDETRValidator\n        args = dict(model='rtdetr-l.pt', data='coco8.yaml')",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "description": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "peekOfCode": "__all__ = (\"RTDETRValidator\",)  # tuple or list\nclass RTDETRDataset(YOLODataset):\n    \"\"\"\n    Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.\n    This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for\n    real-time detection and tracking tasks.\n    \"\"\"\n    def __init__(self, *args, data=None, **kwargs):\n        \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n        super().__init__(*args, data=data, **kwargs)",
        "detail": "Identification.yolov10.ultralytics.models.rtdetr.val",
        "documentation": {}
    },
    {
        "label": "MaskDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "peekOfCode": "class MaskDecoder(nn.Module):\n    \"\"\"\n    Decoder module for generating masks and their associated quality scores, using a transformer architecture to predict\n    masks given image and prompt embeddings.\n    Attributes:\n        transformer_dim (int): Channel dimension for the transformer module.\n        transformer (nn.Module): The transformer module used for mask prediction.\n        num_multimask_outputs (int): Number of masks to predict for disambiguating masks.\n        iou_token (nn.Embedding): Embedding for the IoU token.\n        num_mask_tokens (int): Number of mask tokens.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "documentation": {}
    },
    {
        "label": "MLP",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "peekOfCode": "class MLP(nn.Module):\n    \"\"\"\n    MLP (Multi-Layer Perceptron) model lightly adapted from\n    https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py\n    \"\"\"\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.decoders",
        "documentation": {}
    },
    {
        "label": "ImageEncoderViT",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class ImageEncoderViT(nn.Module):\n    \"\"\"\n    An image encoder using Vision Transformer (ViT) architecture for encoding an image into a compact latent space. The\n    encoder takes an image, splits it into patches, and processes these patches through a series of transformer blocks.\n    The encoded patches are then processed through a neck to generate the final encoded representation.\n    This class and its supporting functions below lightly adapted from the ViTDet backbone available at\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py.\n    Attributes:\n        img_size (int): Dimension of input images, assumed to be square.\n        patch_embed (PatchEmbed): Module for patch embedding.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PromptEncoder",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PromptEncoder(nn.Module):\n    \"\"\"\n    Encodes different types of prompts, including points, boxes, and masks, for input to SAM's mask decoder. The encoder\n    produces both sparse and dense embeddings for the input prompts.\n    Attributes:\n        embed_dim (int): Dimension of the embeddings.\n        input_image_size (Tuple[int, int]): Size of the input image as (H, W).\n        image_embedding_size (Tuple[int, int]): Spatial size of the image embedding as (H, W).\n        pe_layer (PositionEmbeddingRandom): Module for random position embedding.\n        num_point_embeddings (int): Number of point embeddings for different types of points.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PositionEmbeddingRandom",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PositionEmbeddingRandom(nn.Module):\n    \"\"\"Positional encoding using random spatial frequencies.\"\"\"\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -> None:\n        \"\"\"Initializes a position embedding using random spatial frequencies.\"\"\"\n        super().__init__()\n        if scale is None or scale <= 0.0:\n            scale = 1.0\n        self.register_buffer(\"positional_encoding_gaussian_matrix\", scale * torch.randn((2, num_pos_feats)))\n        # Set non-deterministic for forward() error 'cumsum_cuda_kernel does not have a deterministic implementation'\n        torch.use_deterministic_algorithms(False)",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Block",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class Block(nn.Module):\n    \"\"\"Transformer blocks with support of window attention and residual propagation blocks.\"\"\"\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class Attention(nn.Module):\n    \"\"\"Multi-head Attention block with relative position embeddings.\"\"\"\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int = 8,\n        qkv_bias: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        input_size: Optional[Tuple[int, int]] = None,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "class PatchEmbed(nn.Module):\n    \"\"\"Image to Patch Embedding.\"\"\"\n    def __init__(\n        self,\n        kernel_size: Tuple[int, int] = (16, 16),\n        stride: Tuple[int, int] = (16, 16),\n        padding: Tuple[int, int] = (0, 0),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ) -> None:",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "window_partition",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def window_partition(x: torch.Tensor, window_size: int) -> Tuple[torch.Tensor, Tuple[int, int]]:\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "window_unpartition",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def window_unpartition(\n    windows: torch.Tensor, window_size: int, pad_hw: Tuple[int, int], hw: Tuple[int, int]\n) -> torch.Tensor:\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n    Args:\n        windows (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "get_rel_pos",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def get_rel_pos(q_size: int, k_size: int, rel_pos: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Get relative positional embeddings according to the relative positions of query and key sizes.\n    Args:\n        q_size (int): size of query q.\n        k_size (int): size of key k.\n        rel_pos (Tensor): relative position embeddings (L, C).\n    Returns:\n        Extracted positional embeddings according to relative positions.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "add_decomposed_rel_pos",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "peekOfCode": "def add_decomposed_rel_pos(\n    attn: torch.Tensor,\n    q: torch.Tensor,\n    rel_pos_h: torch.Tensor,\n    rel_pos_w: torch.Tensor,\n    q_size: Tuple[int, int],\n    k_size: Tuple[int, int],\n) -> torch.Tensor:\n    \"\"\"\n    Calculate decomposed Relative Positional Embeddings from mvitv2 paper at",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.encoders",
        "documentation": {}
    },
    {
        "label": "Sam",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.sam",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.sam",
        "peekOfCode": "class Sam(nn.Module):\n    \"\"\"\n    Sam (Segment Anything Model) is designed for object segmentation tasks. It uses image encoders to generate image\n    embeddings, and prompt encoders to encode various types of input prompts. These embeddings are then used by the mask\n    decoder to predict object masks.\n    Attributes:\n        mask_threshold (float): Threshold value for mask prediction.\n        image_format (str): Format of the input image, default is 'RGB'.\n        image_encoder (ImageEncoderViT): The backbone used to encode the image into embeddings.\n        prompt_encoder (PromptEncoder): Encodes various types of input prompts.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.sam",
        "documentation": {}
    },
    {
        "label": "Conv2d_BN",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Conv2d_BN(torch.nn.Sequential):\n    \"\"\"A sequential container that performs 2D convolution followed by batch normalization.\"\"\"\n    def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1):\n        \"\"\"Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and\n        drop path.\n        \"\"\"\n        super().__init__()\n        self.add_module(\"c\", torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))\n        bn = torch.nn.BatchNorm2d(b)\n        torch.nn.init.constant_(bn.weight, bn_weight_init)",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "PatchEmbed",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class PatchEmbed(nn.Module):\n    \"\"\"Embeds images into patches and projects them into a specified embedding dimension.\"\"\"\n    def __init__(self, in_chans, embed_dim, resolution, activation):\n        \"\"\"Initialize the PatchMerging class with specified input, output dimensions, resolution and activation\n        function.\n        \"\"\"\n        super().__init__()\n        img_size: Tuple[int, int] = to_2tuple(resolution)\n        self.patches_resolution = (img_size[0] // 4, img_size[1] // 4)\n        self.num_patches = self.patches_resolution[0] * self.patches_resolution[1]",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "MBConv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class MBConv(nn.Module):\n    \"\"\"Mobile Inverted Bottleneck Conv (MBConv) layer, part of the EfficientNet architecture.\"\"\"\n    def __init__(self, in_chans, out_chans, expand_ratio, activation, drop_path):\n        \"\"\"Initializes a convolutional layer with specified dimensions, input resolution, depth, and activation\n        function.\n        \"\"\"\n        super().__init__()\n        self.in_chans = in_chans\n        self.hidden_chans = int(in_chans * expand_ratio)\n        self.out_chans = out_chans",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "PatchMerging",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class PatchMerging(nn.Module):\n    \"\"\"Merges neighboring patches in the feature map and projects to a new dimension.\"\"\"\n    def __init__(self, input_resolution, dim, out_dim, activation):\n        \"\"\"Initializes the ConvLayer with specific dimension, input resolution, depth, activation, drop path, and other\n        optional parameters.\n        \"\"\"\n        super().__init__()\n        self.input_resolution = input_resolution\n        self.dim = dim\n        self.out_dim = out_dim",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "ConvLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class ConvLayer(nn.Module):\n    \"\"\"\n    Convolutional Layer featuring multiple MobileNetV3-style inverted bottleneck convolutions (MBConv).\n    Optionally applies downsample operations to the output, and provides support for gradient checkpointing.\n    \"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Mlp(nn.Module):\n    \"\"\"\n    Multi-layer Perceptron (MLP) for transformer architectures.\n    This layer takes an input with in_features, applies layer normalization and two fully-connected layers.\n    \"\"\"\n    def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0):\n        \"\"\"Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc.\"\"\"\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class Attention(torch.nn.Module):\n    \"\"\"\n    Multi-head attention module with support for spatial awareness, applying attention biases based on spatial\n    resolution. Implements trainable attention biases for each unique offset between spatial positions in the resolution\n    grid.\n    Attributes:\n        ab (Tensor, optional): Cached attention biases for inference, deleted during training.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TinyViTBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class TinyViTBlock(nn.Module):\n    \"\"\"TinyViT Block that applies self-attention and a local convolution to the input.\"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        num_heads,\n        window_size=7,\n        mlp_ratio=4.0,\n        drop=0.0,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "BasicLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class BasicLayer(nn.Module):\n    \"\"\"A basic TinyViT layer for one stage in a TinyViT architecture.\"\"\"\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,\n        num_heads,\n        window_size,\n        mlp_ratio=4.0,",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class LayerNorm2d(nn.Module):\n    \"\"\"A PyTorch implementation of Layer Normalization in 2D.\"\"\"\n    def __init__(self, num_channels: int, eps: float = 1e-6) -> None:\n        \"\"\"Initialize LayerNorm2d with the number of channels and an optional epsilon.\"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Perform a forward pass, normalizing the input tensor.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TinyViT",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "peekOfCode": "class TinyViT(nn.Module):\n    \"\"\"\n    The TinyViT architecture for vision tasks.\n    Attributes:\n        img_size (int): Input image size.\n        in_chans (int): Number of input channels.\n        num_classes (int): Number of classification classes.\n        embed_dims (List[int]): List of embedding dimensions for each layer.\n        depths (List[int]): List of depths for each layer.\n        num_heads (List[int]): List of number of attention heads for each layer.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.tiny_encoder",
        "documentation": {}
    },
    {
        "label": "TwoWayTransformer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class TwoWayTransformer(nn.Module):\n    \"\"\"\n    A Two-Way Transformer module that enables the simultaneous attention to both image and query points. This class\n    serves as a specialized transformer decoder that attends to an input image using queries whose positional embedding\n    is supplied. This is particularly useful for tasks like object detection, image segmentation, and point cloud\n    processing.\n    Attributes:\n        depth (int): The number of layers in the transformer.\n        embedding_dim (int): The channel dimension for the input embeddings.\n        num_heads (int): The number of heads for multihead attention.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TwoWayAttentionBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class TwoWayAttentionBlock(nn.Module):\n    \"\"\"\n    An attention block that performs both self-attention and cross-attention in two directions: queries to keys and\n    keys to queries. This block consists of four main layers: (1) self-attention on sparse inputs, (2) cross-attention\n    of sparse inputs to dense inputs, (3) an MLP block on sparse inputs, and (4) cross-attention of dense inputs to\n    sparse inputs.\n    Attributes:\n        self_attn (Attention): The self-attention layer for the queries.\n        norm1 (nn.LayerNorm): Layer normalization following the first attention block.\n        cross_attn_token_to_image (Attention): Cross-attention layer from queries to keys.",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "description": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "peekOfCode": "class Attention(nn.Module):\n    \"\"\"An attention layer that allows for downscaling the size of the embedding after projection to queries, keys, and\n    values.\n    \"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -> None:",
        "detail": "Identification.yolov10.ultralytics.models.sam.modules.transformer",
        "documentation": {}
    },
    {
        "label": "is_box_near_crop_edge",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -> torch.Tensor:\n    \"\"\"Return a boolean tensor indicating if boxes are near the crop edge.\"\"\"\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "batch_iterator",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:\n    \"\"\"Yield batches of data from the input arguments.\"\"\"\n    assert args and all(len(a) == len(args[0]) for a in args), \"Batched iteration must have same-size inputs.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\ndef calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks.\n    The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "calculate_stability_score",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks.\n    The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high\n    and low values.\n    Notes:\n        - One mask is always contained inside the other.\n        - Save memory by preventing unnecessary cast to torch.int64\n    \"\"\"\n    intersections = (masks > (mask_threshold + threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_point_grid",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def build_point_grid(n_per_side: int) -> np.ndarray:\n    \"\"\"Generate a 2D grid of evenly spaced points in the range [0,1]x[0,1].\"\"\"\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    return np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\ndef build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:\n    \"\"\"Generate point grids for all crop layers.\"\"\"\n    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_all_layer_point_grids",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:\n    \"\"\"Generate point grids for all crop layers.\"\"\"\n    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]\ndef generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes.\n    Each layer has (2**i)**2 boxes for the ith layer.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "generate_crop_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -> Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes.\n    Each layer has (2**i)**2 boxes for the ith layer.\n    \"\"\"\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_boxes_xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop bounding boxes by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\ndef uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop points by adding the crop box offset.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_points",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:\n    \"\"\"Uncrop points by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\ndef uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -> torch.Tensor:\n    \"\"\"Uncrop masks by padding them to the original image size.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "uncrop_masks",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -> torch.Tensor:\n    \"\"\"Uncrop masks by padding them to the original image size.\"\"\"\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)\ndef remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "remove_small_regions",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:\n    \"\"\"Remove small disconnected regions or holes in a mask, returning the mask and a modification indicator.\"\"\"\n    import cv2  # type: ignore\n    assert mode in {\"holes\", \"islands\"}\n    correct_holes = mode == \"holes\"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s < area_thresh]\n    if not small_regions:",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "batched_mask_to_box",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.amg",
        "description": "Identification.yolov10.ultralytics.models.sam.amg",
        "peekOfCode": "def batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks.\n    Return [0,0,0,0] for an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n    # Normalize shape to CxHxW\n    shape = masks.shape",
        "detail": "Identification.yolov10.ultralytics.models.sam.amg",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_h",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_h(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) h-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )\ndef build_sam_vit_l(checkpoint=None):",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_l",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_l(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) l-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )\ndef build_sam_vit_b(checkpoint=None):",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam_vit_b",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam_vit_b(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) b-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )\ndef build_mobile_sam(checkpoint=None):",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_mobile_sam",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "def build_mobile_sam(checkpoint=None):\n    \"\"\"Build and return Mobile Segment Anything Model (Mobile-SAM).\"\"\"\n    return _build_sam(\n        encoder_embed_dim=[64, 128, 160, 320],\n        encoder_depth=[2, 2, 6, 2],\n        encoder_num_heads=[2, 4, 5, 10],\n        encoder_global_attn_indexes=None,\n        mobile_sam=True,\n        checkpoint=checkpoint,\n    )",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "build_sam",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "def build_sam(ckpt=\"sam_b.pt\"):\n    \"\"\"Build a SAM model specified by ckpt.\"\"\"\n    model_builder = None\n    ckpt = str(ckpt)  # to allow Path ckpt types\n    for k in sam_model_map.keys():\n        if ckpt.endswith(k):\n            model_builder = sam_model_map.get(k)\n    if not model_builder:\n        raise FileNotFoundError(f\"{ckpt} is not a supported SAM model. Available models are: \\n {sam_model_map.keys()}\")\n    return model_builder(ckpt)",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "sam_model_map",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.sam.build",
        "description": "Identification.yolov10.ultralytics.models.sam.build",
        "peekOfCode": "sam_model_map = {\n    \"sam_h.pt\": build_sam_vit_h,\n    \"sam_l.pt\": build_sam_vit_l,\n    \"sam_b.pt\": build_sam_vit_b,\n    \"mobile_sam.pt\": build_mobile_sam,\n}\ndef build_sam(ckpt=\"sam_b.pt\"):\n    \"\"\"Build a SAM model specified by ckpt.\"\"\"\n    model_builder = None\n    ckpt = str(ckpt)  # to allow Path ckpt types",
        "detail": "Identification.yolov10.ultralytics.models.sam.build",
        "documentation": {}
    },
    {
        "label": "SAM",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.model",
        "description": "Identification.yolov10.ultralytics.models.sam.model",
        "peekOfCode": "class SAM(Model):\n    \"\"\"\n    SAM (Segment Anything Model) interface class.\n    SAM is designed for promptable real-time image segmentation. It can be used with a variety of prompts such as\n    bounding boxes, points, or labels. The model has capabilities for zero-shot performance and is trained on the SA-1B\n    dataset.\n    \"\"\"\n    def __init__(self, model=\"sam_b.pt\") -> None:\n        \"\"\"\n        Initializes the SAM model with a pre-trained model file.",
        "detail": "Identification.yolov10.ultralytics.models.sam.model",
        "documentation": {}
    },
    {
        "label": "Predictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.sam.predict",
        "description": "Identification.yolov10.ultralytics.models.sam.predict",
        "peekOfCode": "class Predictor(BasePredictor):\n    \"\"\"\n    Predictor class for the Segment Anything Model (SAM), extending BasePredictor.\n    The class provides an interface for model inference tailored to image segmentation tasks.\n    With advanced architecture and promptable segmentation capabilities, it facilitates flexible and real-time\n    mask generation. The class is capable of working with various types of prompts such as bounding boxes,\n    points, and low-resolution masks.\n    Attributes:\n        cfg (dict): Configuration dictionary specifying model and task-related parameters.\n        overrides (dict): Dictionary containing values that override the default configuration.",
        "detail": "Identification.yolov10.ultralytics.models.sam.predict",
        "documentation": {}
    },
    {
        "label": "DETRLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.utils.loss",
        "description": "Identification.yolov10.ultralytics.models.utils.loss",
        "peekOfCode": "class DETRLoss(nn.Module):\n    \"\"\"\n    DETR (DEtection TRansformer) Loss class. This class calculates and returns the different loss components for the\n    DETR object detection model. It computes classification loss, bounding box loss, GIoU loss, and optionally auxiliary\n    losses.\n    Attributes:\n        nc (int): The number of classes.\n        loss_gain (dict): Coefficients for different loss components.\n        aux_loss (bool): Whether to compute auxiliary losses.\n        use_fl (bool): Use FocalLoss or not.",
        "detail": "Identification.yolov10.ultralytics.models.utils.loss",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.utils.loss",
        "description": "Identification.yolov10.ultralytics.models.utils.loss",
        "peekOfCode": "class RTDETRDetectionLoss(DETRLoss):\n    \"\"\"\n    Real-Time DeepTracker (RT-DETR) Detection Loss class that extends the DETRLoss.\n    This class computes the detection loss for the RT-DETR model, which includes the standard detection loss as well as\n    an additional denoising training loss when provided with denoising metadata.\n    \"\"\"\n    def forward(self, preds, batch, dn_bboxes=None, dn_scores=None, dn_meta=None):\n        \"\"\"\n        Forward pass to compute the detection loss.\n        Args:",
        "detail": "Identification.yolov10.ultralytics.models.utils.loss",
        "documentation": {}
    },
    {
        "label": "HungarianMatcher",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.utils.ops",
        "description": "Identification.yolov10.ultralytics.models.utils.ops",
        "peekOfCode": "class HungarianMatcher(nn.Module):\n    \"\"\"\n    A module implementing the HungarianMatcher, which is a differentiable module to solve the assignment problem in an\n    end-to-end fashion.\n    HungarianMatcher performs optimal assignment over the predicted and ground truth bounding boxes using a cost\n    function that considers classification scores, bounding box coordinates, and optionally, mask predictions.\n    Attributes:\n        cost_gain (dict): Dictionary of cost coefficients: 'class', 'bbox', 'giou', 'mask', and 'dice'.\n        use_fl (bool): Indicates whether to use Focal Loss for the classification cost calculation.\n        with_mask (bool): Indicates whether the model makes mask predictions.",
        "detail": "Identification.yolov10.ultralytics.models.utils.ops",
        "documentation": {}
    },
    {
        "label": "get_cdn_group",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.models.utils.ops",
        "description": "Identification.yolov10.ultralytics.models.utils.ops",
        "peekOfCode": "def get_cdn_group(\n    batch, num_classes, num_queries, class_embed, num_dn=100, cls_noise_ratio=0.5, box_noise_scale=1.0, training=False\n):\n    \"\"\"\n    Get contrastive denoising training group. This function creates a contrastive denoising training group with positive\n    and negative samples from the ground truths (gt). It applies noise to the class labels and bounding box coordinates,\n    and returns the modified labels, bounding boxes, attention mask and meta information.\n    Args:\n        batch (dict): A dict that includes 'gt_cls' (torch.Tensor with shape [num_gts, ]), 'gt_bboxes'\n            (torch.Tensor with shape [num_gts, 4]), 'gt_groups' (List(int)) which is a list of batch size length",
        "detail": "Identification.yolov10.ultralytics.models.utils.ops",
        "documentation": {}
    },
    {
        "label": "ClassificationPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.classify.predict",
        "description": "Identification.yolov10.ultralytics.models.yolo.classify.predict",
        "peekOfCode": "class ClassificationPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.classify import ClassificationPredictor\n        args = dict(model='yolov8n-cls.pt', source=ASSETS)",
        "detail": "Identification.yolov10.ultralytics.models.yolo.classify.predict",
        "documentation": {}
    },
    {
        "label": "ClassificationTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.classify.train",
        "description": "Identification.yolov10.ultralytics.models.yolo.classify.train",
        "peekOfCode": "class ClassificationTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationTrainer\n        args = dict(model='yolov8n-cls.pt', data='imagenet10', epochs=3)\n        trainer = ClassificationTrainer(overrides=args)",
        "detail": "Identification.yolov10.ultralytics.models.yolo.classify.train",
        "documentation": {}
    },
    {
        "label": "ClassificationValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.classify.val",
        "description": "Identification.yolov10.ultralytics.models.yolo.classify.val",
        "peekOfCode": "class ClassificationValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a classification model.\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationValidator\n        args = dict(model='yolov8n-cls.pt', data='imagenet10')\n        validator = ClassificationValidator(args=args)",
        "detail": "Identification.yolov10.ultralytics.models.yolo.classify.val",
        "documentation": {}
    },
    {
        "label": "DetectionPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.detect.predict",
        "description": "Identification.yolov10.ultralytics.models.yolo.detect.predict",
        "peekOfCode": "class DetectionPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a detection model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.detect import DetectionPredictor\n        args = dict(model='yolov8n.pt', source=ASSETS)\n        predictor = DetectionPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.ultralytics.models.yolo.detect.predict",
        "documentation": {}
    },
    {
        "label": "DetectionTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.detect.train",
        "description": "Identification.yolov10.ultralytics.models.yolo.detect.train",
        "peekOfCode": "class DetectionTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a detection model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionTrainer\n        args = dict(model='yolov8n.pt', data='coco8.yaml', epochs=3)\n        trainer = DetectionTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.detect.train",
        "documentation": {}
    },
    {
        "label": "DetectionValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.detect.val",
        "description": "Identification.yolov10.ultralytics.models.yolo.detect.val",
        "peekOfCode": "class DetectionValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a detection model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionValidator\n        args = dict(model='yolov8n.pt', data='coco8.yaml')\n        validator = DetectionValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.detect.val",
        "documentation": {}
    },
    {
        "label": "OBBPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.obb.predict",
        "description": "Identification.yolov10.ultralytics.models.yolo.obb.predict",
        "peekOfCode": "class OBBPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.obb import OBBPredictor\n        args = dict(model='yolov8n-obb.pt', source=ASSETS)\n        predictor = OBBPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.ultralytics.models.yolo.obb.predict",
        "documentation": {}
    },
    {
        "label": "OBBTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.obb.train",
        "description": "Identification.yolov10.ultralytics.models.yolo.obb.train",
        "peekOfCode": "class OBBTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBTrainer\n        args = dict(model='yolov8n-obb.pt', data='dota8.yaml', epochs=3)\n        trainer = OBBTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.obb.train",
        "documentation": {}
    },
    {
        "label": "OBBValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.obb.val",
        "description": "Identification.yolov10.ultralytics.models.yolo.obb.val",
        "peekOfCode": "class OBBValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on an Oriented Bounding Box (OBB) model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBValidator\n        args = dict(model='yolov8n-obb.pt', data='dota8.yaml')\n        validator = OBBValidator(args=args)\n        validator(model=args['model'])\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.obb.val",
        "documentation": {}
    },
    {
        "label": "PosePredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.pose.predict",
        "description": "Identification.yolov10.ultralytics.models.yolo.pose.predict",
        "peekOfCode": "class PosePredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a pose model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.pose import PosePredictor\n        args = dict(model='yolov8n-pose.pt', source=ASSETS)\n        predictor = PosePredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.ultralytics.models.yolo.pose.predict",
        "documentation": {}
    },
    {
        "label": "PoseTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.pose.train",
        "description": "Identification.yolov10.ultralytics.models.yolo.pose.train",
        "peekOfCode": "class PoseTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a pose model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseTrainer\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml', epochs=3)\n        trainer = PoseTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.pose.train",
        "documentation": {}
    },
    {
        "label": "PoseValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.pose.val",
        "description": "Identification.yolov10.ultralytics.models.yolo.pose.val",
        "peekOfCode": "class PoseValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a pose model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseValidator\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')\n        validator = PoseValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.pose.val",
        "documentation": {}
    },
    {
        "label": "SegmentationPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.segment.predict",
        "description": "Identification.yolov10.ultralytics.models.yolo.segment.predict",
        "peekOfCode": "class SegmentationPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.segment import SegmentationPredictor\n        args = dict(model='yolov8n-seg.pt', source=ASSETS)\n        predictor = SegmentationPredictor(overrides=args)\n        predictor.predict_cli()",
        "detail": "Identification.yolov10.ultralytics.models.yolo.segment.predict",
        "documentation": {}
    },
    {
        "label": "SegmentationTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.segment.train",
        "description": "Identification.yolov10.ultralytics.models.yolo.segment.train",
        "peekOfCode": "class SegmentationTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationTrainer\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\n        trainer = SegmentationTrainer(overrides=args)\n        trainer.train()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.segment.train",
        "documentation": {}
    },
    {
        "label": "SegmentationValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.segment.val",
        "description": "Identification.yolov10.ultralytics.models.yolo.segment.val",
        "peekOfCode": "class SegmentationValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a segmentation model.\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationValidator\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml')\n        validator = SegmentationValidator(args=args)\n        validator()\n        ```",
        "detail": "Identification.yolov10.ultralytics.models.yolo.segment.val",
        "documentation": {}
    },
    {
        "label": "YOLO",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.model",
        "description": "Identification.yolov10.ultralytics.models.yolo.model",
        "peekOfCode": "class YOLO(Model):\n    \"\"\"YOLO (You Only Look Once) object detection model.\"\"\"\n    def __init__(self, model=\"yolov8n.pt\", task=None, verbose=False):\n        \"\"\"Initialize YOLO model, switching to YOLOWorld if model filename contains '-world'.\"\"\"\n        path = Path(model)\n        if \"-world\" in path.stem and path.suffix in {\".pt\", \".yaml\", \".yml\"}:  # if YOLOWorld PyTorch model\n            new_instance = YOLOWorld(path)\n            self.__class__ = type(new_instance)\n            self.__dict__ = new_instance.__dict__\n        elif \"yolov10\" in path.stem:",
        "detail": "Identification.yolov10.ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "YOLOWorld",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolo.model",
        "description": "Identification.yolov10.ultralytics.models.yolo.model",
        "peekOfCode": "class YOLOWorld(Model):\n    \"\"\"YOLO-World object detection model.\"\"\"\n    def __init__(self, model=\"yolov8s-world.pt\") -> None:\n        \"\"\"\n        Initializes the YOLOv8-World model with the given pre-trained model file. Supports *.pt and *.yaml formats.\n        Args:\n            model (str | Path): Path to the pre-trained model. Defaults to 'yolov8s-world.pt'.\n        \"\"\"\n        super().__init__(model=model, task=\"detect\")\n        # Assign default COCO class names when there are no custom names",
        "detail": "Identification.yolov10.ultralytics.models.yolo.model",
        "documentation": {}
    },
    {
        "label": "card_template_text",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.ultralytics.models.yolov10.card",
        "peekOfCode": "card_template_text = \"\"\"\n---\nlicense: agpl-3.0\nlibrary_name: ultralytics\nrepo_url: https://github.com/THU-MIG/yolov10\ntags:\n- object-detection\n- computer-vision\n- yolov10\ndatasets:",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.ultralytics.models.yolov10.card",
        "peekOfCode": "model = YOLOv10.from_pretrained('jameslahm/yolov10n')\n# Training\nmodel.train(...)\n# after training, one can push to the hub\nmodel.push_to_hub(\"your-hf-username/yolov10-finetuned\")\n# Validation\nmodel.val(...)\n```\n### Inference\nHere's an end-to-end example showcasing inference on a cats image:",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.ultralytics.models.yolov10.card",
        "peekOfCode": "model = YOLOv10.from_pretrained('jameslahm/yolov10n')\nsource = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nmodel.predict(source=source, save=True)\n```\nwhich shows:\n![image/png](https://cdn-uploads.huggingface.co/production/uploads/628ece6054698ce61d1e7be3/tBwAsKcQA_96HCYQp7BRr.png)\n### BibTeX Entry and Citation Info\n```\n@article{wang2024yolov10,\n  title={YOLOv10: Real-Time End-to-End Object Detection},",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.card",
        "description": "Identification.yolov10.ultralytics.models.yolov10.card",
        "peekOfCode": "source = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nmodel.predict(source=source, save=True)\n```\nwhich shows:\n![image/png](https://cdn-uploads.huggingface.co/production/uploads/628ece6054698ce61d1e7be3/tBwAsKcQA_96HCYQp7BRr.png)\n### BibTeX Entry and Citation Info\n```\n@article{wang2024yolov10,\n  title={YOLOv10: Real-Time End-to-End Object Detection},\n  author={Wang, Ao and Chen, Hui and Liu, Lihao and Chen, Kai and Lin, Zijia and Han, Jungong and Ding, Guiguang},",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.card",
        "documentation": {}
    },
    {
        "label": "YOLOv10",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.model",
        "description": "Identification.yolov10.ultralytics.models.yolov10.model",
        "peekOfCode": "class YOLOv10(Model, PyTorchModelHubMixin, model_card_template=card_template_text):\n    def __init__(self, model=\"yolov10n.pt\", task=None, verbose=False, \n                 names=None):\n        super().__init__(model=model, task=task, verbose=verbose)\n        if names is not None:\n            setattr(self.model, 'names', names)\n    def push_to_hub(self, repo_name, **kwargs):\n        config = kwargs.get('config', {})\n        config['names'] = self.names\n        config['model'] = self.model.yaml['yaml_file']",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.model",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionPredictor",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.predict",
        "description": "Identification.yolov10.ultralytics.models.yolov10.predict",
        "peekOfCode": "class YOLOv10DetectionPredictor(DetectionPredictor):\n    def postprocess(self, preds, img, orig_imgs):\n        if isinstance(preds, dict):\n            preds = preds[\"one2one\"]\n        if isinstance(preds, (list, tuple)):\n            preds = preds[0]\n        if preds.shape[-1] == 6:\n            pass\n        else:\n            preds = preds.transpose(-1, -2)",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.predict",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionTrainer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.train",
        "description": "Identification.yolov10.ultralytics.models.yolov10.train",
        "peekOfCode": "class YOLOv10DetectionTrainer(DetectionTrainer):\n    def get_validator(self):\n        \"\"\"Returns a DetectionValidator for YOLO model validation.\"\"\"\n        self.loss_names = \"box_om\", \"cls_om\", \"dfl_om\", \"box_oo\", \"cls_oo\", \"dfl_oo\", \n        return YOLOv10DetectionValidator(\n            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n        )\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Return a YOLO detection model.\"\"\"\n        model = YOLOv10DetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.train",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionValidator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.models.yolov10.val",
        "description": "Identification.yolov10.ultralytics.models.yolov10.val",
        "peekOfCode": "class YOLOv10DetectionValidator(DetectionValidator):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.args.save_json |= self.is_coco\n    def postprocess(self, preds):\n        if isinstance(preds, dict):\n            preds = preds[\"one2one\"]\n        if isinstance(preds, (list, tuple)):\n            preds = preds[0]\n        # Acknowledgement: Thanks to sanha9999 in #190 and #181!",
        "detail": "Identification.yolov10.ultralytics.models.yolov10.val",
        "documentation": {}
    },
    {
        "label": "DFL",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class DFL(nn.Module):\n    \"\"\"\n    Integral module of Distribution Focal Loss (DFL).\n    Proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391\n    \"\"\"\n    def __init__(self, c1=16):\n        \"\"\"Initialize a convolutional layer with a given number of input channels.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, 1, 1, bias=False).requires_grad_(False)\n        x = torch.arange(c1, dtype=torch.float)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Proto",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class Proto(nn.Module):\n    \"\"\"YOLOv8 mask Proto module for segmentation models.\"\"\"\n    def __init__(self, c1, c_=256, c2=32):\n        \"\"\"\n        Initializes the YOLOv8 mask Proto module with specified number of protos and masks.\n        Input arguments are ch_in, number of protos, number of masks.\n        \"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c_, k=3)\n        self.upsample = nn.ConvTranspose2d(c_, c_, 2, 2, 0, bias=True)  # nn.Upsample(scale_factor=2, mode='nearest')",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "HGStem",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class HGStem(nn.Module):\n    \"\"\"\n    StemBlock of PPHGNetV2 with 5 convolutions and one maxpool2d.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, cm, c2):\n        \"\"\"Initialize the SPP layer with input/output channels and specified kernel sizes for max pooling.\"\"\"\n        super().__init__()\n        self.stem1 = Conv(c1, cm, 3, 2, act=nn.ReLU())\n        self.stem2a = Conv(cm, cm // 2, 2, 1, 0, act=nn.ReLU())",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "HGBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class HGBlock(nn.Module):\n    \"\"\"\n    HG_Block of PPHGNetV2 with 2 convolutions and LightConv.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, cm, c2, k=3, n=6, lightconv=False, shortcut=False, act=nn.ReLU()):\n        \"\"\"Initializes a CSP Bottleneck with 1 convolution using specified input and output channels.\"\"\"\n        super().__init__()\n        block = LightConv if lightconv else Conv\n        self.m = nn.ModuleList(block(c1 if i == 0 else cm, cm, k=k, act=act) for i in range(n))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPP",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class SPP(nn.Module):\n    \"\"\"Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729.\"\"\"\n    def __init__(self, c1, c2, k=(5, 9, 13)):\n        \"\"\"Initialize the SPP layer with input/output channels and pooling kernel sizes.\"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])\n    def forward(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPPF",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class SPPF(nn.Module):\n    \"\"\"Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher.\"\"\"\n    def __init__(self, c1, c2, k=5):\n        \"\"\"\n        Initializes the SPPF layer with given input/output channels and kernel size.\n        This module is equivalent to SPP(k=(5, 9, 13)).\n        \"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C1",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C1(nn.Module):\n    \"\"\"CSP Bottleneck with 1 convolution.\"\"\"\n    def __init__(self, c1, c2, n=1):\n        \"\"\"Initializes the CSP Bottleneck with configurations for 1 convolution with arguments ch_in, ch_out, number.\"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*(Conv(c2, c2, 3) for _ in range(n)))\n    def forward(self, x):\n        \"\"\"Applies cross-convolutions to input in the C3 module.\"\"\"\n        y = self.cv1(x)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C2(nn.Module):\n    \"\"\"CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck with 2 convolutions module with arguments ch_in, ch_out, number, shortcut,\n        groups, expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv(2 * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2f",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C2f(nn.Module):\n    \"\"\"Faster Implementation of CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv((2 + n) * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C3(nn.Module):\n    \"\"\"CSP Bottleneck with 3 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize the CSP Bottleneck with given channels, number, shortcut, groups, and expansion values.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, k=((1, 1), (3, 3)), e=1.0) for _ in range(n)))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3x",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C3x(C3):\n    \"\"\"C3 module with cross-convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3TR instance and set default parameters.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        self.c_ = int(c2 * e)\n        self.m = nn.Sequential(*(Bottleneck(self.c_, self.c_, shortcut, g, k=((1, 3), (3, 1)), e=1) for _ in range(n)))\nclass RepC3(nn.Module):\n    \"\"\"Rep C3.\"\"\"\n    def __init__(self, c1, c2, n=3, e=1.0):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepC3",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class RepC3(nn.Module):\n    \"\"\"Rep C3.\"\"\"\n    def __init__(self, c1, c2, n=3, e=1.0):\n        \"\"\"Initialize CSP Bottleneck with a single convolution using input channels, output channels, and number.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.cv2 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*[RepConv(c_, c_) for _ in range(n)])\n        self.cv3 = Conv(c_, c2, 1, 1) if c_ != c2 else nn.Identity()",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3TR",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C3TR(C3):\n    \"\"\"C3 module with TransformerBlock().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3Ghost module with GhostBottleneck().\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = TransformerBlock(c_, c_, 4, n)\nclass C3Ghost(C3):\n    \"\"\"C3 module with GhostBottleneck().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C3Ghost",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C3Ghost(C3):\n    \"\"\"C3 module with GhostBottleneck().\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize 'SPP' module with various pooling sizes for spatial pyramid pooling.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)  # hidden channels\n        self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))\nclass GhostBottleneck(nn.Module):\n    \"\"\"Ghost Bottleneck https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "GhostBottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class GhostBottleneck(nn.Module):\n    \"\"\"Ghost Bottleneck https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1):\n        \"\"\"Initializes GhostBottleneck module with arguments ch_in, ch_out, kernel, stride.\"\"\"\n        super().__init__()\n        c_ = c2 // 2\n        self.conv = nn.Sequential(\n            GhostConv(c1, c_, 1, 1),  # pw\n            DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n            GhostConv(c_, c2, 1, 1, act=False),  # pw-linear",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Bottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class Bottleneck(nn.Module):\n    \"\"\"Standard bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n        \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, k[0], 1)\n        self.cv2 = Conv(c_, c2, k[1], 1, g=g)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "BottleneckCSP",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class BottleneckCSP(nn.Module):\n    \"\"\"CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck given arguments for ch_in, ch_out, number, shortcut, groups, expansion.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n        self.cv4 = Conv(2 * c_, c2, 1, 1)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ResNetBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class ResNetBlock(nn.Module):\n    \"\"\"ResNet block with standard convolution layers.\"\"\"\n    def __init__(self, c1, c2, s=1, e=4):\n        \"\"\"Initialize convolution with given parameters.\"\"\"\n        super().__init__()\n        c3 = e * c2\n        self.cv1 = Conv(c1, c2, k=1, s=1, act=True)\n        self.cv2 = Conv(c2, c2, k=3, s=s, p=1, act=True)\n        self.cv3 = Conv(c2, c3, k=1, act=False)\n        self.shortcut = nn.Sequential(Conv(c1, c3, k=1, s=s, act=False)) if s != 1 or c1 != c3 else nn.Identity()",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ResNetLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class ResNetLayer(nn.Module):\n    \"\"\"ResNet layer with multiple ResNet blocks.\"\"\"\n    def __init__(self, c1, c2, s=1, is_first=False, n=1, e=4):\n        \"\"\"Initializes the ResNetLayer given arguments.\"\"\"\n        super().__init__()\n        self.is_first = is_first\n        if self.is_first:\n            self.layer = nn.Sequential(\n                Conv(c1, c2, k=7, s=2, p=3, act=True), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n            )",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "MaxSigmoidAttnBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class MaxSigmoidAttnBlock(nn.Module):\n    \"\"\"Max Sigmoid attention block.\"\"\"\n    def __init__(self, c1, c2, nh=1, ec=128, gc=512, scale=False):\n        \"\"\"Initializes MaxSigmoidAttnBlock with specified arguments.\"\"\"\n        super().__init__()\n        self.nh = nh\n        self.hc = c2 // nh\n        self.ec = Conv(c1, ec, k=1, act=False) if c1 != ec else None\n        self.gl = nn.Linear(gc, ec)\n        self.bias = nn.Parameter(torch.zeros(nh))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2fAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C2fAttn(nn.Module):\n    \"\"\"C2f module with an additional attn module.\"\"\"\n    def __init__(self, c1, c2, n=1, ec=128, nh=1, gc=512, shortcut=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv((3 + n) * self.c, c2, 1)  # optional act=FReLU(c2)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ImagePoolingAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class ImagePoolingAttn(nn.Module):\n    \"\"\"ImagePoolingAttn: Enhance the text embeddings with image-aware information.\"\"\"\n    def __init__(self, ec=256, ch=(), ct=512, nh=8, k=3, scale=False):\n        \"\"\"Initializes ImagePoolingAttn with specified arguments.\"\"\"\n        super().__init__()\n        nf = len(ch)\n        self.query = nn.Sequential(nn.LayerNorm(ct), nn.Linear(ct, ec))\n        self.key = nn.Sequential(nn.LayerNorm(ec), nn.Linear(ec, ec))\n        self.value = nn.Sequential(nn.LayerNorm(ec), nn.Linear(ec, ec))\n        self.proj = nn.Linear(ec, ct)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ContrastiveHead",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class ContrastiveHead(nn.Module):\n    \"\"\"Contrastive Head for YOLO-World compute the region-text scores according to the similarity between image and text\n    features.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes ContrastiveHead with specified region-text similarity parameters.\"\"\"\n        super().__init__()\n        self.bias = nn.Parameter(torch.zeros([]))\n        self.logit_scale = nn.Parameter(torch.ones([]) * torch.tensor(1 / 0.07).log())\n    def forward(self, x, w):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "BNContrastiveHead",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class BNContrastiveHead(nn.Module):\n    \"\"\"\n    Batch Norm Contrastive Head for YOLO-World using batch norm instead of l2-normalization.\n    Args:\n        embed_dims (int): Embed dimensions of text and image features.\n    \"\"\"\n    def __init__(self, embed_dims: int):\n        \"\"\"Initialize ContrastiveHead with region-text similarity parameters.\"\"\"\n        super().__init__()\n        self.norm = nn.BatchNorm2d(embed_dims)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepBottleneck",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class RepBottleneck(nn.Module):\n    \"\"\"Rep bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n        \"\"\"Initializes a RepBottleneck module with customizable in/out channels, shortcut option, groups and expansion\n        ratio.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = RepConv(c1, c_, k[0], 1)\n        self.cv2 = Conv(c_, c2, k[1], 1, g=g)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepCSP",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class RepCSP(nn.Module):\n    \"\"\"Rep CSP Bottleneck with 3 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes RepCSP layer with given channels, repetitions, shortcut, groups and expansion ratio.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(RepBottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepNCSPELAN4",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class RepNCSPELAN4(nn.Module):\n    \"\"\"CSP-ELAN.\"\"\"\n    def __init__(self, c1, c2, c3, c4, n=1):\n        \"\"\"Initializes CSP-ELAN layer with specified channel sizes, repetitions, and convolutions.\"\"\"\n        super().__init__()\n        self.c = c3 // 2\n        self.cv1 = Conv(c1, c3, 1, 1)\n        self.cv2 = nn.Sequential(RepCSP(c3 // 2, c4, n), Conv(c4, c4, 3, 1))\n        self.cv3 = nn.Sequential(RepCSP(c4, c4, n), Conv(c4, c4, 3, 1))\n        self.cv4 = Conv(c3 + (2 * c4), c2, 1, 1)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "ADown",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class ADown(nn.Module):\n    \"\"\"ADown.\"\"\"\n    def __init__(self, c1, c2):\n        \"\"\"Initializes ADown module with convolution layers to downsample input from channels c1 to c2.\"\"\"\n        super().__init__()\n        self.c = c2 // 2\n        self.cv1 = Conv(c1 // 2, self.c, 3, 2, 1)\n        self.cv2 = Conv(c1 // 2, self.c, 1, 1, 0)\n    def forward(self, x):\n        \"\"\"Forward pass through ADown layer.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SPPELAN",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class SPPELAN(nn.Module):\n    \"\"\"SPP-ELAN.\"\"\"\n    def __init__(self, c1, c2, c3, k=5):\n        \"\"\"Initializes SPP-ELAN block with convolution and max pooling layers for spatial pyramid pooling.\"\"\"\n        super().__init__()\n        self.c = c3\n        self.cv1 = Conv(c1, c3, 1, 1)\n        self.cv2 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n        self.cv3 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n        self.cv4 = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Silence",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class Silence(nn.Module):\n    \"\"\"Silence.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the Silence module.\"\"\"\n        super(Silence, self).__init__()\n    def forward(self, x):\n        \"\"\"Forward pass through Silence layer.\"\"\"\n        return x\nclass CBLinear(nn.Module):\n    \"\"\"CBLinear.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CBLinear",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class CBLinear(nn.Module):\n    \"\"\"CBLinear.\"\"\"\n    def __init__(self, c1, c2s, k=1, s=1, p=None, g=1):\n        \"\"\"Initializes the CBLinear module, passing inputs unchanged.\"\"\"\n        super(CBLinear, self).__init__()\n        self.c2s = c2s\n        self.conv = nn.Conv2d(c1, sum(c2s), k, s, autopad(k, p), groups=g, bias=True)\n    def forward(self, x):\n        \"\"\"Forward pass through CBLinear layer.\"\"\"\n        outs = self.conv(x).split(self.c2s, dim=1)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CBFuse",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class CBFuse(nn.Module):\n    \"\"\"CBFuse.\"\"\"\n    def __init__(self, idx):\n        \"\"\"Initializes CBFuse module with layer index for selective feature fusion.\"\"\"\n        super(CBFuse, self).__init__()\n        self.idx = idx\n    def forward(self, xs):\n        \"\"\"Forward pass through CBFuse layer.\"\"\"\n        target_size = xs[-1].shape[2:]\n        res = [F.interpolate(x[self.idx[i]], size=target_size, mode=\"nearest\") for i, x in enumerate(xs[:-1])]",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "RepVGGDW",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class RepVGGDW(torch.nn.Module):\n    def __init__(self, ed) -> None:\n        super().__init__()\n        self.conv = Conv(ed, ed, 7, 1, 3, g=ed, act=False)\n        self.conv1 = Conv(ed, ed, 3, 1, 1, g=ed, act=False)\n        self.dim = ed\n        self.act = nn.SiLU()\n    def forward(self, x):\n        return self.act(self.conv(x) + self.conv1(x))\n    def forward_fuse(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "CIB",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class CIB(nn.Module):\n    \"\"\"Standard bottleneck.\"\"\"\n    def __init__(self, c1, c2, shortcut=True, e=0.5, lk=False):\n        \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = nn.Sequential(\n            Conv(c1, c1, 3, g=c1),",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "C2fCIB",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class C2fCIB(C2f):\n    \"\"\"Faster Implementation of CSP Bottleneck with 2 convolutions.\"\"\"\n    def __init__(self, c1, c2, n=1, shortcut=False, lk=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        self.m = nn.ModuleList(CIB(self.c, self.c, shortcut, e=1.0, lk=lk) for _ in range(n))\nclass Attention(nn.Module):\n    def __init__(self, dim, num_heads=8,",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Attention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class Attention(nn.Module):\n    def __init__(self, dim, num_heads=8,\n                 attn_ratio=0.5):\n        super().__init__()\n        self.num_heads = num_heads\n        self.head_dim = dim // num_heads\n        self.key_dim = int(self.head_dim * attn_ratio)\n        self.scale = self.key_dim ** -0.5\n        nh_kd = nh_kd = self.key_dim * num_heads\n        h = dim + nh_kd * 2",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "PSA",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class PSA(nn.Module):\n    def __init__(self, c1, c2, e=0.5):\n        super().__init__()\n        assert(c1 == c2)\n        self.c = int(c1 * e)\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv(2 * self.c, c1, 1)\n        self.attn = Attention(self.c, attn_ratio=0.5, num_heads=self.c // 64)\n        self.ffn = nn.Sequential(\n            Conv(self.c, self.c*2, 1),",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "SCDown",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "class SCDown(nn.Module):\n    def __init__(self, c1, c2, k, s):\n        super().__init__()\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.cv2 = Conv(c2, c2, k=k, s=s, g=c2, act=False)\n    def forward(self, x):\n        return self.cv2(self.cv1(x))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.block",
        "description": "Identification.yolov10.ultralytics.nn.modules.block",
        "peekOfCode": "__all__ = (\n    \"DFL\",\n    \"HGBlock\",\n    \"HGStem\",\n    \"SPP\",\n    \"SPPF\",\n    \"C1\",\n    \"C2\",\n    \"C3\",\n    \"C2f\",",
        "detail": "Identification.yolov10.ultralytics.nn.modules.block",
        "documentation": {}
    },
    {
        "label": "Conv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class Conv(nn.Module):\n    \"\"\"Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n    def forward(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Conv2",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class Conv2(Conv):\n    \"\"\"Simplified RepConv module with Conv fusing.\"\"\"\n    def __init__(self, c1, c2, k=3, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__(c1, c2, k, s, p, g=g, d=d, act=act)\n        self.cv2 = nn.Conv2d(c1, c2, 1, s, autopad(1, p, d), groups=g, dilation=d, bias=False)  # add 1x1 conv\n    def forward(self, x):\n        \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n        return self.act(self.bn(self.conv(x) + self.cv2(x)))\n    def forward_fuse(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "LightConv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class LightConv(nn.Module):\n    \"\"\"\n    Light convolution with args(ch_in, ch_out, kernel).\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n    def __init__(self, c1, c2, k=1, act=nn.ReLU()):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv1 = Conv(c1, c2, 1, act=False)\n        self.conv2 = DWConv(c2, c2, k, act=act)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "DWConv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class DWConv(Conv):\n    \"\"\"Depth-wise convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, d=1, act=True):  # ch_in, ch_out, kernel, stride, dilation, activation\n        \"\"\"Initialize Depth-wise convolution with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)\nclass DWConvTranspose2d(nn.ConvTranspose2d):\n    \"\"\"Depth-wise transpose convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "DWConvTranspose2d",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class DWConvTranspose2d(nn.ConvTranspose2d):\n    \"\"\"Depth-wise transpose convolution.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))\nclass ConvTranspose(nn.Module):\n    \"\"\"Convolution transpose 2d layer.\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n        \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "ConvTranspose",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class ConvTranspose(nn.Module):\n    \"\"\"Convolution transpose 2d layer.\"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n        \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"\n        super().__init__()\n        self.conv_transpose = nn.ConvTranspose2d(c1, c2, k, s, p, bias=not bn)\n        self.bn = nn.BatchNorm2d(c2) if bn else nn.Identity()\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n    def forward(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Focus",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class Focus(nn.Module):\n    \"\"\"Focus wh information into c-space.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):\n        \"\"\"Initializes Focus object with user defined channel, convolution, padding, group and activation values.\"\"\"\n        super().__init__()\n        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)\n        # self.contract = Contract(gain=2)\n    def forward(self, x):\n        \"\"\"\n        Applies convolution to concatenated tensor and returns the output.",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "GhostConv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class GhostConv(nn.Module):\n    \"\"\"Ghost Convolution https://github.com/huawei-noah/ghostnet.\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\n        \"\"\"Initializes the GhostConv object with input channels, output channels, kernel size, stride, groups and\n        activation.\n        \"\"\"\n        super().__init__()\n        c_ = c2 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "RepConv",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class RepConv(nn.Module):\n    \"\"\"\n    RepConv is a basic rep-style block, including training and deploy status.\n    This module is used in RT-DETR.\n    Based on https://github.com/DingXiaoH/RepVGG/blob/main/repvgg.py\n    \"\"\"\n    default_act = nn.SiLU()  # default activation\n    def __init__(self, c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False):\n        \"\"\"Initializes Light Convolution layer with inputs, outputs & optional activation function.\"\"\"\n        super().__init__()",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "ChannelAttention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class ChannelAttention(nn.Module):\n    \"\"\"Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet.\"\"\"\n    def __init__(self, channels: int) -> None:\n        \"\"\"Initializes the class and sets the basic configurations and instance variables required.\"\"\"\n        super().__init__()\n        self.pool = nn.AdaptiveAvgPool2d(1)\n        self.fc = nn.Conv2d(channels, channels, 1, 1, 0, bias=True)\n        self.act = nn.Sigmoid()\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Applies forward pass using activation on convolutions of the input, optionally using batch normalization.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "SpatialAttention",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class SpatialAttention(nn.Module):\n    \"\"\"Spatial-attention module.\"\"\"\n    def __init__(self, kernel_size=7):\n        \"\"\"Initialize Spatial-attention module with kernel size argument.\"\"\"\n        super().__init__()\n        assert kernel_size in (3, 7), \"kernel size must be 3 or 7\"\n        padding = 3 if kernel_size == 7 else 1\n        self.cv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)\n        self.act = nn.Sigmoid()\n    def forward(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "CBAM",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class CBAM(nn.Module):\n    \"\"\"Convolutional Block Attention Module.\"\"\"\n    def __init__(self, c1, kernel_size=7):\n        \"\"\"Initialize CBAM with given input channel (c1) and kernel size.\"\"\"\n        super().__init__()\n        self.channel_attention = ChannelAttention(c1)\n        self.spatial_attention = SpatialAttention(kernel_size)\n    def forward(self, x):\n        \"\"\"Applies the forward pass through C1 module.\"\"\"\n        return self.spatial_attention(self.channel_attention(x))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Concat",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "class Concat(nn.Module):\n    \"\"\"Concatenate a list of tensors along dimension.\"\"\"\n    def __init__(self, dimension=1):\n        \"\"\"Concatenates a list of tensors along a specified dimension.\"\"\"\n        super().__init__()\n        self.d = dimension\n    def forward(self, x):\n        \"\"\"Forward pass for the YOLOv8 mask Proto module.\"\"\"\n        return torch.cat(x, self.d)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "autopad",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "def autopad(k, p=None, d=1):  # kernel, padding, dilation\n    \"\"\"Pad to 'same' shape outputs.\"\"\"\n    if d > 1:\n        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size\n    if p is None:\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\n    return p\nclass Conv(nn.Module):\n    \"\"\"Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).\"\"\"\n    default_act = nn.SiLU()  # default activation",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.conv",
        "description": "Identification.yolov10.ultralytics.nn.modules.conv",
        "peekOfCode": "__all__ = (\n    \"Conv\",\n    \"Conv2\",\n    \"LightConv\",\n    \"DWConv\",\n    \"DWConvTranspose2d\",\n    \"ConvTranspose\",\n    \"Focus\",\n    \"GhostConv\",\n    \"ChannelAttention\",",
        "detail": "Identification.yolov10.ultralytics.nn.modules.conv",
        "documentation": {}
    },
    {
        "label": "Detect",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class Detect(nn.Module):\n    \"\"\"YOLOv8 Detect head for detection models.\"\"\"\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n    shape = None\n    anchors = torch.empty(0)  # init\n    strides = torch.empty(0)  # init\n    def __init__(self, nc=80, ch=()):\n        \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"\n        super().__init__()",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Segment",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class Segment(Detect):\n    \"\"\"YOLOv8 Segment head for segmentation models.\"\"\"\n    def __init__(self, nc=80, nm=32, npr=256, ch=()):\n        \"\"\"Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers.\"\"\"\n        super().__init__(nc, ch)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.nm)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "OBB",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class OBB(Detect):\n    \"\"\"YOLOv8 OBB detection head for detection with rotation models.\"\"\"\n    def __init__(self, nc=80, ne=1, ch=()):\n        \"\"\"Initialize OBB with number of classes `nc` and layer channels `ch`.\"\"\"\n        super().__init__(nc, ch)\n        self.ne = ne  # number of extra parameters\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.ne)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.ne, 1)) for x in ch)\n    def forward(self, x):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Pose",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class Pose(Detect):\n    \"\"\"YOLOv8 Pose head for keypoints models.\"\"\"\n    def __init__(self, nc=80, kpt_shape=(17, 3), ch=()):\n        \"\"\"Initialize YOLO network with default parameters and Convolutional Layers.\"\"\"\n        super().__init__(nc, ch)\n        self.kpt_shape = kpt_shape  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\n        self.nk = kpt_shape[0] * kpt_shape[1]  # number of keypoints total\n        self.detect = Detect.forward\n        c4 = max(ch[0] // 4, self.nk)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nk, 1)) for x in ch)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "Classify",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class Classify(nn.Module):\n    \"\"\"YOLOv8 classification head, i.e. x(b,c1,20,20) to x(b,c2).\"\"\"\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1):\n        \"\"\"Initializes YOLOv8 classification head with specified input and output channels, kernel size, stride,\n        padding, and groups.\n        \"\"\"\n        super().__init__()\n        c_ = 1280  # efficientnet_b0 size\n        self.conv = Conv(c1, c_, k, s, p, g)\n        self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "WorldDetect",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class WorldDetect(Detect):\n    def __init__(self, nc=80, embed=512, with_bn=False, ch=()):\n        \"\"\"Initialize YOLOv8 detection layer with nc classes and layer channels ch.\"\"\"\n        super().__init__(nc, ch)\n        c3 = max(ch[0], min(self.nc, 100))\n        self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, embed, 1)) for x in ch)\n        self.cv4 = nn.ModuleList(BNContrastiveHead(embed) if with_bn else ContrastiveHead() for _ in ch)\n    def forward(self, x, text):\n        \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n        for i in range(self.nl):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "RTDETRDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class RTDETRDecoder(nn.Module):\n    \"\"\"\n    Real-Time Deformable Transformer Decoder (RTDETRDecoder) module for object detection.\n    This decoder module utilizes Transformer architecture along with deformable convolutions to predict bounding boxes\n    and class labels for objects in an image. It integrates features from multiple layers and runs through a series of\n    Transformer decoder layers to output the final predictions.\n    \"\"\"\n    export = False  # export mode\n    def __init__(\n        self,",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "v10Detect",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "class v10Detect(Detect):\n    max_det = 300\n    def __init__(self, nc=80, ch=()):\n        super().__init__(nc, ch)\n        c3 = max(ch[0], min(self.nc, 100))  # channels\n        self.cv3 = nn.ModuleList(nn.Sequential(nn.Sequential(Conv(x, x, 3, g=x), Conv(x, c3, 1)), \\\n                                               nn.Sequential(Conv(c3, c3, 3, g=c3), Conv(c3, c3, 1)), \\\n                                                nn.Conv2d(c3, self.nc, 1)) for i, x in enumerate(ch))\n        self.one2one_cv2 = copy.deepcopy(self.cv2)\n        self.one2one_cv3 = copy.deepcopy(self.cv3)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.head",
        "description": "Identification.yolov10.ultralytics.nn.modules.head",
        "peekOfCode": "__all__ = \"Detect\", \"Segment\", \"Pose\", \"Classify\", \"OBB\", \"RTDETRDecoder\"\nclass Detect(nn.Module):\n    \"\"\"YOLOv8 Detect head for detection models.\"\"\"\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n    shape = None\n    anchors = torch.empty(0)  # init\n    strides = torch.empty(0)  # init\n    def __init__(self, nc=80, ch=()):\n        \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.head",
        "documentation": {}
    },
    {
        "label": "TransformerEncoderLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerEncoderLayer(nn.Module):\n    \"\"\"Defines a single layer of the transformer encoder.\"\"\"\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the TransformerEncoderLayer with specified parameters.\"\"\"\n        super().__init__()\n        from ...utils.torch_utils import TORCH_1_9\n        if not TORCH_1_9:\n            raise ModuleNotFoundError(\n                \"TransformerEncoderLayer() requires torch>=1.9 to use nn.MultiheadAttention(batch_first=True).\"\n            )",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "AIFI",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class AIFI(TransformerEncoderLayer):\n    \"\"\"Defines the AIFI transformer layer.\"\"\"\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the AIFI instance with specified parameters.\"\"\"\n        super().__init__(c1, cm, num_heads, dropout, act, normalize_before)\n    def forward(self, x):\n        \"\"\"Forward pass for the AIFI transformer layer.\"\"\"\n        c, h, w = x.shape[1:]\n        pos_embed = self.build_2d_sincos_position_embedding(w, h, c)\n        # Flatten [B, C, H, W] to [B, HxW, C]",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerLayer(nn.Module):\n    \"\"\"Transformer layer https://arxiv.org/abs/2010.11929 (LayerNorm layers removed for better performance).\"\"\"\n    def __init__(self, c, num_heads):\n        \"\"\"Initializes a self-attention mechanism using linear transformations and multi-head attention.\"\"\"\n        super().__init__()\n        self.q = nn.Linear(c, c, bias=False)\n        self.k = nn.Linear(c, c, bias=False)\n        self.v = nn.Linear(c, c, bias=False)\n        self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n        self.fc1 = nn.Linear(c, c, bias=False)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "TransformerBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class TransformerBlock(nn.Module):\n    \"\"\"Vision Transformer https://arxiv.org/abs/2010.11929.\"\"\"\n    def __init__(self, c1, c2, num_heads, num_layers):\n        \"\"\"Initialize a Transformer module with position embedding and specified number of heads and layers.\"\"\"\n        super().__init__()\n        self.conv = None\n        if c1 != c2:\n            self.conv = Conv(c1, c2)\n        self.linear = nn.Linear(c2, c2)  # learnable position embedding\n        self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MLPBlock",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MLPBlock(nn.Module):\n    \"\"\"Implements a single block of a multi-layer perceptron.\"\"\"\n    def __init__(self, embedding_dim, mlp_dim, act=nn.GELU):\n        \"\"\"Initialize the MLPBlock with specified embedding dimension, MLP dimension, and activation function.\"\"\"\n        super().__init__()\n        self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n        self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n        self.act = act()\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"Forward pass for the MLPBlock.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MLP",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MLP(nn.Module):\n    \"\"\"Implements a simple multi-layer perceptron (also called FFN).\"\"\"\n    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):\n        \"\"\"Initialize the MLP with specified input, hidden, output dimensions and number of layers.\"\"\"\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n    def forward(self, x):\n        \"\"\"Forward pass for the entire MLP.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "LayerNorm2d",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class LayerNorm2d(nn.Module):\n    \"\"\"\n    2D Layer Normalization module inspired by Detectron2 and ConvNeXt implementations.\n    Original implementations in\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py\n    and\n    https://github.com/facebookresearch/ConvNeXt/blob/main/models/convnext.py.\n    \"\"\"\n    def __init__(self, num_channels, eps=1e-6):\n        \"\"\"Initialize LayerNorm2d with the given parameters.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "MSDeformAttn",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class MSDeformAttn(nn.Module):\n    \"\"\"\n    Multiscale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py\n    \"\"\"\n    def __init__(self, d_model=256, n_levels=4, n_heads=8, n_points=4):\n        \"\"\"Initialize MSDeformAttn with the given parameters.\"\"\"\n        super().__init__()\n        if d_model % n_heads != 0:\n            raise ValueError(f\"d_model must be divisible by n_heads, but got {d_model} and {n_heads}\")",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "DeformableTransformerDecoderLayer",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class DeformableTransformerDecoderLayer(nn.Module):\n    \"\"\"\n    Deformable Transformer Decoder Layer inspired by PaddleDetection and Deformable-DETR implementations.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/deformable_transformer.py\n    \"\"\"\n    def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4):\n        \"\"\"Initialize the DeformableTransformerDecoderLayer with the given parameters.\"\"\"\n        super().__init__()\n        # Self attention",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "DeformableTransformerDecoder",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "class DeformableTransformerDecoder(nn.Module):\n    \"\"\"\n    Implementation of Deformable Transformer Decoder based on PaddleDetection.\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    \"\"\"\n    def __init__(self, hidden_dim, decoder_layer, num_layers, eval_idx=-1):\n        \"\"\"Initialize the DeformableTransformerDecoder with the given parameters.\"\"\"\n        super().__init__()\n        self.layers = _get_clones(decoder_layer, num_layers)\n        self.num_layers = num_layers",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "description": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "peekOfCode": "__all__ = (\n    \"TransformerEncoderLayer\",\n    \"TransformerLayer\",\n    \"TransformerBlock\",\n    \"MLPBlock\",\n    \"LayerNorm2d\",\n    \"AIFI\",\n    \"DeformableTransformerDecoder\",\n    \"DeformableTransformerDecoderLayer\",\n    \"MSDeformAttn\",",
        "detail": "Identification.yolov10.ultralytics.nn.modules.transformer",
        "documentation": {}
    },
    {
        "label": "bias_init_with_prob",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.ultralytics.nn.modules.utils",
        "peekOfCode": "def bias_init_with_prob(prior_prob=0.01):\n    \"\"\"Initialize conv/fc bias value according to a given probability value.\"\"\"\n    return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init\ndef linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])\n    uniform_(module.weight, -bound, bound)\n    if hasattr(module, \"bias\") and module.bias is not None:\n        uniform_(module.bias, -bound, bound)\ndef inverse_sigmoid(x, eps=1e-5):",
        "detail": "Identification.yolov10.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "linear_init",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.ultralytics.nn.modules.utils",
        "peekOfCode": "def linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])\n    uniform_(module.weight, -bound, bound)\n    if hasattr(module, \"bias\") and module.bias is not None:\n        uniform_(module.bias, -bound, bound)\ndef inverse_sigmoid(x, eps=1e-5):\n    \"\"\"Calculate the inverse sigmoid function for a tensor.\"\"\"\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)",
        "detail": "Identification.yolov10.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "inverse_sigmoid",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.ultralytics.nn.modules.utils",
        "peekOfCode": "def inverse_sigmoid(x, eps=1e-5):\n    \"\"\"Calculate the inverse sigmoid function for a tensor.\"\"\"\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)\n    x2 = (1 - x).clamp(min=eps)\n    return torch.log(x1 / x2)\ndef multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,",
        "detail": "Identification.yolov10.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "multi_scale_deformable_attn_pytorch",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.ultralytics.nn.modules.utils",
        "peekOfCode": "def multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,\n    attention_weights: torch.Tensor,\n) -> torch.Tensor:\n    \"\"\"\n    Multiscale deformable attention.\n    https://github.com/IDEA-Research/detrex/blob/main/detrex/layers/multi_scale_deform_attn.py\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.nn.modules.utils",
        "description": "Identification.yolov10.ultralytics.nn.modules.utils",
        "peekOfCode": "__all__ = \"multi_scale_deformable_attn_pytorch\", \"inverse_sigmoid\"\ndef _get_clones(module, n):\n    \"\"\"Create a list of cloned modules from the given module.\"\"\"\n    return nn.ModuleList([copy.deepcopy(module) for _ in range(n)])\ndef bias_init_with_prob(prior_prob=0.01):\n    \"\"\"Initialize conv/fc bias value according to a given probability value.\"\"\"\n    return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init\ndef linear_init(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])",
        "detail": "Identification.yolov10.ultralytics.nn.modules.utils",
        "documentation": {}
    },
    {
        "label": "AutoBackend",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.ultralytics.nn.autobackend",
        "peekOfCode": "class AutoBackend(nn.Module):\n    \"\"\"\n    Handles dynamic backend selection for running inference using Ultralytics YOLO models.\n    The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide\n    range of formats, each with specific naming conventions as outlined below:\n        Supported Formats and Naming Conventions:\n            | Format                | File Suffix      |\n            |-----------------------|------------------|\n            | PyTorch               | *.pt             |\n            | TorchScript           | *.torchscript    |",
        "detail": "Identification.yolov10.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "check_class_names",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.ultralytics.nn.autobackend",
        "peekOfCode": "def check_class_names(names):\n    \"\"\"\n    Check class names.\n    Map imagenet class codes to human-readable names if required. Convert lists to dicts.\n    \"\"\"\n    if isinstance(names, list):  # names is a list\n        names = dict(enumerate(names))  # convert to dict\n    if isinstance(names, dict):\n        # Convert 1) string keys to int, i.e. '0' to 0, and non-string values to strings, i.e. True to 'True'\n        names = {int(k): str(v) for k, v in names.items()}",
        "detail": "Identification.yolov10.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "default_class_names",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.autobackend",
        "description": "Identification.yolov10.ultralytics.nn.autobackend",
        "peekOfCode": "def default_class_names(data=None):\n    \"\"\"Applies default class names to an input YAML file or returns numerical class names.\"\"\"\n    if data:\n        with contextlib.suppress(Exception):\n            return yaml_load(check_yaml(data))[\"names\"]\n    return {i: f\"class{i}\" for i in range(999)}  # return default if above errors\nclass AutoBackend(nn.Module):\n    \"\"\"\n    Handles dynamic backend selection for running inference using Ultralytics YOLO models.\n    The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide",
        "detail": "Identification.yolov10.ultralytics.nn.autobackend",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class BaseModel(nn.Module):\n    \"\"\"The BaseModel class serves as a base class for all the models in the Ultralytics YOLO family.\"\"\"\n    def forward(self, x, *args, **kwargs):\n        \"\"\"\n        Forward pass of the model on a single scale. Wrapper for `_forward_once` method.\n        Args:\n            x (torch.Tensor | dict): The input image tensor or a dict including image tensor and gt labels.\n        Returns:\n            (torch.Tensor): The output of the network.\n        \"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "DetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class DetectionModel(BaseModel):\n    \"\"\"YOLOv8 detection model.\"\"\"\n    def __init__(self, cfg=\"yolov8n.yaml\", ch=3, nc=None, verbose=True):  # model, input channels, number of classes\n        \"\"\"Initialize the YOLOv8 detection model with the given config and parameters.\"\"\"\n        super().__init__()\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n        # Define model\n        ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "OBBModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class OBBModel(DetectionModel):\n    \"\"\"YOLOv8 Oriented Bounding Box (OBB) model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-obb.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 OBB model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the model.\"\"\"\n        return v8OBBLoss(self)\nclass SegmentationModel(DetectionModel):\n    \"\"\"YOLOv8 segmentation model.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "SegmentationModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class SegmentationModel(DetectionModel):\n    \"\"\"YOLOv8 segmentation model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-seg.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 segmentation model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the SegmentationModel.\"\"\"\n        return v8SegmentationLoss(self)\nclass PoseModel(DetectionModel):\n    \"\"\"YOLOv8 pose model.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "PoseModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class PoseModel(DetectionModel):\n    \"\"\"YOLOv8 pose model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-pose.yaml\", ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):\n        \"\"\"Initialize YOLOv8 Pose model.\"\"\"\n        if not isinstance(cfg, dict):\n            cfg = yaml_model_load(cfg)  # load model YAML\n        if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg[\"kpt_shape\"]):\n            LOGGER.info(f\"Overriding model.yaml kpt_shape={cfg['kpt_shape']} with kpt_shape={data_kpt_shape}\")\n            cfg[\"kpt_shape\"] = data_kpt_shape\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "ClassificationModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class ClassificationModel(BaseModel):\n    \"\"\"YOLOv8 classification model.\"\"\"\n    def __init__(self, cfg=\"yolov8n-cls.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Init ClassificationModel with YAML, channels, number of classes, verbose flag.\"\"\"\n        super().__init__()\n        self._from_yaml(cfg, ch, nc, verbose)\n    def _from_yaml(self, cfg, ch, nc, verbose):\n        \"\"\"Set YOLOv8 model configurations and define the model architecture.\"\"\"\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n        # Define model",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "RTDETRDetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class RTDETRDetectionModel(DetectionModel):\n    \"\"\"\n    RTDETR (Real-time DEtection and Tracking using Transformers) Detection Model class.\n    This class is responsible for constructing the RTDETR architecture, defining loss functions, and facilitating both\n    the training and inference processes. RTDETR is an object detection and tracking model that extends from the\n    DetectionModel base class.\n    Attributes:\n        cfg (str): The configuration file path or preset string. Default is 'rtdetr-l.yaml'.\n        ch (int): Number of input channels. Default is 3 (RGB).\n        nc (int, optional): Number of classes for object detection. Default is None.",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "WorldModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class WorldModel(DetectionModel):\n    \"\"\"YOLOv8 World Model.\"\"\"\n    def __init__(self, cfg=\"yolov8s-world.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 world model with given config and parameters.\"\"\"\n        self.txt_feats = torch.randn(1, nc or 80, 512)  # features placeholder\n        self.clip_model = None  # CLIP model placeholder\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n    def set_classes(self, text):\n        \"\"\"Perform a forward pass with optional profiling, visualization, and embedding extraction.\"\"\"\n        try:",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "YOLOv10DetectionModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class YOLOv10DetectionModel(DetectionModel):\n    def init_criterion(self):\n        return v10DetectLoss(self)\nclass Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize an ensemble of models.\"\"\"\n        super().__init__()\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Function generates the YOLO network's final layer.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "Ensemble",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "class Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize an ensemble of models.\"\"\"\n        super().__init__()\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Function generates the YOLO network's final layer.\"\"\"\n        y = [module(x, augment, profile, visualize)[0] for module in self]\n        # y = torch.stack(y).max(0)[0]  # max ensemble\n        # y = torch.stack(y).mean(0)  # mean ensemble",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "temporary_modules",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def temporary_modules(modules=None):\n    \"\"\"\n    Context manager for temporarily adding or modifying modules in Python's module cache (`sys.modules`).\n    This function can be used to change the module paths during runtime. It's useful when refactoring code,\n    where you've moved a module from one location to another, but you still want to support the old import\n    paths for backwards compatibility.\n    Args:\n        modules (dict, optional): A dictionary mapping old module paths to new module paths.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "torch_safe_load",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def torch_safe_load(weight):\n    \"\"\"\n    This function attempts to load a PyTorch model with the torch.load() function. If a ModuleNotFoundError is raised,\n    it catches the error, logs a warning message, and attempts to install the missing module via the\n    check_requirements() function. After installation, the function again attempts to load the model using torch.load().\n    Args:\n        weight (str): The file path of the PyTorch model.\n    Returns:\n        (dict): The loaded PyTorch model.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_weights",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def attempt_load_weights(weights, device=None, inplace=True, fuse=False):\n    \"\"\"Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a.\"\"\"\n    ensemble = Ensemble()\n    for w in weights if isinstance(weights, list) else [weights]:\n        ckpt, w = torch_safe_load(w)  # load ckpt\n        args = {**DEFAULT_CFG_DICT, **ckpt[\"train_args\"]} if \"train_args\" in ckpt else None  # combined args\n        model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n        # Model compatibility updates\n        model.args = args  # attach args to model\n        model.pt_path = w  # attach *.pt file path to model",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "attempt_load_one_weight",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def attempt_load_one_weight(weight, device=None, inplace=True, fuse=False):\n    \"\"\"Loads a single model weights.\"\"\"\n    ckpt, weight = torch_safe_load(weight)  # load ckpt\n    args = {**DEFAULT_CFG_DICT, **(ckpt.get(\"train_args\", {}))}  # combine model and default args, preferring model args\n    model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n    # Model compatibility updates\n    model.args = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # attach args to model\n    model.pt_path = weight  # attach *.pt file path to model\n    model.task = guess_model_task(model)\n    if not hasattr(model, \"stride\"):",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "parse_model",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def parse_model(d, ch, verbose=True):  # model_dict, input_channels(3)\n    \"\"\"Parse a YOLO model.yaml dictionary into a PyTorch model.\"\"\"\n    import ast\n    # Args\n    max_channels = float(\"inf\")\n    nc, act, scales = (d.get(x) for x in (\"nc\", \"activation\", \"scales\"))\n    depth, width, kpt_shape = (d.get(x, 1.0) for x in (\"depth_multiple\", \"width_multiple\", \"kpt_shape\"))\n    if scales:\n        scale = d.get(\"scale\")\n        if not scale:",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "yaml_model_load",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def yaml_model_load(path):\n    \"\"\"Load a YOLOv8 model from a YAML file.\"\"\"\n    import re\n    path = Path(path)\n    if path.stem in (f\"yolov{d}{x}6\" for x in \"nsmlx\" for d in (5, 8)):\n        new_stem = re.sub(r\"(\\d+)([nslmx])6(.+)?$\", r\"\\1\\2-p6\\3\", path.stem)\n        LOGGER.warning(f\"WARNING  Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.\")\n        path = path.with_name(new_stem + path.suffix)\n    if \"v10\" not in str(path):\n        unified_path = re.sub(r\"(\\d+)([nsblmx])(.+)?$\", r\"\\1\\3\", str(path))  # i.e. yolov8x.yaml -> yolov8.yaml",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_scale",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def guess_model_scale(model_path):\n    \"\"\"\n    Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function\n    uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by\n    n, s, m, l, or x. The function returns the size character of the model scale as a string.\n    Args:\n        model_path (str | Path): The path to the YOLO model's YAML file.\n    Returns:\n        (str): The size character of the model's scale, which can be n, s, m, l, or x.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "guess_model_task",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.nn.tasks",
        "description": "Identification.yolov10.ultralytics.nn.tasks",
        "peekOfCode": "def guess_model_task(model):\n    \"\"\"\n    Guess the task of a PyTorch model from its architecture or configuration.\n    Args:\n        model (nn.Module | dict): PyTorch model or model configuration in YAML format.\n    Returns:\n        (str): Task of the model ('detect', 'segment', 'classify', 'pose').\n    Raises:\n        SyntaxError: If the task of the model could not be determined.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.nn.tasks",
        "documentation": {}
    },
    {
        "label": "AIGym",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.solutions.ai_gym",
        "description": "Identification.yolov10.ultralytics.solutions.ai_gym",
        "peekOfCode": "class AIGym:\n    \"\"\"A class to manage the gym steps of people in a real-time video stream based on their poses.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the AIGym with default values for Visual and Image parameters.\"\"\"\n        # Image and line thickness\n        self.im0 = None\n        self.tf = None\n        # Keypoints and count information\n        self.keypoints = None\n        self.poseup_angle = None",
        "detail": "Identification.yolov10.ultralytics.solutions.ai_gym",
        "documentation": {}
    },
    {
        "label": "DistanceCalculation",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.solutions.distance_calculation",
        "description": "Identification.yolov10.ultralytics.solutions.distance_calculation",
        "peekOfCode": "class DistanceCalculation:\n    \"\"\"A class to calculate distance between two objects in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the distance calculation class with default values for Visual, Image, track and distance\n        parameters.\n        \"\"\"\n        # Visual & im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False",
        "detail": "Identification.yolov10.ultralytics.solutions.distance_calculation",
        "documentation": {}
    },
    {
        "label": "Heatmap",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.solutions.heatmap",
        "description": "Identification.yolov10.ultralytics.solutions.heatmap",
        "peekOfCode": "class Heatmap:\n    \"\"\"A class to draw heatmaps in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the heatmap class with default values for Visual, Image, track, count and heatmap parameters.\"\"\"\n        # Visual information\n        self.annotator = None\n        self.view_img = False\n        self.shape = \"circle\"\n        # Image information\n        self.imw = None",
        "detail": "Identification.yolov10.ultralytics.solutions.heatmap",
        "documentation": {}
    },
    {
        "label": "ObjectCounter",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.solutions.object_counter",
        "description": "Identification.yolov10.ultralytics.solutions.object_counter",
        "peekOfCode": "class ObjectCounter:\n    \"\"\"A class to manage the counting of objects in a real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the Counter with default values for various tracking and counting parameters.\"\"\"\n        # Mouse events\n        self.is_drawing = False\n        self.selected_point = None\n        # Region & Line Information\n        self.reg_pts = [(20, 400), (1260, 400)]\n        self.line_dist_thresh = 15",
        "detail": "Identification.yolov10.ultralytics.solutions.object_counter",
        "documentation": {}
    },
    {
        "label": "SpeedEstimator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.solutions.speed_estimation",
        "description": "Identification.yolov10.ultralytics.solutions.speed_estimation",
        "peekOfCode": "class SpeedEstimator:\n    \"\"\"A class to estimation speed of objects in real-time video stream based on their tracks.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the speed-estimator class with default values for Visual, Image, track and speed parameters.\"\"\"\n        # Visual & im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False\n        # Region information\n        self.reg_pts = [(20, 400), (1260, 400)]",
        "detail": "Identification.yolov10.ultralytics.solutions.speed_estimation",
        "documentation": {}
    },
    {
        "label": "GMC",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.gmc",
        "description": "Identification.yolov10.ultralytics.trackers.utils.gmc",
        "peekOfCode": "class GMC:\n    \"\"\"\n    Generalized Motion Compensation (GMC) class for tracking and object detection in video frames.\n    This class provides methods for tracking and detecting objects based on several tracking algorithms including ORB,\n    SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of frames for computational efficiency.\n    Attributes:\n        method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.\n        downscale (int): Factor by which to downscale the frames for processing.\n        prevFrame (np.ndarray): Stores the previous frame for tracking.\n        prevKeyPoints (list): Stores the keypoints from the previous frame.",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.gmc",
        "documentation": {}
    },
    {
        "label": "KalmanFilterXYAH",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "description": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "peekOfCode": "class KalmanFilterXYAH:\n    \"\"\"\n    For bytetrack. A simple Kalman filter for tracking bounding boxes in image space.\n    The 8-dimensional state space (x, y, a, h, vx, vy, va, vh) contains the bounding box center position (x, y), aspect\n    ratio a, height h, and their respective velocities.\n    Object motion follows a constant velocity model. The bounding box location (x, y, a, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize Kalman filter model matrices with motion and observation uncertainty weights.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "documentation": {}
    },
    {
        "label": "KalmanFilterXYWH",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "description": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "peekOfCode": "class KalmanFilterXYWH(KalmanFilterXYAH):\n    \"\"\"\n    For BoT-SORT. A simple Kalman filter for tracking bounding boxes in image space.\n    The 8-dimensional state space (x, y, w, h, vx, vy, vw, vh) contains the bounding box center position (x, y), width\n    w, height h, and their respective velocities.\n    Object motion follows a constant velocity model. The bounding box location (x, y, w, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n    def initiate(self, measurement: np.ndarray) -> tuple:\n        \"\"\"",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.kalman_filter",
        "documentation": {}
    },
    {
        "label": "linear_assignment",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "peekOfCode": "def linear_assignment(cost_matrix: np.ndarray, thresh: float, use_lap: bool = True) -> tuple:\n    \"\"\"\n    Perform linear assignment using scipy or lap.lapjv.\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        thresh (float): Threshold for considering an assignment valid.\n        use_lap (bool, optional): Whether to use lap.lapjv. Defaults to True.\n    Returns:\n        Tuple with:\n            - matched indices",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "iou_distance",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "peekOfCode": "def iou_distance(atracks: list, btracks: list) -> np.ndarray:\n    \"\"\"\n    Compute cost based on Intersection over Union (IoU) between tracks.\n    Args:\n        atracks (list[STrack] | list[np.ndarray]): List of tracks 'a' or bounding boxes.\n        btracks (list[STrack] | list[np.ndarray]): List of tracks 'b' or bounding boxes.\n    Returns:\n        (np.ndarray): Cost matrix computed based on IoU.\n    \"\"\"\n    if atracks and isinstance(atracks[0], np.ndarray) or btracks and isinstance(btracks[0], np.ndarray):",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "embedding_distance",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "peekOfCode": "def embedding_distance(tracks: list, detections: list, metric: str = \"cosine\") -> np.ndarray:\n    \"\"\"\n    Compute distance between tracks and detections based on embeddings.\n    Args:\n        tracks (list[STrack]): List of tracks.\n        detections (list[BaseTrack]): List of detections.\n        metric (str, optional): Metric for distance computation. Defaults to 'cosine'.\n    Returns:\n        (np.ndarray): Cost matrix computed based on embeddings.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "fuse_score",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "description": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "peekOfCode": "def fuse_score(cost_matrix: np.ndarray, detections: list) -> np.ndarray:\n    \"\"\"\n    Fuses cost matrix with detection scores to produce a single similarity matrix.\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        detections (list[BaseTrack]): List of detections with scores.\n    Returns:\n        (np.ndarray): Fused similarity matrix.\n    \"\"\"\n    if cost_matrix.size == 0:",
        "detail": "Identification.yolov10.ultralytics.trackers.utils.matching",
        "documentation": {}
    },
    {
        "label": "TrackState",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.basetrack",
        "description": "Identification.yolov10.ultralytics.trackers.basetrack",
        "peekOfCode": "class TrackState:\n    \"\"\"\n    Enumeration class representing the possible states of an object being tracked.\n    Attributes:\n        New (int): State when the object is newly detected.\n        Tracked (int): State when the object is successfully tracked in subsequent frames.\n        Lost (int): State when the object is no longer tracked.\n        Removed (int): State when the object is removed from tracking.\n    \"\"\"\n    New = 0",
        "detail": "Identification.yolov10.ultralytics.trackers.basetrack",
        "documentation": {}
    },
    {
        "label": "BaseTrack",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.basetrack",
        "description": "Identification.yolov10.ultralytics.trackers.basetrack",
        "peekOfCode": "class BaseTrack:\n    \"\"\"\n    Base class for object tracking, providing foundational attributes and methods.\n    Attributes:\n        _count (int): Class-level counter for unique track IDs.\n        track_id (int): Unique identifier for the track.\n        is_activated (bool): Flag indicating whether the track is currently active.\n        state (TrackState): Current state of the track.\n        history (OrderedDict): Ordered history of the track's states.\n        features (list): List of features extracted from the object for tracking.",
        "detail": "Identification.yolov10.ultralytics.trackers.basetrack",
        "documentation": {}
    },
    {
        "label": "BOTrack",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "description": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "peekOfCode": "class BOTrack(STrack):\n    \"\"\"\n    An extended version of the STrack class for YOLOv8, adding object tracking features.\n    Attributes:\n        shared_kalman (KalmanFilterXYWH): A shared Kalman filter for all instances of BOTrack.\n        smooth_feat (np.ndarray): Smoothed feature vector.\n        curr_feat (np.ndarray): Current feature vector.\n        features (deque): A deque to store feature vectors with a maximum length defined by `feat_history`.\n        alpha (float): Smoothing factor for the exponential moving average of features.\n        mean (np.ndarray): The mean state of the Kalman filter.",
        "detail": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "documentation": {}
    },
    {
        "label": "BOTSORT",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "description": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "peekOfCode": "class BOTSORT(BYTETracker):\n    \"\"\"\n    An extended version of the BYTETracker class for YOLOv8, designed for object tracking with ReID and GMC algorithm.\n    Attributes:\n        proximity_thresh (float): Threshold for spatial proximity (IoU) between tracks and detections.\n        appearance_thresh (float): Threshold for appearance similarity (ReID embeddings) between tracks and detections.\n        encoder (object): Object to handle ReID embeddings, set to None if ReID is not enabled.\n        gmc (GMC): An instance of the GMC algorithm for data association.\n        args (object): Parsed command-line arguments containing tracking parameters.\n    Methods:",
        "detail": "Identification.yolov10.ultralytics.trackers.bot_sort",
        "documentation": {}
    },
    {
        "label": "STrack",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "description": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "peekOfCode": "class STrack(BaseTrack):\n    \"\"\"\n    Single object tracking representation that uses Kalman filtering for state estimation.\n    This class is responsible for storing all the information regarding individual tracklets and performs state updates\n    and predictions based on Kalman filter.\n    Attributes:\n        shared_kalman (KalmanFilterXYAH): Shared Kalman filter that is used across all STrack instances for prediction.\n        _tlwh (np.ndarray): Private attribute to store top-left corner coordinates and width and height of bounding box.\n        kalman_filter (KalmanFilterXYAH): Instance of Kalman filter used for this particular object track.\n        mean (np.ndarray): Mean state estimate vector.",
        "detail": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "documentation": {}
    },
    {
        "label": "BYTETracker",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "description": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "peekOfCode": "class BYTETracker:\n    \"\"\"\n    BYTETracker: A tracking algorithm built on top of YOLOv8 for object detection and tracking.\n    The class is responsible for initializing, updating, and managing the tracks for detected objects in a video\n    sequence. It maintains the state of tracked, lost, and removed tracks over frames, utilizes Kalman filtering for\n    predicting the new object locations, and performs data association.\n    Attributes:\n        tracked_stracks (list[STrack]): List of successfully activated tracks.\n        lost_stracks (list[STrack]): List of lost tracks.\n        removed_stracks (list[STrack]): List of removed tracks.",
        "detail": "Identification.yolov10.ultralytics.trackers.byte_tracker",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.track",
        "description": "Identification.yolov10.ultralytics.trackers.track",
        "peekOfCode": "def on_predict_start(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Initialize trackers for object tracking during prediction.\n    Args:\n        predictor (object): The predictor object to initialize trackers for.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    Raises:\n        AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.\n    \"\"\"\n    if hasattr(predictor, \"trackers\") and persist:",
        "detail": "Identification.yolov10.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "on_predict_postprocess_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.track",
        "description": "Identification.yolov10.ultralytics.trackers.track",
        "peekOfCode": "def on_predict_postprocess_end(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Postprocess detected boxes and update with object tracking.\n    Args:\n        predictor (object): The predictor object containing the predictions.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    \"\"\"\n    path, im0s = predictor.batch[:2]\n    is_obb = predictor.args.task == \"obb\"\n    is_stream = predictor.dataset.mode == \"stream\"",
        "detail": "Identification.yolov10.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "register_tracker",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.trackers.track",
        "description": "Identification.yolov10.ultralytics.trackers.track",
        "peekOfCode": "def register_tracker(model: object, persist: bool) -> None:\n    \"\"\"\n    Register tracking callbacks to the model for object tracking during prediction.\n    Args:\n        model (object): The model object to register tracking callbacks for.\n        persist (bool): Whether to persist the trackers if they already exist.\n    \"\"\"\n    model.add_callback(\"on_predict_start\", partial(on_predict_start, persist=persist))\n    model.add_callback(\"on_predict_postprocess_end\", partial(on_predict_postprocess_end, persist=persist))",
        "detail": "Identification.yolov10.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "TRACKER_MAP",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.trackers.track",
        "description": "Identification.yolov10.ultralytics.trackers.track",
        "peekOfCode": "TRACKER_MAP = {\"bytetrack\": BYTETracker, \"botsort\": BOTSORT}\ndef on_predict_start(predictor: object, persist: bool = False) -> None:\n    \"\"\"\n    Initialize trackers for object tracking during prediction.\n    Args:\n        predictor (object): The predictor object to initialize trackers for.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    Raises:\n        AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.trackers.track",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Called before the pretraining routine starts.\"\"\"\n    pass\ndef on_pretrain_routine_end(trainer):\n    \"\"\"Called after the pretraining routine ends.\"\"\"\n    pass\ndef on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Called after the pretraining routine ends.\"\"\"\n    pass\ndef on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\ndef on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\ndef on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\ndef optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "optimizer_step",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\ndef on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_before_zero_grad",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\ndef on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\ndef on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\ndef on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\ndef on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_model_save",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\ndef on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\ndef on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_params_update",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\ndef teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------\ndef on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "teardown",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n# Validator callbacks --------------------------------------------------------------------------------------------------\ndef on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass\ndef on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass\ndef on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass\ndef on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass\ndef on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\ndef on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------\ndef on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n# Predictor callbacks --------------------------------------------------------------------------------------------------\ndef on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass\ndef on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass\ndef on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass\ndef on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_batch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass\ndef on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_batch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\ndef on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_postprocess_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\ndef on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------\ndef on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_predict_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n# Exporter callbacks ---------------------------------------------------------------------------------------------------\ndef on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass\ndef on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_export_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass\ndef on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass\ndefault_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_export_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass\ndefault_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],\n    \"on_train_start\": [on_train_start],\n    \"on_train_epoch_start\": [on_train_epoch_start],\n    \"on_train_batch_start\": [on_train_batch_start],",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "get_default_callbacks",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def get_default_callbacks():\n    \"\"\"\n    Return a copy of the default_callbacks dictionary with lists as default values.\n    Returns:\n        (defaultdict): A defaultdict with keys from default_callbacks and empty lists as default values.\n    \"\"\"\n    return defaultdict(list, deepcopy(default_callbacks))\ndef add_integration_callbacks(instance):\n    \"\"\"\n    Add integration callbacks from various sources to the instance's callbacks.",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "add_integration_callbacks",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "def add_integration_callbacks(instance):\n    \"\"\"\n    Add integration callbacks from various sources to the instance's callbacks.\n    Args:\n        instance (Trainer, Predictor, Validator, Exporter): An object with a 'callbacks' attribute that is a dictionary\n            of callback lists.\n    \"\"\"\n    # Load HUB callbacks\n    from .hub import callbacks as hub_cb\n    callbacks_list = [hub_cb]",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "default_callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "peekOfCode": "default_callbacks = {\n    # Run in trainer\n    \"on_pretrain_routine_start\": [on_pretrain_routine_start],\n    \"on_pretrain_routine_end\": [on_pretrain_routine_end],\n    \"on_train_start\": [on_train_start],\n    \"on_train_epoch_start\": [on_train_epoch_start],\n    \"on_train_batch_start\": [on_train_batch_start],\n    \"optimizer_step\": [optimizer_step],\n    \"on_before_zero_grad\": [on_before_zero_grad],\n    \"on_train_batch_end\": [on_train_batch_end],",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.base",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Runs at start of pretraining routine; initializes and connects/ logs task to ClearML.\"\"\"\n    try:\n        if task := Task.current_task():\n            # Make sure the automatic pytorch and matplotlib bindings are disabled!\n            # We are logging these plots and model files manually in the integration\n            PatchPyTorchModelIO.update_current_task(None)\n            PatchedMatplotlib.update_current_task(None)\n        else:\n            task = Task.init(",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Logs debug samples for the first epoch of YOLO training and report current training progress.\"\"\"\n    if task := Task.current_task():\n        # Log debug samples\n        if trainer.epoch == 1:\n            _log_debug_samples(sorted(trainer.save_dir.glob(\"train_batch*.jpg\")), \"Mosaic\")\n        # Report the current training progress\n        for k, v in trainer.label_loss_items(trainer.tloss, prefix=\"train\").items():\n            task.get_logger().report_scalar(\"train\", k, v, iteration=trainer.epoch)\n        for k, v in trainer.lr.items():",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Reports model information to logger at the end of an epoch.\"\"\"\n    if task := Task.current_task():\n        # You should have access to the validation bboxes under jdict\n        task.get_logger().report_scalar(\n            title=\"Epoch Time\", series=\"Epoch Time\", value=trainer.epoch_time, iteration=trainer.epoch\n        )\n        for k, v in trainer.metrics.items():\n            task.get_logger().report_scalar(\"val\", k, v, iteration=trainer.epoch)\n        if trainer.epoch == 0:",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Logs validation results including labels and predictions.\"\"\"\n    if Task.current_task():\n        # Log val_labels and val_pred\n        _log_debug_samples(sorted(validator.save_dir.glob(\"val*.jpg\")), \"Validation\")\ndef on_train_end(trainer):\n    \"\"\"Logs final model and its name on training completion.\"\"\"\n    if task := Task.current_task():\n        # Log final results, CM matrix + PR plots\n        files = [",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Logs final model and its name on training completion.\"\"\"\n    if task := Task.current_task():\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_val_end\": on_val_end,\n        \"on_train_end\": on_train_end,\n    }\n    if clearml\n    else {}",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.clearml",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Creates or resumes a CometML experiment at the start of a YOLO pre-training routine.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    is_alive = getattr(experiment, \"alive\", False)\n    if not experiment or not is_alive:\n        _create_experiment(trainer.args)\ndef on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save batch images at the end of training epochs.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save batch images at the end of training epochs.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    experiment.log_metrics(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=curr_step, epoch=curr_epoch)\n    if curr_epoch == 1:",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs model assets at the end of each epoch.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    save_assets = metadata[\"save_assets\"]\n    experiment.log_metrics(trainer.metrics, step=curr_step, epoch=curr_epoch)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Perform operations at the end of training.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    plots = trainer.args.plots\n    _log_model(experiment, trainer)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if comet_ml\n    else {}\n)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.comet",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initializes DVCLive logger for training metadata during pre-training routine.\"\"\"\n    try:\n        global live\n        live = dvclive.Live(save_dvc_exp=True, cache_images=True)\n        LOGGER.info(\"DVCLive is detected and auto logging is enabled (run 'yolo settings dvc=False' to disable).\")\n    except Exception as e:\n        LOGGER.warning(f\"WARNING  DVCLive installed but not initialized correctly, not logging this run. {e}\")\ndef on_pretrain_routine_end(trainer):\n    \"\"\"Logs plots related to the training process at the end of the pretraining routine.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Logs plots related to the training process at the end of the pretraining routine.\"\"\"\n    _log_plots(trainer.plots, \"train\")\ndef on_train_start(trainer):\n    \"\"\"Logs the training parameters if DVCLive logging is active.\"\"\"\n    if live:\n        live.log_params(trainer.args)\ndef on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Logs the training parameters if DVCLive logging is active.\"\"\"\n    if live:\n        live.log_params(trainer.args)\ndef on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch\n    _training_epoch = True\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch\n    _training_epoch = True\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"\n    global _training_epoch\n    if live and _training_epoch:\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"\n    global _training_epoch\n    if live and _training_epoch:\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value)\n        if trainer.epoch == 0:\n            from ultralytics.utils.torch_utils import model_info_for_loggers\n            for metric, value in model_info_for_loggers(trainer).items():",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Logs the best metrics, plots, and confusion matrix at the end of training if DVCLive is active.\"\"\"\n    if live:\n        # At the end log the best metrics. It runs validator on the best model internally.\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value, plot=False)\n        _log_plots(trainer.plots, \"val\")\n        _log_plots(trainer.validator.plots, \"val\")\n        _log_confusion_matrix(trainer.validator)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_train_start\": on_train_start,\n        \"on_train_epoch_start\": on_train_epoch_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if dvclive",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.dvc",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"Logs info before starting timer for upload rate limit.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Start timer for upload rate limit\n        session.timers = {\n            \"metrics\": time(),\n            \"ckpt\": time(),\n        }  # start timer on session.rate_limit\ndef on_fit_epoch_end(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Uploads training progress metrics at the end of each epoch.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload metrics after val end\n        all_plots = {\n            **trainer.label_loss_items(trainer.tloss, prefix=\"train\"),\n            **trainer.metrics,\n        }\n        if trainer.epoch == 0:",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_model_save",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_model_save(trainer):\n    \"\"\"Saves checkpoints to Ultralytics HUB with rate limiting.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload checkpoints with rate limiting\n        is_best = trainer.best_fitness == trainer.fitness\n        if time() - session.timers[\"ckpt\"] > session.rate_limits[\"ckpt\"]:\n            LOGGER.info(f\"{PREFIX}Uploading checkpoint {HUB_WEB_ROOT}/models/{session.model.id}\")\n            session.upload_model(trainer.epoch, trainer.last, is_best)\n            session.timers[\"ckpt\"] = time()  # reset timer",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Upload final model and metrics to Ultralytics HUB at the end of training.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload final model and metrics with exponential standoff\n        LOGGER.info(f\"{PREFIX}Syncing final model...\")\n        session.upload_model(\n            trainer.epoch,\n            trainer.best,\n            map=trainer.metrics.get(\"metrics/mAP50-95(B)\", 0),",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Run events on train start.\"\"\"\n    events(trainer.args)\ndef on_val_start(validator):\n    \"\"\"Runs events on validation start.\"\"\"\n    events(validator.args)\ndef on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_val_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_val_start(validator):\n    \"\"\"Runs events on validation start.\"\"\"\n    events(validator.args)\ndef on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_predict_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\ndef on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_export_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "def on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\ncallbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_model_save\": on_model_save,\n        \"on_train_end\": on_train_end,\n        \"on_train_start\": on_train_start,",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_model_save\": on_model_save,\n        \"on_train_end\": on_train_end,\n        \"on_train_start\": on_train_start,\n        \"on_val_start\": on_val_start,\n        \"on_predict_start\": on_predict_start,\n        \"on_export_start\": on_export_start,",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.hub",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_pretrain_routine_end(trainer):\n    \"\"\"\n    Log training parameters to MLflow at the end of the pretraining routine.\n    This function sets up MLflow logging based on environment variables and trainer arguments. It sets the tracking URI,\n    experiment name, and run name, then starts the MLflow run if not already active. It finally logs the parameters\n    from the trainer.\n    Args:\n        trainer (ultralytics.engine.trainer.BaseTrainer): The training object with arguments and parameters to log.\n    Global:\n        mlflow: The imported mlflow module to use for logging.",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each train epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(\n            metrics={\n                **SANITIZE(trainer.lr),\n                **SANITIZE(trainer.label_loss_items(trainer.tloss, prefix=\"train\")),\n            },\n            step=trainer.epoch,\n        )",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each fit epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(metrics=SANITIZE(trainer.metrics), step=trainer.epoch)\ndef on_train_end(trainer):\n    \"\"\"Log model artifacts at the end of the training.\"\"\"\n    if mlflow:\n        mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt\n        for f in trainer.save_dir.glob(\"*\"):  # log all other files in save_dir\n            if f.suffix in {\".png\", \".jpg\", \".csv\", \".pt\", \".yaml\"}:",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Log model artifacts at the end of the training.\"\"\"\n    if mlflow:\n        mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt\n        for f in trainer.save_dir.glob(\"*\"):  # log all other files in save_dir\n            if f.suffix in {\".png\", \".jpg\", \".csv\", \".pt\", \".yaml\"}:\n                mlflow.log_artifact(str(f))\n        keep_run_active = os.environ.get(\"MLFLOW_KEEP_RUN_ACTIVE\", \"False\").lower() in (\"true\")\n        if keep_run_active:\n            LOGGER.info(f\"{PREFIX}mlflow run still alive, remember to close it using mlflow.end_run()\")",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_end\": on_pretrain_routine_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if mlflow\n    else {}\n)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.mlflow",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Callback function called before the training routine starts.\"\"\"\n    try:\n        global run\n        run = neptune.init_run(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, tags=[\"YOLOv8\"])\n        run[\"Configuration/Hyperparameters\"] = {k: \"\" if v is None else v for k, v in vars(trainer.args).items()}\n    except Exception as e:\n        LOGGER.warning(f\"WARNING  NeptuneAI installed but not initialized correctly, not logging this run. {e}\")\ndef on_train_epoch_end(trainer):\n    \"\"\"Callback function called at end of each training epoch.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Callback function called at end of each training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_images({f.stem: str(f) for f in trainer.save_dir.glob(\"train_batch*.jpg\")}, \"Mosaic\")\ndef on_fit_epoch_end(trainer):\n    \"\"\"Callback function called at end of each fit (train+val) epoch.\"\"\"\n    if run and trainer.epoch == 0:\n        from ultralytics.utils.torch_utils import model_info_for_loggers",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Callback function called at end of each fit (train+val) epoch.\"\"\"\n    if run and trainer.epoch == 0:\n        from ultralytics.utils.torch_utils import model_info_for_loggers\n        run[\"Configuration/Model\"] = model_info_for_loggers(trainer)\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ndef on_val_end(validator):\n    \"\"\"Callback function called at end of each validation.\"\"\"\n    if run:\n        # Log val_labels and val_pred",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_val_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_val_end(validator):\n    \"\"\"Callback function called at end of each validation.\"\"\"\n    if run:\n        # Log val_labels and val_pred\n        _log_images({f.stem: str(f) for f in validator.save_dir.glob(\"val*.jpg\")}, \"Validation\")\ndef on_train_end(trainer):\n    \"\"\"Callback function called at end of training.\"\"\"\n    if run:\n        # Log final results, CM matrix + PR plots\n        files = [",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Callback function called at end of training.\"\"\"\n    if run:\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_val_end\": on_val_end,\n        \"on_train_end\": on_train_end,\n    }\n    if neptune\n    else {}",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.neptune",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Sends training metrics to Ray Tune at end of each epoch.\"\"\"\n    if ray.tune.is_session_enabled():\n        metrics = trainer.metrics\n        metrics[\"epoch\"] = trainer.epoch\n        session.report(metrics)\ncallbacks = (\n    {\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n    }",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "peekOfCode": "callbacks = (\n    {\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n    }\n    if tune\n    else {}\n)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.raytune",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initialize TensorBoard logging with SummaryWriter.\"\"\"\n    if SummaryWriter:\n        try:\n            global WRITER\n            WRITER = SummaryWriter(str(trainer.save_dir))\n            LOGGER.info(f\"{PREFIX}Start with 'tensorboard --logdir {trainer.save_dir}', view at http://localhost:6006/\")\n        except Exception as e:\n            LOGGER.warning(f\"{PREFIX}WARNING  TensorBoard not initialized correctly, not logging this run. {e}\")\ndef on_train_start(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_train_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_train_start(trainer):\n    \"\"\"Log TensorBoard graph.\"\"\"\n    if WRITER:\n        _log_tensorboard_graph(trainer)\ndef on_train_epoch_end(trainer):\n    \"\"\"Logs scalar statistics at the end of a training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Logs scalar statistics at the end of a training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ncallbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\ncallbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_start\": on_train_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n    }",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_start\": on_train_start,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_epoch_end\": on_train_epoch_end,\n    }\n    if SummaryWriter\n    else {}\n)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.tensorboard",
        "documentation": {}
    },
    {
        "label": "on_pretrain_routine_start",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_pretrain_routine_start(trainer):\n    \"\"\"Initiate and start project if module is present.\"\"\"\n    wb.run or wb.init(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, config=vars(trainer.args))\ndef on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model information at the end of an epoch.\"\"\"\n    wb.run.log(trainer.metrics, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    if trainer.epoch == 0:\n        wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_fit_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model information at the end of an epoch.\"\"\"\n    wb.run.log(trainer.metrics, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    if trainer.epoch == 0:\n        wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)\ndef on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save images at the end of each training epoch.\"\"\"\n    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_train_epoch_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save images at the end of each training epoch.\"\"\"\n    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=trainer.epoch + 1)\n    wb.run.log(trainer.lr, step=trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_plots(trainer.plots, step=trainer.epoch + 1)\ndef on_train_end(trainer):\n    \"\"\"Save the best model as an artifact at end of training.\"\"\"\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "on_train_end",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "peekOfCode": "def on_train_end(trainer):\n    \"\"\"Save the best model as an artifact at end of training.\"\"\"\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    art = wb.Artifact(type=\"model\", name=f\"run_{wb.run.id}_model\")\n    if trainer.best.exists():\n        art.add_file(trainer.best)\n        wb.run.log_artifact(art, aliases=[\"best\"])\n    for curve_name, curve_values in zip(trainer.validator.metrics.curves, trainer.validator.metrics.curves_results):\n        x, y, x_title, y_title = curve_values",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "callbacks",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "description": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "peekOfCode": "callbacks = (\n    {\n        \"on_pretrain_routine_start\": on_pretrain_routine_start,\n        \"on_train_epoch_end\": on_train_epoch_end,\n        \"on_fit_epoch_end\": on_fit_epoch_end,\n        \"on_train_end\": on_train_end,\n    }\n    if wb\n    else {}\n)",
        "detail": "Identification.yolov10.ultralytics.utils.callbacks.wb",
        "documentation": {}
    },
    {
        "label": "check_train_batch_size",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.autobatch",
        "description": "Identification.yolov10.ultralytics.utils.autobatch",
        "peekOfCode": "def check_train_batch_size(model, imgsz=640, amp=True):\n    \"\"\"\n    Check YOLO training batch size using the autobatch() function.\n    Args:\n        model (torch.nn.Module): YOLO model to check batch size for.\n        imgsz (int): Image size used for training.\n        amp (bool): If True, use automatic mixed precision (AMP) for training.\n    Returns:\n        (int): Optimal batch size computed using the autobatch() function.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "autobatch",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.autobatch",
        "description": "Identification.yolov10.ultralytics.utils.autobatch",
        "peekOfCode": "def autobatch(model, imgsz=640, fraction=0.60, batch_size=DEFAULT_CFG.batch):\n    \"\"\"\n    Automatically estimate the best YOLO batch size to use a fraction of the available CUDA memory.\n    Args:\n        model (torch.nn.module): YOLO model to compute batch size for.\n        imgsz (int, optional): The image size used as input for the YOLO model. Defaults to 640.\n        fraction (float, optional): The fraction of available CUDA memory to use. Defaults to 0.60.\n        batch_size (int, optional): The default batch size to use if an error is detected. Defaults to 16.\n    Returns:\n        (int): The optimal batch size.",
        "detail": "Identification.yolov10.ultralytics.utils.autobatch",
        "documentation": {}
    },
    {
        "label": "ProfileModels",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.benchmarks",
        "description": "Identification.yolov10.ultralytics.utils.benchmarks",
        "peekOfCode": "class ProfileModels:\n    \"\"\"\n    ProfileModels class for profiling different models on ONNX and TensorRT.\n    This class profiles the performance of different models, returning results such as model speed and FLOPs.\n    Attributes:\n        paths (list): Paths of the models to profile.\n        num_timed_runs (int): Number of timed runs for the profiling. Default is 100.\n        num_warmup_runs (int): Number of warmup runs before profiling. Default is 10.\n        min_time (float): Minimum number of seconds to profile for. Default is 60.\n        imgsz (int): Image size used in the models. Default is 640.",
        "detail": "Identification.yolov10.ultralytics.utils.benchmarks",
        "documentation": {}
    },
    {
        "label": "benchmark",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.benchmarks",
        "description": "Identification.yolov10.ultralytics.utils.benchmarks",
        "peekOfCode": "def benchmark(\n    model=WEIGHTS_DIR / \"yolov8n.pt\", data=None, imgsz=160, half=False, int8=False, device=\"cpu\", verbose=False\n):\n    \"\"\"\n    Benchmark a YOLO model across different formats for speed and accuracy.\n    Args:\n        model (str | Path | optional): Path to the model file or directory. Default is\n            Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.\n        data (str, optional): Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.\n        imgsz (int, optional): Image size for the benchmark. Default is 160.",
        "detail": "Identification.yolov10.ultralytics.utils.benchmarks",
        "documentation": {}
    },
    {
        "label": "parse_requirements",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def parse_requirements(file_path=ROOT.parent / \"requirements.txt\", package=\"\"):\n    \"\"\"\n    Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.\n    Args:\n        file_path (Path): Path to the requirements.txt file.\n        package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.\n    Returns:\n        (List[Dict[str, str]]): List of parsed requirements as dictionaries with `name` and `specifier` keys.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "parse_version",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def parse_version(version=\"0.0.0\") -> tuple:\n    \"\"\"\n    Convert a version string to a tuple of integers, ignoring any extra non-numeric string attached to the version. This\n    function replaces deprecated 'pkg_resources.parse_version(v)'.\n    Args:\n        version (str): Version string, i.e. '2.0.1+cpu'\n    Returns:\n        (tuple): Tuple of integers representing the numeric part of the version and the extra string, i.e. (2, 0, 1)\n    \"\"\"\n    try:",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "is_ascii",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def is_ascii(s) -> bool:\n    \"\"\"\n    Check if a string is composed of only ASCII characters.\n    Args:\n        s (str): String to be checked.\n    Returns:\n        (bool): True if the string is composed only of ASCII characters, False otherwise.\n    \"\"\"\n    # Convert list, tuple, None, etc. to string\n    s = str(s)",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imgsz",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_imgsz(imgsz, stride=32, min_dim=1, max_dim=2, floor=0):\n    \"\"\"\n    Verify image size is a multiple of the given stride in each dimension. If the image size is not a multiple of the\n    stride, update it to the nearest multiple of the stride that is greater than or equal to the given floor value.\n    Args:\n        imgsz (int | cList[int]): Image size.\n        stride (int): Stride value.\n        min_dim (int): Minimum number of dimensions.\n        max_dim (int): Maximum number of dimensions.\n        floor (int): Minimum allowed value for image size.",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_version",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_version(\n    current: str = \"0.0.0\",\n    required: str = \"0.0.0\",\n    name: str = \"version\",\n    hard: bool = False,\n    verbose: bool = False,\n    msg: str = \"\",\n) -> bool:\n    \"\"\"\n    Check current version against the required version or range.",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_latest_pypi_version",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_latest_pypi_version(package_name=\"ultralytics\"):\n    \"\"\"\n    Returns the latest version of a PyPI package without downloading or installing it.\n    Parameters:\n        package_name (str): The name of the package to find the latest version for.\n    Returns:\n        (str): The latest version of the package.\n    \"\"\"\n    with contextlib.suppress(Exception):\n        requests.packages.urllib3.disable_warnings()  # Disable the InsecureRequestWarning",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_pip_update_available",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_pip_update_available():\n    \"\"\"\n    Checks if a new version of the ultralytics package is available on PyPI.\n    Returns:\n        (bool): True if an update is available, False otherwise.\n    \"\"\"\n    if ONLINE and is_pip_package():\n        with contextlib.suppress(Exception):\n            from ultralytics import __version__\n            latest = check_latest_pypi_version()",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_font",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_font(font=\"Arial.ttf\"):\n    \"\"\"\n    Find font locally or download to user's configuration directory if it does not already exist.\n    Args:\n        font (str): Path or name of font.\n    Returns:\n        file (Path): Resolved font file path.\n    \"\"\"\n    name = Path(font).name\n    # Check USER_CONFIG_DIR",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_python",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_python(minimum: str = \"3.8.0\") -> bool:\n    \"\"\"\n    Check current python version against the required minimum version.\n    Args:\n        minimum (str): Required minimum version of python.\n    Returns:\n        (bool): Whether the installed Python version meets the minimum constraints.\n    \"\"\"\n    return check_version(PYTHON_VERSION, minimum, name=\"Python \", hard=True)\n@TryExcept()",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_requirements",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_requirements(requirements=ROOT.parent / \"requirements.txt\", exclude=(), install=True, cmds=\"\"):\n    \"\"\"\n    Check if installed dependencies meet YOLOv8 requirements and attempt to auto-update if needed.\n    Args:\n        requirements (Union[Path, str, List[str]]): Path to a requirements.txt file, a single package requirement as a\n            string, or a list of package requirements as strings.\n        exclude (Tuple[str]): Tuple of package names to exclude from checking.\n        install (bool): If True, attempt to auto-update packages that don't meet requirements.\n        cmds (str): Additional commands to pass to the pip install command when auto-updating.\n    Example:",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_torchvision",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_torchvision():\n    \"\"\"\n    Checks the installed versions of PyTorch and Torchvision to ensure they're compatible.\n    This function checks the installed versions of PyTorch and Torchvision, and warns if they're incompatible according\n    to the provided compatibility table based on:\n    https://github.com/pytorch/vision#installation.\n    The compatibility table is a dictionary where the keys are PyTorch versions and the values are lists of compatible\n    Torchvision versions.\n    \"\"\"\n    import torchvision",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_suffix",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_suffix(file=\"yolov8n.pt\", suffix=\".pt\", msg=\"\"):\n    \"\"\"Check file(s) for acceptable suffix.\"\"\"\n    if file and suffix:\n        if isinstance(suffix, str):\n            suffix = (suffix,)\n        for f in file if isinstance(file, (list, tuple)) else [file]:\n            s = Path(f).suffix.lower().strip()  # file suffix\n            if len(s):\n                assert s in suffix, f\"{msg}{f} acceptable suffix is {suffix}, not {s}\"\ndef check_yolov5u_filename(file: str, verbose: bool = True):",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolov5u_filename",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_yolov5u_filename(file: str, verbose: bool = True):\n    \"\"\"Replace legacy YOLOv5 filenames with updated YOLOv5u filenames.\"\"\"\n    if \"yolov3\" in file or \"yolov5\" in file:\n        if \"u.yaml\" in file:\n            file = file.replace(\"u.yaml\", \".yaml\")  # i.e. yolov5nu.yaml -> yolov5n.yaml\n        elif \".pt\" in file and \"u\" not in file:\n            original_file = file\n            file = re.sub(r\"(.*yolov5([nsmlx]))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n.pt -> yolov5nu.pt\n            file = re.sub(r\"(.*yolov5([nsmlx])6)\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n6.pt -> yolov5n6u.pt\n            file = re.sub(r\"(.*yolov3(|-tiny|-spp))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov3-spp.pt -> yolov3-sppu.pt",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_model_file_from_stem",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_model_file_from_stem(model=\"yolov8n\"):\n    \"\"\"Return a model filename from a valid model stem.\"\"\"\n    if model and not Path(model).suffix and Path(model).stem in downloads.GITHUB_ASSETS_STEMS:\n        return Path(model).with_suffix(\".pt\")  # add suffix, i.e. yolov8n -> yolov8n.pt\n    else:\n        return model\ndef check_file(file, suffix=\"\", download=True, hard=True):\n    \"\"\"Search/download file (if necessary) and return path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file).strip()  # convert to string and strip spaces",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_file",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_file(file, suffix=\"\", download=True, hard=True):\n    \"\"\"Search/download file (if necessary) and return path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file).strip()  # convert to string and strip spaces\n    file = check_yolov5u_filename(file)  # yolov5n -> yolov5nu\n    if (\n        not file\n        or (\"://\" not in file and Path(file).exists())  # '://' check required in Windows Python<3.10\n        or file.lower().startswith(\"grpc://\")\n    ):  # file exists or gRPC Triton images",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yaml",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_yaml(file, suffix=(\".yaml\", \".yml\"), hard=True):\n    \"\"\"Search/download YAML file (if necessary) and return path, checking suffix.\"\"\"\n    return check_file(file, suffix, hard=hard)\ndef check_is_path_safe(basedir, path):\n    \"\"\"\n    Check if the resolved path is under the intended directory to prevent path traversal.\n    Args:\n        basedir (Path | str): The intended directory.\n        path (Path | str): The path to check.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_is_path_safe",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_is_path_safe(basedir, path):\n    \"\"\"\n    Check if the resolved path is under the intended directory to prevent path traversal.\n    Args:\n        basedir (Path | str): The intended directory.\n        path (Path | str): The path to check.\n    Returns:\n        (bool): True if the path is safe, False otherwise.\n    \"\"\"\n    base_dir_resolved = Path(basedir).resolve()",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_imshow",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_imshow(warn=False):\n    \"\"\"Check if environment supports image displays.\"\"\"\n    try:\n        if LINUX:\n            assert \"DISPLAY\" in os.environ and not is_docker() and not is_colab() and not is_kaggle()\n        cv2.imshow(\"test\", np.zeros((8, 8, 3), dtype=np.uint8))  # show a small 8-pixel image\n        cv2.waitKey(1)\n        cv2.destroyAllWindows()\n        cv2.waitKey(1)\n        return True",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_yolo",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_yolo(verbose=True, device=\"\"):\n    \"\"\"Return a human-readable YOLO software and hardware summary.\"\"\"\n    import psutil\n    from ultralytics.utils.torch_utils import select_device\n    if is_jupyter():\n        if check_requirements(\"wandb\", install=False):\n            os.system(\"pip uninstall -y wandb\")  # uninstall wandb: unwanted account creation prompt with infinite hang\n        if is_colab():\n            shutil.rmtree(\"sample_data\", ignore_errors=True)  # remove colab /sample_data directory\n    if verbose:",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "collect_system_info",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def collect_system_info():\n    \"\"\"Collect and print relevant system information including OS, Python, RAM, CPU, and CUDA.\"\"\"\n    import psutil\n    from ultralytics.utils import ENVIRONMENT, is_git_dir\n    from ultralytics.utils.torch_utils import get_cpu_info\n    ram_info = psutil.virtual_memory().total / (1024**3)  # Convert bytes to GB\n    check_yolo()\n    LOGGER.info(\n        f\"\\n{'OS':<20}{platform.platform()}\\n\"\n        f\"{'Environment':<20}{ENVIRONMENT}\\n\"",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "check_amp",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def check_amp(model):\n    \"\"\"\n    This function checks the PyTorch Automatic Mixed Precision (AMP) functionality of a YOLOv8 model. If the checks\n    fail, it means there are anomalies with AMP on the system that may cause NaN losses or zero-mAP results, so AMP will\n    be disabled during training.\n    Args:\n        model (nn.Module): A YOLOv8 model instance.\n    Example:\n        ```python\n        from ultralytics import YOLO",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "git_describe",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def git_describe(path=ROOT):  # path must be a directory\n    \"\"\"Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe.\"\"\"\n    with contextlib.suppress(Exception):\n        return subprocess.check_output(f\"git -C {path} describe --tags --long --always\", shell=True).decode()[:-1]\n    return \"\"\ndef print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Print function arguments (optional args dict).\"\"\"\n    def strip_auth(v):\n        \"\"\"Clean longer Ultralytics HUB URLs by stripping potential authentication information.\"\"\"\n        return clean_url(v) if (isinstance(v, str) and v.startswith(\"http\") and len(v) > 100) else v",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "print_args",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Print function arguments (optional args dict).\"\"\"\n    def strip_auth(v):\n        \"\"\"Clean longer Ultralytics HUB URLs by stripping potential authentication information.\"\"\"\n        return clean_url(v) if (isinstance(v, str) and v.startswith(\"http\") and len(v) > 100) else v\n    x = inspect.currentframe().f_back  # previous frame\n    file, _, func, _, _ = inspect.getframeinfo(x)\n    if args is None:  # get args automatically\n        args, _, _, frm = inspect.getargvalues(x)\n        args = {k: v for k, v in frm.items() if k in args}",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "cuda_device_count",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def cuda_device_count() -> int:\n    \"\"\"\n    Get the number of NVIDIA GPUs available in the environment.\n    Returns:\n        (int): The number of NVIDIA GPUs available.\n    \"\"\"\n    try:\n        # Run the nvidia-smi command and capture its output\n        output = subprocess.check_output(\n            [\"nvidia-smi\", \"--query-gpu=count\", \"--format=csv,noheader,nounits\"], encoding=\"utf-8\"",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "cuda_is_available",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "def cuda_is_available() -> bool:\n    \"\"\"\n    Check if CUDA is available in the environment.\n    Returns:\n        (bool): True if one or more NVIDIA GPUs are available, False otherwise.\n    \"\"\"\n    return cuda_device_count() > 0\n# Define constants\nIS_PYTHON_3_12 = PYTHON_VERSION.startswith(\"3.12\")",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSION",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "PYTHON_VERSION = platform.python_version()\ndef parse_requirements(file_path=ROOT.parent / \"requirements.txt\", package=\"\"):\n    \"\"\"\n    Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.\n    Args:\n        file_path (Path): Path to the requirements.txt file.\n        package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.\n    Returns:\n        (List[Dict[str, str]]): List of parsed requirements as dictionaries with `name` and `specifier` keys.\n    Example:",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "IS_PYTHON_3_12",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.checks",
        "description": "Identification.yolov10.ultralytics.utils.checks",
        "peekOfCode": "IS_PYTHON_3_12 = PYTHON_VERSION.startswith(\"3.12\")",
        "detail": "Identification.yolov10.ultralytics.utils.checks",
        "documentation": {}
    },
    {
        "label": "find_free_network_port",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.dist",
        "description": "Identification.yolov10.ultralytics.utils.dist",
        "peekOfCode": "def find_free_network_port() -> int:\n    \"\"\"\n    Finds a free port on localhost.\n    It is useful in single-node training when we don't want to connect to a real main node but have to set the\n    `MASTER_PORT` environment variable.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]  # port\ndef generate_ddp_file(trainer):",
        "detail": "Identification.yolov10.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_file",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.dist",
        "description": "Identification.yolov10.ultralytics.utils.dist",
        "peekOfCode": "def generate_ddp_file(trainer):\n    \"\"\"Generates a DDP file and returns its file name.\"\"\"\n    module, name = f\"{trainer.__class__.__module__}.{trainer.__class__.__name__}\".rsplit(\".\", 1)\n    content = f\"\"\"\n# Ultralytics Multi-GPU training temp file (should be automatically deleted after use)\noverrides = {vars(trainer.args)}\nif __name__ == \"__main__\":\n    from {module} import {name}\n    from ultralytics.utils import DEFAULT_CFG_DICT\n    cfg = DEFAULT_CFG_DICT.copy()",
        "detail": "Identification.yolov10.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "generate_ddp_command",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.dist",
        "description": "Identification.yolov10.ultralytics.utils.dist",
        "peekOfCode": "def generate_ddp_command(world_size, trainer):\n    \"\"\"Generates and returns command for distributed training.\"\"\"\n    import __main__  # noqa local import to avoid https://github.com/Lightning-AI/lightning/issues/15218\n    if not trainer.resume:\n        shutil.rmtree(trainer.save_dir)  # remove the save_dir\n    file = generate_ddp_file(trainer)\n    dist_cmd = \"torch.distributed.run\" if TORCH_1_9 else \"torch.distributed.launch\"\n    port = find_free_network_port()\n    cmd = [sys.executable, \"-m\", dist_cmd, \"--nproc_per_node\", f\"{world_size}\", \"--master_port\", f\"{port}\", file]\n    return cmd, file",
        "detail": "Identification.yolov10.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "ddp_cleanup",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.dist",
        "description": "Identification.yolov10.ultralytics.utils.dist",
        "peekOfCode": "def ddp_cleanup(trainer, file):\n    \"\"\"Delete temp file if created.\"\"\"\n    if f\"{id(trainer)}.py\" in file:  # if temp_file suffix in file\n        os.remove(file)",
        "detail": "Identification.yolov10.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "overrides",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.dist",
        "description": "Identification.yolov10.ultralytics.utils.dist",
        "peekOfCode": "overrides = {vars(trainer.args)}\nif __name__ == \"__main__\":\n    from {module} import {name}\n    from ultralytics.utils import DEFAULT_CFG_DICT\n    cfg = DEFAULT_CFG_DICT.copy()\n    cfg.update(save_dir='')   # handle the extra key 'save_dir'\n    trainer = {name}(cfg=cfg, overrides=overrides)\n    results = trainer.train()\n\"\"\"\n    (USER_CONFIG_DIR / \"DDP\").mkdir(exist_ok=True)",
        "detail": "Identification.yolov10.ultralytics.utils.dist",
        "documentation": {}
    },
    {
        "label": "is_url",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def is_url(url, check=False):\n    \"\"\"\n    Validates if the given string is a URL and optionally checks if the URL exists online.\n    Args:\n        url (str): The string to be validated as a URL.\n        check (bool, optional): If True, performs an additional check to see if the URL exists online.\n            Defaults to True.\n    Returns:\n        (bool): Returns True for a valid URL. If 'check' is True, also returns True if the URL exists online.\n            Returns False otherwise.",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "delete_dsstore",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def delete_dsstore(path, files_to_delete=(\".DS_Store\", \"__MACOSX\")):\n    \"\"\"\n    Deletes all \".DS_store\" files under a specified directory.\n    Args:\n        path (str, optional): The directory path where the \".DS_store\" files should be deleted.\n        files_to_delete (tuple): The files to be deleted.\n    Example:\n        ```python\n        from ultralytics.utils.downloads import delete_dsstore\n        delete_dsstore('path/to/dir')",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "zip_directory",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def zip_directory(directory, compress=True, exclude=(\".DS_Store\", \"__MACOSX\"), progress=True):\n    \"\"\"\n    Zips the contents of a directory, excluding files containing strings in the exclude list. The resulting zip file is\n    named after the directory and placed alongside it.\n    Args:\n        directory (str | Path): The path to the directory to be zipped.\n        compress (bool): Whether to compress the files while zipping. Default is True.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').\n        progress (bool, optional): Whether to display a progress bar. Defaults to True.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "unzip_file",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def unzip_file(file, path=None, exclude=(\".DS_Store\", \"__MACOSX\"), exist_ok=False, progress=True):\n    \"\"\"\n    Unzips a *.zip file to the specified path, excluding files containing strings in the exclude list.\n    If the zipfile does not contain a single top-level directory, the function will create a new\n    directory with the same name as the zipfile (without the extension) to extract its contents.\n    If a path is not provided, the function will use the parent directory of the zipfile as the default path.\n    Args:\n        file (str): The path to the zipfile to be extracted.\n        path (str, optional): The path to extract the zipfile to. Defaults to None.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "check_disk_space",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def check_disk_space(url=\"https://ultralytics.com/assets/coco128.zip\", path=Path.cwd(), sf=1.5, hard=True):\n    \"\"\"\n    Check if there is sufficient disk space to download and store a file.\n    Args:\n        url (str, optional): The URL to the file. Defaults to 'https://ultralytics.com/assets/coco128.zip'.\n        path (str | Path, optional): The path or drive to check the available free space on.\n        sf (float, optional): Safety factor, the multiplier for the required free space. Defaults to 2.0.\n        hard (bool, optional): Whether to throw an error or not on insufficient disk space. Defaults to True.\n    Returns:\n        (bool): True if there is sufficient disk space, False otherwise.",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_google_drive_file_info",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def get_google_drive_file_info(link):\n    \"\"\"\n    Retrieves the direct download link and filename for a shareable Google Drive file link.\n    Args:\n        link (str): The shareable link of the Google Drive file.\n    Returns:\n        (str): Direct download URL for the Google Drive file.\n        (str): Original filename of the Google Drive file. If filename extraction fails, returns None.\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "safe_download",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def safe_download(\n    url,\n    file=None,\n    dir=None,\n    unzip=True,\n    delete=False,\n    curl=False,\n    retry=3,\n    min_bytes=1e0,\n    exist_ok=False,",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "get_github_assets",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def get_github_assets(repo=\"ultralytics/assets\", version=\"latest\", retry=False):\n    \"\"\"\n    Retrieve the specified version's tag and assets from a GitHub repository. If the version is not specified, the\n    function fetches the latest release assets.\n    Args:\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        version (str, optional): The release version to fetch assets from. Defaults to 'latest'.\n        retry (bool, optional): Flag to retry the request in case of a failure. Defaults to False.\n    Returns:\n        (tuple): A tuple containing the release tag and a list of asset names.",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "attempt_download_asset",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def attempt_download_asset(file, repo=\"ultralytics/assets\", release=\"v8.1.0\", **kwargs):\n    \"\"\"\n    Attempt to download a file from GitHub release assets if it is not found locally. The function checks for the file\n    locally first, then tries to download it from the specified GitHub repository release.\n    Args:\n        file (str | Path): The filename or file path to be downloaded.\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        release (str, optional): The specific release version to be downloaded. Defaults to 'v8.1.0'.\n        **kwargs (any): Additional keyword arguments for the download process.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "download",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "def download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3, exist_ok=False):\n    \"\"\"\n    Downloads files from specified URLs to a given directory. Supports concurrent downloads if multiple threads are\n    specified.\n    Args:\n        url (str | list): The URL or list of URLs of the files to be downloaded.\n        dir (Path, optional): The directory where the files will be saved. Defaults to the current working directory.\n        unzip (bool, optional): Flag to unzip the files after downloading. Defaults to True.\n        delete (bool, optional): Flag to delete the zip files after extraction. Defaults to False.\n        curl (bool, optional): Flag to use curl for downloading. Defaults to False.",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_REPO",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_REPO = \"ultralytics/assets\"\nGITHUB_ASSETS_NAMES = (\n    [f\"yolov8{k}{suffix}.pt\" for k in \"nsmlx\" for suffix in (\"\", \"-cls\", \"-seg\", \"-pose\", \"-obb\")]\n    + [f\"yolov5{k}{resolution}u.pt\" for k in \"nsmlx\" for resolution in (\"\", \"6\")]\n    + [f\"yolov3{k}u.pt\" for k in (\"\", \"-spp\", \"-tiny\")]\n    + [f\"yolov8{k}-world.pt\" for k in \"smlx\"]\n    + [f\"yolov8{k}-worldv2.pt\" for k in \"smlx\"]\n    + [f\"yolov9{k}.pt\" for k in \"ce\"]\n    + [f\"yolo_nas_{k}.pt\" for k in \"sml\"]\n    + [f\"sam_{k}.pt\" for k in \"bl\"]",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_NAMES",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_NAMES = (\n    [f\"yolov8{k}{suffix}.pt\" for k in \"nsmlx\" for suffix in (\"\", \"-cls\", \"-seg\", \"-pose\", \"-obb\")]\n    + [f\"yolov5{k}{resolution}u.pt\" for k in \"nsmlx\" for resolution in (\"\", \"6\")]\n    + [f\"yolov3{k}u.pt\" for k in (\"\", \"-spp\", \"-tiny\")]\n    + [f\"yolov8{k}-world.pt\" for k in \"smlx\"]\n    + [f\"yolov8{k}-worldv2.pt\" for k in \"smlx\"]\n    + [f\"yolov9{k}.pt\" for k in \"ce\"]\n    + [f\"yolo_nas_{k}.pt\" for k in \"sml\"]\n    + [f\"sam_{k}.pt\" for k in \"bl\"]\n    + [f\"FastSAM-{k}.pt\" for k in \"sx\"]",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "GITHUB_ASSETS_STEMS",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.downloads",
        "description": "Identification.yolov10.ultralytics.utils.downloads",
        "peekOfCode": "GITHUB_ASSETS_STEMS = [Path(k).stem for k in GITHUB_ASSETS_NAMES]\ndef is_url(url, check=False):\n    \"\"\"\n    Validates if the given string is a URL and optionally checks if the URL exists online.\n    Args:\n        url (str): The string to be validated as a URL.\n        check (bool, optional): If True, performs an additional check to see if the URL exists online.\n            Defaults to True.\n    Returns:\n        (bool): Returns True for a valid URL. If 'check' is True, also returns True if the URL exists online.",
        "detail": "Identification.yolov10.ultralytics.utils.downloads",
        "documentation": {}
    },
    {
        "label": "HUBModelError",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.errors",
        "description": "Identification.yolov10.ultralytics.utils.errors",
        "peekOfCode": "class HUBModelError(Exception):\n    \"\"\"\n    Custom exception class for handling errors related to model fetching in Ultralytics YOLO.\n    This exception is raised when a requested model is not found or cannot be retrieved.\n    The message is also processed to include emojis for better user experience.\n    Attributes:\n        message (str): The error message displayed when the exception is raised.\n    Note:\n        The message is automatically processed through the 'emojis' function from the 'ultralytics.utils' package.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.errors",
        "documentation": {}
    },
    {
        "label": "WorkingDirectory",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "class WorkingDirectory(contextlib.ContextDecorator):\n    \"\"\"Usage: @WorkingDirectory(dir) decorator or 'with WorkingDirectory(dir):' context manager.\"\"\"\n    def __init__(self, new_dir):\n        \"\"\"Sets the working directory to 'new_dir' upon instantiation.\"\"\"\n        self.dir = new_dir  # new dir\n        self.cwd = Path.cwd().resolve()  # current dir\n    def __enter__(self):\n        \"\"\"Changes the current directory to the specified directory.\"\"\"\n        os.chdir(self.dir)\n    def __exit__(self, exc_type, exc_val, exc_tb):  # noqa",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "spaces_in_path",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def spaces_in_path(path):\n    \"\"\"\n    Context manager to handle paths with spaces in their names. If a path contains spaces, it replaces them with\n    underscores, copies the file/directory to the new path, executes the context code block, then copies the\n    file/directory back to its original location.\n    Args:\n        path (str | Path): The original path.\n    Yields:\n        (Path): Temporary path with spaces replaced by underscores if spaces were present, otherwise the original path.\n    Example:",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "increment_path",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def increment_path(path, exist_ok=False, sep=\"\", mkdir=False):\n    \"\"\"\n    Increments a file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.\n    If the path exists and exist_ok is not set to True, the path will be incremented by appending a number and sep to\n    the end of the path. If the path is a file, the file extension will be preserved. If the path is a directory, the\n    number will be appended directly to the end of the path. If mkdir is set to True, the path will be created as a\n    directory if it does not already exist.\n    Args:\n        path (str, pathlib.Path): Path to increment.\n        exist_ok (bool, optional): If True, the path will not be incremented and returned as-is. Defaults to False.",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_age",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def file_age(path=__file__):\n    \"\"\"Return days since last file update.\"\"\"\n    dt = datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime)  # delta\n    return dt.days  # + dt.seconds / 86400  # fractional days\ndef file_date(path=__file__):\n    \"\"\"Return human-readable file modification date, i.e. '2021-3-26'.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\ndef file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_date",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def file_date(path=__file__):\n    \"\"\"Return human-readable file modification date, i.e. '2021-3-26'.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\ndef file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"\n    if isinstance(path, (str, Path)):\n        mb = 1 << 20  # bytes to MiB (1024 ** 2)\n        path = Path(path)\n        if path.is_file():",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "file_size",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"\n    if isinstance(path, (str, Path)):\n        mb = 1 << 20  # bytes to MiB (1024 ** 2)\n        path = Path(path)\n        if path.is_file():\n            return path.stat().st_size / mb\n        elif path.is_dir():\n            return sum(f.stat().st_size for f in path.glob(\"**/*\") if f.is_file()) / mb\n    return 0.0",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "get_latest_run",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def get_latest_run(search_dir=\".\"):\n    \"\"\"Return path to most recent 'last.pt' in /runs (i.e. to --resume from).\"\"\"\n    last_list = glob.glob(f\"{search_dir}/**/last*.pt\", recursive=True)\n    return max(last_list, key=os.path.getctime) if last_list else \"\"\ndef update_models(model_names=(\"yolov8n.pt\",), source_dir=Path(\".\"), update_names=False):\n    \"\"\"\n    Updates and re-saves specified YOLO models in an 'updated_models' subdirectory.\n    Args:\n        model_names (tuple, optional): Model filenames to update, defaults to (\"yolov8n.pt\").\n        source_dir (Path, optional): Directory containing models and target subdirectory, defaults to current directory.",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "update_models",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.files",
        "description": "Identification.yolov10.ultralytics.utils.files",
        "peekOfCode": "def update_models(model_names=(\"yolov8n.pt\",), source_dir=Path(\".\"), update_names=False):\n    \"\"\"\n    Updates and re-saves specified YOLO models in an 'updated_models' subdirectory.\n    Args:\n        model_names (tuple, optional): Model filenames to update, defaults to (\"yolov8n.pt\").\n        source_dir (Path, optional): Directory containing models and target subdirectory, defaults to current directory.\n        update_names (bool, optional): Update model names from a data YAML.\n    Example:\n        ```python\n        from ultralytics.utils.files import update_models",
        "detail": "Identification.yolov10.ultralytics.utils.files",
        "documentation": {}
    },
    {
        "label": "Bboxes",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "class Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').\n    Note:\n        This class does not handle normalization or denormalization of bounding boxes.",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "Instances",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "class Instances:\n    \"\"\"\n    Container for bounding boxes, segments, and keypoints of detected objects in an image.\n    Attributes:\n        _bboxes (Bboxes): Internal object for handling bounding box operations.\n        keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3]. Default is None.\n        normalized (bool): Flag indicating whether the bounding box coordinates are normalized.\n        segments (ndarray): Segments array with shape [N, 1000, 2] after resampling.\n    Args:\n        bboxes (ndarray): An array of bounding boxes with shape [N, 4].",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_2tuple",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "to_2tuple = _ntuple(2)\nto_4tuple = _ntuple(4)\n# `xyxy` means left top and right bottom\n# `xywh` means center x, center y and width, height(YOLO format)\n# `ltwh` means left top and width, height(COCO format)\n_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "to_4tuple",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "to_4tuple = _ntuple(4)\n# `xyxy` means left top and right bottom\n# `xywh` means center x, center y and width, height(YOLO format)\n# `ltwh` means left top and width, height(COCO format)\n_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "_formats",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "_formats = [\"xyxy\", \"xywh\", \"ltwh\"]\n__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.instance",
        "description": "Identification.yolov10.ultralytics.utils.instance",
        "peekOfCode": "__all__ = (\"Bboxes\",)  # tuple or list\nclass Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').\n    Note:",
        "detail": "Identification.yolov10.ultralytics.utils.instance",
        "documentation": {}
    },
    {
        "label": "VarifocalLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class VarifocalLoss(nn.Module):\n    \"\"\"\n    Varifocal loss by Zhang et al.\n    https://arxiv.org/abs/2008.13367.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the VarifocalLoss class.\"\"\"\n        super().__init__()\n    @staticmethod\n    def forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0):",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "FocalLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class FocalLoss(nn.Module):\n    \"\"\"Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5).\"\"\"\n    def __init__(self):\n        \"\"\"Initializer for FocalLoss class with no parameters.\"\"\"\n        super().__init__()\n    @staticmethod\n    def forward(pred, label, gamma=1.5, alpha=0.25):\n        \"\"\"Calculates and updates confusion matrix for object detection/classification tasks.\"\"\"\n        loss = F.binary_cross_entropy_with_logits(pred, label, reduction=\"none\")\n        # p_t = torch.exp(-loss)",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "BboxLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class BboxLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__()\n        self.reg_max = reg_max\n        self.use_dfl = use_dfl\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "RotatedBboxLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class RotatedBboxLoss(BboxLoss):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__(reg_max, use_dfl)\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n        iou = probiou(pred_bboxes[fg_mask], target_bboxes[fg_mask])\n        loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "KeypointLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class KeypointLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, sigmas) -> None:\n        \"\"\"Initialize the KeypointLoss class.\"\"\"\n        super().__init__()\n        self.sigmas = sigmas\n    def forward(self, pred_kpts, gt_kpts, kpt_mask, area):\n        \"\"\"Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints.\"\"\"\n        d = (pred_kpts[..., 0] - gt_kpts[..., 0]).pow(2) + (pred_kpts[..., 1] - gt_kpts[..., 1]).pow(2)\n        kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8DetectionLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v8DetectionLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model, tal_topk=10):  # model must be de-paralleled\n        \"\"\"Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function.\"\"\"\n        device = next(model.parameters()).device  # get model device\n        h = model.args  # hyperparameters\n        m = model.model[-1]  # Detect() module\n        self.bce = nn.BCEWithLogitsLoss(reduction=\"none\")\n        self.hyp = h\n        self.stride = m.stride  # model strides",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8SegmentationLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v8SegmentationLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument.\"\"\"\n        super().__init__(model)\n        self.overlap = model.args.overlap_mask\n    def __call__(self, preds, batch):\n        \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n        loss = torch.zeros(4, device=self.device)  # box, cls, dfl\n        feats, pred_masks, proto = preds if len(preds) == 3 else preds[1]",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8PoseLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v8PoseLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance.\"\"\"\n        super().__init__(model)\n        self.kpt_shape = model.model[-1].kpt_shape\n        self.bce_pose = nn.BCEWithLogitsLoss()\n        is_pose = self.kpt_shape == [17, 3]\n        nkpt = self.kpt_shape[0]  # number of keypoints\n        sigmas = torch.from_numpy(OKS_SIGMA).to(self.device) if is_pose else torch.ones(nkpt, device=self.device) / nkpt",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8ClassificationLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v8ClassificationLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n    def __call__(self, preds, batch):\n        \"\"\"Compute the classification loss between predictions and true labels.\"\"\"\n        loss = torch.nn.functional.cross_entropy(preds, batch[\"cls\"], reduction=\"mean\")\n        loss_items = loss.detach()\n        return loss, loss_items\nclass v8OBBLoss(v8DetectionLoss):\n    def __init__(self, model):\n        \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v8OBBLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v8OBBLoss(v8DetectionLoss):\n    def __init__(self, model):\n        \"\"\"\n        Initializes v8OBBLoss with model, assigner, and rotated bbox loss.\n        Note model must be de-paralleled.\n        \"\"\"\n        super().__init__(model)\n        self.assigner = RotatedTaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)\n        self.bbox_loss = RotatedBboxLoss(self.reg_max - 1, use_dfl=self.use_dfl).to(self.device)\n    def preprocess(self, targets, batch_size, scale_tensor):",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "v10DetectLoss",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.loss",
        "description": "Identification.yolov10.ultralytics.utils.loss",
        "peekOfCode": "class v10DetectLoss:\n    def __init__(self, model):\n        self.one2many = v8DetectionLoss(model, tal_topk=10)\n        self.one2one = v8DetectionLoss(model, tal_topk=1)\n    def __call__(self, preds, batch):\n        one2many = preds[\"one2many\"]\n        loss_one2many = self.one2many(one2many, batch)\n        one2one = preds[\"one2one\"]\n        loss_one2one = self.one2one(one2one, batch)\n        return loss_one2many[0] + loss_one2one[0], torch.cat((loss_one2many[1], loss_one2one[1]))",
        "detail": "Identification.yolov10.ultralytics.utils.loss",
        "documentation": {}
    },
    {
        "label": "ConfusionMatrix",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class ConfusionMatrix:\n    \"\"\"\n    A class for calculating and updating a confusion matrix for object detection and classification tasks.\n    Attributes:\n        task (str): The type of task, either 'detect' or 'classify'.\n        matrix (np.ndarray): The confusion matrix, with dimensions depending on the task.\n        nc (int): The number of classes.\n        conf (float): The confidence threshold for detections.\n        iou_thres (float): The Intersection over Union threshold.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "Metric",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class Metric(SimpleClass):\n    \"\"\"\n    Class for computing evaluation metrics for YOLOv8 model.\n    Attributes:\n        p (list): Precision for each class. Shape: (nc,).\n        r (list): Recall for each class. Shape: (nc,).\n        f1 (list): F1 score for each class. Shape: (nc,).\n        all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).\n        ap_class_index (list): Index of class for each AP score. Shape: (nc,).\n        nc (int): Number of classes.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "DetMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class DetMetrics(SimpleClass):\n    \"\"\"\n    This class is a utility class for computing detection metrics such as precision, recall, and mean average precision\n    (mAP) of an object detection model.\n    Args:\n        save_dir (Path): A path to the directory where the output plots will be saved. Defaults to current directory.\n        plot (bool): A flag that indicates whether to plot precision-recall curves for each class. Defaults to False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (tuple of str): A tuple of strings that represents the names of the classes. Defaults to an empty tuple.\n    Attributes:",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "SegmentMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class SegmentMetrics(SimpleClass):\n    \"\"\"\n    Calculates and aggregates detection and segmentation metrics over a given set of classes.\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "PoseMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class PoseMetrics(SegmentMetrics):\n    \"\"\"\n    Calculates and aggregates detection and pose metrics over a given set of classes.\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ClassifyMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class ClassifyMetrics(SimpleClass):\n    \"\"\"\n    Class for computing classification metrics including top-1 and top-5 accuracy.\n    Attributes:\n        top1 (float): The top-1 accuracy.\n        top5 (float): The top-5 accuracy.\n        speed (Dict[str, float]): A dictionary containing the time taken for each step in the pipeline.\n    Properties:\n        fitness (float): The fitness of the model, which is equal to top-5 accuracy.\n        results_dict (Dict[str, Union[float, str]]): A dictionary containing the classification metrics and fitness.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OBBMetrics",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "class OBBMetrics(SimpleClass):\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -> None:\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    def process(self, tp, conf, pred_cls, target_cls):\n        \"\"\"Process predicted results for object detection and update metrics.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_ioa",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def bbox_ioa(box1, box2, iou=False, eps=1e-7):\n    \"\"\"\n    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.\n    Args:\n        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.\n        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.\n        iou (bool): Calculate the standard IoU if True else return inter_area/box2_area.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (np.ndarray): A numpy array of shape (n, m) representing the intersection over box2 area.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "box_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def box_iou(box1, box2, eps=1e-7):\n    \"\"\"\n    Calculate intersection-over-union (IoU) of boxes. Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n    Based on https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py\n    Args:\n        box1 (torch.Tensor): A tensor of shape (N, 4) representing N bounding boxes.\n        box2 (torch.Tensor): A tensor of shape (M, 4) representing M bounding boxes.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): An NxM tensor containing the pairwise IoU values for every element in box1 and box2.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "bbox_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate Intersection over Union (IoU) of box1(1, 4) to box2(n, 4).\n    Args:\n        box1 (torch.Tensor): A tensor representing a single bounding box with shape (1, 4).\n        box2 (torch.Tensor): A tensor representing n bounding boxes with shape (n, 4).\n        xywh (bool, optional): If True, input boxes are in (x, y, w, h) format. If False, input boxes are in\n                               (x1, y1, x2, y2) format. Defaults to True.\n        GIoU (bool, optional): If True, calculate Generalized IoU. Defaults to False.\n        DIoU (bool, optional): If True, calculate Distance IoU. Defaults to False.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "mask_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def mask_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    Calculate masks IoU.\n    Args:\n        mask1 (torch.Tensor): A tensor of shape (N, n) where N is the number of ground truth objects and n is the\n                        product of image width and height.\n        mask2 (torch.Tensor): A tensor of shape (M, n) where M is the number of predicted objects and n is the\n                        product of image width and height.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "kpt_iou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def kpt_iou(kpt1, kpt2, area, sigma, eps=1e-7):\n    \"\"\"\n    Calculate Object Keypoint Similarity (OKS).\n    Args:\n        kpt1 (torch.Tensor): A tensor of shape (N, 17, 3) representing ground truth keypoints.\n        kpt2 (torch.Tensor): A tensor of shape (M, 17, 3) representing predicted keypoints.\n        area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.\n        sigma (list): A list containing 17 values representing keypoint scales.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "probiou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def probiou(obb1, obb2, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n    Args:\n        obb1 (torch.Tensor): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor): A tensor of shape (N, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): A tensor of shape (N, ) representing obb similarities.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "batch_probiou",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def batch_probiou(obb1, obb2, eps=1e-7):\n    \"\"\"\n    Calculate the prob IoU between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n    Args:\n        obb1 (torch.Tensor | np.ndarray): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor | np.ndarray): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n    Returns:\n        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "smooth_BCE",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def smooth_BCE(eps=0.1):\n    \"\"\"\n    Computes smoothed positive and negative Binary Cross-Entropy targets.\n    This function calculates positive and negative label smoothing BCE targets based on a given epsilon value.\n    For implementation details, refer to https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441.\n    Args:\n        eps (float, optional): The epsilon value for label smoothing. Defaults to 0.1.\n    Returns:\n        (tuple): A tuple containing the positive and negative label smoothing BCE targets.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "smooth",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def smooth(y, f=0.05):\n    \"\"\"Box filter of fraction f.\"\"\"\n    nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)\n    p = np.ones(nf // 2)  # ones padding\n    yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded\n    return np.convolve(yp, np.ones(nf) / nf, mode=\"valid\")  # y-smoothed\n@plt_settings()\ndef plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=(), on_plot=None):\n    \"\"\"Plots a precision-recall curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "plot_pr_curve",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=(), on_plot=None):\n    \"\"\"Plots a precision-recall curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    py = np.stack(py, axis=1)\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py.T):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]} {ap[i, 0]:.3f}\")  # plot(recall, precision)\n    else:\n        ax.plot(px, py, linewidth=1, color=\"grey\")  # plot(recall, precision)\n    ax.plot(px, py.mean(1), linewidth=3, color=\"blue\", label=\"all classes %.3f mAP@0.5\" % ap[:, 0].mean())",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "plot_mc_curve",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def plot_mc_curve(px, py, save_dir=Path(\"mc_curve.png\"), names=(), xlabel=\"Confidence\", ylabel=\"Metric\", on_plot=None):\n    \"\"\"Plots a metric-confidence curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]}\")  # plot(confidence, metric)\n    else:\n        ax.plot(px, py.T, linewidth=1, color=\"grey\")  # plot(confidence, metric)\n    y = smooth(py.mean(0), 0.05)\n    ax.plot(px, y, linewidth=3, color=\"blue\", label=f\"all classes {y.max():.2f} at {px[y.argmax()]:.3f}\")",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "compute_ap",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def compute_ap(recall, precision):\n    \"\"\"\n    Compute the average precision (AP) given the recall and precision curves.\n    Args:\n        recall (list): The recall curve.\n        precision (list): The precision curve.\n    Returns:\n        (float): Average precision.\n        (np.ndarray): Precision envelope curve.\n        (np.ndarray): Modified recall curve with sentinel values added at the beginning and end.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "ap_per_class",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "def ap_per_class(\n    tp, conf, pred_cls, target_cls, plot=False, on_plot=None, save_dir=Path(), names=(), eps=1e-16, prefix=\"\"\n):\n    \"\"\"\n    Computes the average precision per class for object detection evaluation.\n    Args:\n        tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).\n        conf (np.ndarray): Array of confidence scores of the detections.\n        pred_cls (np.ndarray): Array of predicted classes of the detections.\n        target_cls (np.ndarray): Array of true classes of the detections.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "OKS_SIGMA",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.metrics",
        "description": "Identification.yolov10.ultralytics.utils.metrics",
        "peekOfCode": "OKS_SIGMA = (\n    np.array([0.26, 0.25, 0.25, 0.35, 0.35, 0.79, 0.79, 0.72, 0.72, 0.62, 0.62, 1.07, 1.07, 0.87, 0.87, 0.89, 0.89])\n    / 10.0\n)\ndef bbox_ioa(box1, box2, iou=False, eps=1e-7):\n    \"\"\"\n    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.\n    Args:\n        box1 (np.ndarray): A numpy array of shape (n, 4) representing n bounding boxes.\n        box2 (np.ndarray): A numpy array of shape (m, 4) representing m bounding boxes.",
        "detail": "Identification.yolov10.ultralytics.utils.metrics",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "class Profile(contextlib.ContextDecorator):\n    \"\"\"\n    YOLOv8 Profile class. Use as a decorator with @Profile() or as a context manager with 'with Profile():'.\n    Example:\n        ```python\n        from ultralytics.utils.ops import Profile\n        with Profile(device=device) as dt:\n            pass  # slow operation here\n        print(dt)  # prints \"Elapsed time is 9.5367431640625e-07 s\"\n        ```",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segment2box",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def segment2box(segment, width=640, height=640):\n    \"\"\"\n    Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).\n    Args:\n        segment (torch.Tensor): the segment label\n        width (int): the width of the image. Defaults to 640\n        height (int): The height of the image. Defaults to 640\n    Returns:\n        (np.ndarray): the minimum and maximum x and y values of the segment.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True, xywh=False):\n    \"\"\"\n    Rescales bounding boxes (in the format of xyxy by default) from the shape of the image they were originally\n    specified in (img1_shape) to the shape of a different image (img0_shape).\n    Args:\n        img1_shape (tuple): The shape of the image that the bounding boxes are for, in the format of (height, width).\n        boxes (torch.Tensor): the bounding boxes of the objects in the image, in the format of (x1, y1, x2, y2)\n        img0_shape (tuple): the shape of the target image, in the format of (height, width).\n        ratio_pad (tuple): a tuple of (ratio, pad) for scaling the boxes. If not provided, the ratio and pad will be\n            calculated based on the size difference between the two images.",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def make_divisible(x, divisor):\n    \"\"\"\n    Returns the nearest number that is divisible by the given divisor.\n    Args:\n        x (int): The number to make divisible.\n        divisor (int | torch.Tensor): The divisor.\n    Returns:\n        (int): The nearest number divisible by the divisor.\n    \"\"\"\n    if isinstance(divisor, torch.Tensor):",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "nms_rotated",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def nms_rotated(boxes, scores, threshold=0.45):\n    \"\"\"\n    NMS for obbs, powered by probiou and fast-nms.\n    Args:\n        boxes (torch.Tensor): (N, 5), xywhr.\n        scores (torch.Tensor): (N, ).\n        threshold (float): IoU threshold.\n    Returns:\n    \"\"\"\n    if len(boxes) == 0:",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "non_max_suppression",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def non_max_suppression(\n    prediction,\n    conf_thres=0.25,\n    iou_thres=0.45,\n    classes=None,\n    agnostic=False,\n    multi_label=False,\n    labels=(),\n    max_det=300,\n    nc=0,  # number of classes (optional)",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clip_boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def clip_boxes(boxes, shape):\n    \"\"\"\n    Takes a list of bounding boxes and a shape (height, width) and clips the bounding boxes to the shape.\n    Args:\n        boxes (torch.Tensor): the bounding boxes to clip\n        shape (tuple): the shape of the image\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped boxes\n    \"\"\"\n    if isinstance(boxes, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clip_coords",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def clip_coords(coords, shape):\n    \"\"\"\n    Clip line coordinates to the image boundaries.\n    Args:\n        coords (torch.Tensor | numpy.ndarray): A list of line coordinates.\n        shape (tuple): A tuple of integers representing the size of the image in the format (height, width).\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped coordinates\n    \"\"\"\n    if isinstance(coords, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_image",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def scale_image(masks, im0_shape, ratio_pad=None):\n    \"\"\"\n    Takes a mask, and resizes it to the original image size.\n    Args:\n        masks (np.ndarray): resized and padded masks/images, [h, w, num]/[h, w, 3].\n        im0_shape (tuple): the original image shape\n        ratio_pad (tuple): the ratio of the padding to the original image.\n    Returns:\n        masks (torch.Tensor): The masks that are being returned.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywh",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2xywh(x):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xywh2xyxy(x):\n    \"\"\"\n    Convert bounding box coordinates from (x, y, width, height) format to (x1, y1, x2, y2) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x, y, width, height) format.\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x1, y1, x2, y2) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywhn2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):\n    \"\"\"\n    Convert normalized bounding box coordinates to pixel coordinates.\n    Args:\n        x (np.ndarray | torch.Tensor): The bounding box coordinates.\n        w (int): Width of the image. Defaults to 640\n        h (int): Height of the image. Defaults to 640\n        padw (int): Padding width. Defaults to 0\n        padh (int): Padding height. Defaults to 0\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2xywhn",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height, normalized) format. x, y,\n    width and height are normalized to image dimensions.\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n        w (int): The width of the image. Defaults to 640\n        h (int): The height of the image. Defaults to 640\n        clip (bool): If True, the boxes will be clipped to the image boundaries. Defaults to False\n        eps (float): The minimum value of the box's width and height. Defaults to 0.0",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywh2ltwh",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xywh2ltwh(x):\n    \"\"\"\n    Convert the bounding box format from [x, y, w, h] to [x1, y1, w, h], where x1, y1 are the top-left coordinates.\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding box coordinates in the xywh format\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] - x[..., 2] / 2  # top left x",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxy2ltwh",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xyxy2ltwh(x):\n    \"\"\"\n    Convert nx4 bounding boxes from [x1, y1, x2, y2] to [x1, y1, w, h], where xy1=top-left, xy2=bottom-right.\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding boxes coordinates in the xyxy format\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] - x[..., 0]  # width",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "ltwh2xywh",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def ltwh2xywh(x):\n    \"\"\"\n    Convert nx4 boxes from [x1, y1, w, h] to [x, y, w, h] where xy1=top-left, xy=center.\n    Args:\n        x (torch.Tensor): the input tensor\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xywh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] + x[..., 2] / 2  # center x",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xyxyxyxy2xywhr",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xyxyxyxy2xywhr(corners):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation]. Rotation values are\n    expected in degrees from 0 to 90.\n    Args:\n        corners (numpy.ndarray | torch.Tensor): Input corners of shape (n, 8).\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted data in [cx, cy, w, h, rotation] format of shape (n, 5).\n    \"\"\"\n    is_torch = isinstance(corners, torch.Tensor)",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "xywhr2xyxyxyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def xywhr2xyxyxyxy(rboxes):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4]. Rotation values should\n    be in degrees from 0 to 90.\n    Args:\n        rboxes (numpy.ndarray | torch.Tensor): Boxes in [cx, cy, w, h, rotation] format of shape (n, 5) or (b, n, 5).\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted corner points of shape (n, 4, 2) or (b, n, 4, 2).\n    \"\"\"\n    is_numpy = isinstance(rboxes, np.ndarray)",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "ltwh2xyxy",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def ltwh2xyxy(x):\n    \"\"\"\n    It converts the bounding box from [x1, y1, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.\n    Args:\n        x (np.ndarray | torch.Tensor): the input image\n    Returns:\n        y (np.ndarray | torch.Tensor): the xyxy coordinates of the bounding boxes.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] + x[..., 0]  # width",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "segments2boxes",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def segments2boxes(segments):\n    \"\"\"\n    It converts segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)\n    Args:\n        segments (list): list of segments, each segment is a list of points, each point is a list of x, y coordinates\n    Returns:\n        (np.ndarray): the xywh coordinates of the bounding boxes.\n    \"\"\"\n    boxes = []\n    for s in segments:",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "resample_segments",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def resample_segments(segments, n=1000):\n    \"\"\"\n    Inputs a list of segments (n,2) and returns a list of segments (n,2) up-sampled to n points each.\n    Args:\n        segments (list): a list of (n,2) arrays, where n is the number of points in the segment.\n        n (int): number of points to resample the segment to. Defaults to 1000\n    Returns:\n        segments (list): the resampled segments.\n    \"\"\"\n    for i, s in enumerate(segments):",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "crop_mask",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def crop_mask(masks, boxes):\n    \"\"\"\n    It takes a mask and a bounding box, and returns a mask that is cropped to the bounding box.\n    Args:\n        masks (torch.Tensor): [n, h, w] tensor of masks\n        boxes (torch.Tensor): [n, 4] tensor of bbox coordinates in relative point form\n    Returns:\n        (torch.Tensor): The masks are being cropped to the bounding box.\n    \"\"\"\n    _, h, w = masks.shape",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask_upsample",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def process_mask_upsample(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Takes the output of the mask head, and applies the mask to the bounding boxes. This produces masks of higher quality\n    but is slower.\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def process_mask(protos, masks_in, bboxes, shape, upsample=False):\n    \"\"\"\n    Apply masks to bounding boxes using the output of the mask head.\n    Args:\n        protos (torch.Tensor): A tensor of shape [mask_dim, mask_h, mask_w].\n        masks_in (torch.Tensor): A tensor of shape [n, mask_dim], where n is the number of masks after NMS.\n        bboxes (torch.Tensor): A tensor of shape [n, 4], where n is the number of masks after NMS.\n        shape (tuple): A tuple of integers representing the size of the input image in the format (h, w).\n        upsample (bool): A flag to indicate whether to upsample the mask to the original image size. Default is False.\n    Returns:",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "process_mask_native",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def process_mask_native(protos, masks_in, bboxes, shape):\n    \"\"\"\n    It takes the output of the mask head, and crops it after upsampling to the bounding boxes.\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n    Returns:\n        masks (torch.Tensor): The returned masks with dimensions [h, w, n]",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_masks",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def scale_masks(masks, shape, padding=True):\n    \"\"\"\n    Rescale segment masks to shape.\n    Args:\n        masks (torch.Tensor): (N, C, H, W).\n        shape (tuple): Height and width.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular\n            rescaling.\n    \"\"\"\n    mh, mw = masks.shape[2:]",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "scale_coords",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None, normalize=False, padding=True):\n    \"\"\"\n    Rescale segment coordinates (xy) from img1_shape to img0_shape.\n    Args:\n        img1_shape (tuple): The shape of the image that the coords are from.\n        coords (torch.Tensor): the coords to be scaled of shape n,2.\n        img0_shape (tuple): the shape of the image that the segmentation is being applied to.\n        ratio_pad (tuple): the ratio of the image size to the padded image size.\n        normalize (bool): If True, the coordinates will be normalized to the range [0, 1]. Defaults to False.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "regularize_rboxes",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def regularize_rboxes(rboxes):\n    \"\"\"\n    Regularize rotated boxes in range [0, pi/2].\n    Args:\n        rboxes (torch.Tensor): (N, 5), xywhr.\n    Returns:\n        (torch.Tensor): The regularized boxes.\n    \"\"\"\n    x, y, w, h, t = rboxes.unbind(dim=-1)\n    # Swap edge and angle if h >= w",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "masks2segments",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def masks2segments(masks, strategy=\"largest\"):\n    \"\"\"\n    It takes a list of masks(n,h,w) and returns a list of segments(n,xy)\n    Args:\n        masks (torch.Tensor): the output of the model, which is a tensor of shape (batch_size, 160, 160)\n        strategy (str): 'concat' or 'largest'. Defaults to largest\n    Returns:\n        segments (List): list of segment masks\n    \"\"\"\n    segments = []",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "convert_torch2numpy_batch",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def convert_torch2numpy_batch(batch: torch.Tensor) -> np.ndarray:\n    \"\"\"\n    Convert a batch of FP32 torch tensors (0.0-1.0) to a NumPy uint8 array (0-255), changing from BCHW to BHWC layout.\n    Args:\n        batch (torch.Tensor): Input tensor batch of shape (Batch, Channels, Height, Width) and dtype torch.float32.\n    Returns:\n        (np.ndarray): Output NumPy array batch of shape (Batch, Height, Width, Channels) and dtype uint8.\n    \"\"\"\n    return (batch.permute(0, 2, 3, 1).contiguous() * 255).clamp(0, 255).to(torch.uint8).cpu().numpy()\ndef clean_str(s):",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "clean_str",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def clean_str(s):\n    \"\"\"\n    Cleans a string by replacing special characters with underscore _\n    Args:\n        s (str): a string needing special characters replaced\n    Returns:\n        (str): a string with special characters replaced by an underscore _\n    \"\"\"\n    return re.sub(pattern=\"[|@#!$%&()=?^*;:,><+]\", repl=\"_\", string=s)\ndef v10postprocess(preds, max_det, nc=80):",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "v10postprocess",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.ops",
        "description": "Identification.yolov10.ultralytics.utils.ops",
        "peekOfCode": "def v10postprocess(preds, max_det, nc=80):\n    assert(4 + nc == preds.shape[-1])\n    boxes, scores = preds.split([4, nc], dim=-1)\n    max_scores = scores.amax(dim=-1)\n    max_scores, index = torch.topk(max_scores, max_det, dim=-1)\n    index = index.unsqueeze(-1)\n    boxes = torch.gather(boxes, dim=1, index=index.repeat(1, 1, boxes.shape[-1]))\n    scores = torch.gather(scores, dim=1, index=index.repeat(1, 1, scores.shape[-1]))\n    scores, index = torch.topk(scores.flatten(1), max_det, dim=-1)\n    labels = index % nc",
        "detail": "Identification.yolov10.ultralytics.utils.ops",
        "documentation": {}
    },
    {
        "label": "imread",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "def imread(filename: str, flags: int = cv2.IMREAD_COLOR):\n    \"\"\"\n    Read an image from a file.\n    Args:\n        filename (str): Path to the file to read.\n        flags (int, optional): Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.\n    Returns:\n        (np.ndarray): The read image.\n    \"\"\"\n    return cv2.imdecode(np.fromfile(filename, np.uint8), flags)",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "def imwrite(filename: str, img: np.ndarray, params=None):\n    \"\"\"\n    Write an image to a file.\n    Args:\n        filename (str): Path to the file to write.\n        img (np.ndarray): Image to write.\n        params (list of ints, optional): Additional parameters. See OpenCV documentation.\n    Returns:\n        (bool): True if the file was written, False otherwise.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "imshow",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "def imshow(winname: str, mat: np.ndarray):\n    \"\"\"\n    Displays an image in the specified window.\n    Args:\n        winname (str): Name of the window.\n        mat (np.ndarray): Image to be shown.\n    \"\"\"\n    _imshow(winname.encode(\"unicode_escape\").decode(), mat)\n# PyTorch functions ----------------------------------------------------------------------------------------------------\n_torch_save = torch.save  # copy to avoid recursion errors",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "torch_save",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "def torch_save(*args, use_dill=True, **kwargs):\n    \"\"\"\n    Optionally use dill to serialize lambda functions where pickle does not, adding robustness with 3 retries and\n    exponential standoff in case of save failure.\n    Args:\n        *args (tuple): Positional arguments to pass to torch.save.\n        use_dill (bool): Whether to try using dill for serialization if available. Defaults to True.\n        **kwargs (any): Keyword arguments to pass to torch.save.\n    \"\"\"\n    try:",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "_imshow",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "_imshow = cv2.imshow  # copy to avoid recursion errors\ndef imread(filename: str, flags: int = cv2.IMREAD_COLOR):\n    \"\"\"\n    Read an image from a file.\n    Args:\n        filename (str): Path to the file to read.\n        flags (int, optional): Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.\n    Returns:\n        (np.ndarray): The read image.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "_torch_save",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.patches",
        "description": "Identification.yolov10.ultralytics.utils.patches",
        "peekOfCode": "_torch_save = torch.save  # copy to avoid recursion errors\ndef torch_save(*args, use_dill=True, **kwargs):\n    \"\"\"\n    Optionally use dill to serialize lambda functions where pickle does not, adding robustness with 3 retries and\n    exponential standoff in case of save failure.\n    Args:\n        *args (tuple): Positional arguments to pass to torch.save.\n        use_dill (bool): Whether to try using dill for serialization if available. Defaults to True.\n        **kwargs (any): Keyword arguments to pass to torch.save.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.patches",
        "documentation": {}
    },
    {
        "label": "Colors",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "class Colors:\n    \"\"\"\n    Ultralytics default color palette https://ultralytics.com/.\n    This class provides methods to work with the Ultralytics color palette, including converting hex color codes to\n    RGB values.\n    Attributes:\n        palette (list of tuple): List of RGB color values.\n        n (int): The number of colors in the palette.\n        pose_palette (np.ndarray): A specific color palette array with dtype np.uint8.\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "Annotator",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "class Annotator:\n    \"\"\"\n    Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.\n    Attributes:\n        im (Image.Image or numpy array): The image to annotate.\n        pil (bool): Whether to use PIL or cv2 for drawing annotations.\n        font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.\n        lw (float): Line width for drawing.\n        skeleton (List[List[int]]): Skeleton structure for keypoints.\n        limb_color (List[int]): Color palette for limbs.",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_labels",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def plot_labels(boxes, cls, names=(), save_dir=Path(\"\"), on_plot=None):\n    \"\"\"Plot training labels including class histograms and box statistics.\"\"\"\n    import pandas as pd\n    import seaborn as sn\n    # Filter matplotlib>=3.7.2 warning and Seaborn use_inf and is_categorical FutureWarnings\n    warnings.filterwarnings(\"ignore\", category=UserWarning, message=\"The figure layout has changed to tight\")\n    warnings.filterwarnings(\"ignore\", category=FutureWarning)\n    # Plot dataset labels\n    LOGGER.info(f\"Plotting labels to {save_dir / 'labels.jpg'}... \")\n    nc = int(cls.max() + 1)  # number of classes",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "save_one_box",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def save_one_box(xyxy, im, file=Path(\"im.jpg\"), gain=1.02, pad=10, square=False, BGR=False, save=True):\n    \"\"\"\n    Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop.\n    This function takes a bounding box and an image, and then saves a cropped portion of the image according\n    to the bounding box. Optionally, the crop can be squared, and the function allows for gain and padding\n    adjustments to the bounding box.\n    Args:\n        xyxy (torch.Tensor or list): A tensor or list representing the bounding box in xyxy format.\n        im (numpy.ndarray): The input image.\n        file (Path, optional): The path where the cropped image will be saved. Defaults to 'im.jpg'.",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_images",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def plot_images(\n    images,\n    batch_idx,\n    cls,\n    bboxes=np.zeros(0, dtype=np.float32),\n    confs=None,\n    masks=np.zeros(0, dtype=np.uint8),\n    kpts=np.zeros((0, 51), dtype=np.float32),\n    paths=None,\n    fname=\"images.jpg\",",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def plot_results(file=\"path/to/results.csv\", dir=\"\", segment=False, pose=False, classify=False, on_plot=None):\n    \"\"\"\n    Plot training results from a results CSV file. The function supports various types of data including segmentation,\n    pose estimation, and classification. Plots are saved as 'results.png' in the directory where the CSV is located.\n    Args:\n        file (str, optional): Path to the CSV file containing the training results. Defaults to 'path/to/results.csv'.\n        dir (str, optional): Directory where the CSV file is located if 'file' is not provided. Defaults to ''.\n        segment (bool, optional): Flag to indicate if the data is for segmentation. Defaults to False.\n        pose (bool, optional): Flag to indicate if the data is for pose estimation. Defaults to False.\n        classify (bool, optional): Flag to indicate if the data is for classification. Defaults to False.",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plt_color_scatter",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def plt_color_scatter(v, f, bins=20, cmap=\"viridis\", alpha=0.8, edgecolors=\"none\"):\n    \"\"\"\n    Plots a scatter plot with points colored based on a 2D histogram.\n    Args:\n        v (array-like): Values for the x-axis.\n        f (array-like): Values for the y-axis.\n        bins (int, optional): Number of bins for the histogram. Defaults to 20.\n        cmap (str, optional): Colormap for the scatter plot. Defaults to 'viridis'.\n        alpha (float, optional): Alpha for the scatter plot. Defaults to 0.8.\n        edgecolors (str, optional): Edge colors for the scatter plot. Defaults to 'none'.",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "plot_tune_results",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def plot_tune_results(csv_file=\"tune_results.csv\"):\n    \"\"\"\n    Plot the evolution results stored in an 'tune_results.csv' file. The function generates a scatter plot for each key\n    in the CSV, color-coded based on fitness scores. The best-performing configurations are highlighted on the plots.\n    Args:\n        csv_file (str, optional): Path to the CSV file containing the tuning results. Defaults to 'tune_results.csv'.\n    Examples:\n        >>> plot_tune_results('path/to/tune_results.csv')\n    \"\"\"\n    import pandas as pd",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_target",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def output_to_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, ops.xyxy2xywh(box), conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\ndef output_to_rotated_target(output, max_det=300):",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "output_to_rotated_target",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def output_to_rotated_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls, angle = o[:max_det].cpu().split((4, 1, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, box, angle, conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\ndef feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "feature_visualization",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "def feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):\n    \"\"\"\n    Visualize feature maps of a given model module during inference.\n    Args:\n        x (torch.Tensor): Features to be visualized.\n        module_type (str): Module type.\n        stage (int): Module stage within the model.\n        n (int, optional): Maximum number of feature maps to plot. Defaults to 32.\n        save_dir (Path, optional): Directory to save results. Defaults to Path('runs/detect/exp').\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.plotting",
        "description": "Identification.yolov10.ultralytics.utils.plotting",
        "peekOfCode": "colors = Colors()  # create instance for 'from utils.plots import colors'\nclass Annotator:\n    \"\"\"\n    Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.\n    Attributes:\n        im (Image.Image or numpy array): The image to annotate.\n        pil (bool): Whether to use PIL or cv2 for drawing annotations.\n        font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.\n        lw (float): Line width for drawing.\n        skeleton (List[List[int]]): Skeleton structure for keypoints.",
        "detail": "Identification.yolov10.ultralytics.utils.plotting",
        "documentation": {}
    },
    {
        "label": "TaskAlignedAssigner",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "class TaskAlignedAssigner(nn.Module):\n    \"\"\"\n    A task-aligned assigner for object detection.\n    This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both\n    classification and localization information.\n    Attributes:\n        topk (int): The number of top candidates to consider.\n        num_classes (int): The number of object classes.\n        alpha (float): The alpha parameter for the classification component of the task-aligned metric.\n        beta (float): The beta parameter for the localization component of the task-aligned metric.",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "RotatedTaskAlignedAssigner",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "class RotatedTaskAlignedAssigner(TaskAlignedAssigner):\n    def iou_calculation(self, gt_bboxes, pd_bboxes):\n        \"\"\"IoU calculation for rotated bounding boxes.\"\"\"\n        return probiou(gt_bboxes, pd_bboxes).squeeze(-1).clamp_(0)\n    @staticmethod\n    def select_candidates_in_gts(xy_centers, gt_bboxes):\n        \"\"\"\n        Select the positive anchor center in gt for rotated bounding boxes.\n        Args:\n            xy_centers (Tensor): shape(h*w, 2)",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "make_anchors",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "def make_anchors(feats, strides, grid_cell_offset=0.5):\n    \"\"\"Generate anchors from features.\"\"\"\n    anchor_points, stride_tensor = [], []\n    assert feats is not None\n    dtype, device = feats[0].dtype, feats[0].device\n    for i, stride in enumerate(strides):\n        _, _, h, w = feats[i].shape\n        sx = torch.arange(end=w, device=device, dtype=dtype) + grid_cell_offset  # shift x\n        sy = torch.arange(end=h, device=device, dtype=dtype) + grid_cell_offset  # shift y\n        sy, sx = torch.meshgrid(sy, sx, indexing=\"ij\") if TORCH_1_10 else torch.meshgrid(sy, sx)",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2bbox",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "def dist2bbox(distance, anchor_points, xywh=True, dim=-1):\n    \"\"\"Transform distance(ltrb) to box(xywh or xyxy).\"\"\"\n    assert(distance.shape[dim] == 4)\n    lt, rb = distance.split([2, 2], dim)\n    x1y1 = anchor_points - lt\n    x2y2 = anchor_points + rb\n    if xywh:\n        c_xy = (x1y1 + x2y2) / 2\n        wh = x2y2 - x1y1\n        return torch.cat((c_xy, wh), dim)  # xywh bbox",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "bbox2dist",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "def bbox2dist(anchor_points, bbox, reg_max):\n    \"\"\"Transform bbox(xyxy) to dist(ltrb).\"\"\"\n    x1y1, x2y2 = bbox.chunk(2, -1)\n    return torch.cat((anchor_points - x1y1, x2y2 - anchor_points), -1).clamp_(0, reg_max - 0.01)  # dist (lt, rb)\ndef dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n    Args:\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "dist2rbox",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "def dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n    Args:\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).\n        anchor_points (torch.Tensor): Anchor points, (h*w, 2).\n    Returns:\n        (torch.Tensor): Predicted rotated bounding boxes, (bs, h*w, 4).\n    \"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "TORCH_1_10",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.tal",
        "description": "Identification.yolov10.ultralytics.utils.tal",
        "peekOfCode": "TORCH_1_10 = check_version(torch.__version__, \"1.10.0\")\nclass TaskAlignedAssigner(nn.Module):\n    \"\"\"\n    A task-aligned assigner for object detection.\n    This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both\n    classification and localization information.\n    Attributes:\n        topk (int): The number of top candidates to consider.\n        num_classes (int): The number of object classes.\n        alpha (float): The alpha parameter for the classification component of the task-aligned metric.",
        "detail": "Identification.yolov10.ultralytics.utils.tal",
        "documentation": {}
    },
    {
        "label": "ModelEMA",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "class ModelEMA:\n    \"\"\"Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models\n    Keeps a moving average of everything in the model state_dict (parameters and buffers)\n    For EMA details see https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage\n    To disable EMA set the `enabled` attribute to `False`.\n    \"\"\"\n    def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n        \"\"\"Create EMA.\"\"\"\n        self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n        self.updates = updates  # number of EMA updates",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "EarlyStopping",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "class EarlyStopping:\n    \"\"\"Early stopping class that stops training when a specified number of epochs have passed without improvement.\"\"\"\n    def __init__(self, patience=50):\n        \"\"\"\n        Initialize early stopping object.\n        Args:\n            patience (int, optional): Number of epochs to wait after fitness stops improving before stopping.\n        \"\"\"\n        self.best_fitness = 0.0  # i.e. mAP\n        self.best_epoch = 0",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "torch_distributed_zero_first",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:\n        dist.barrier(device_ids=[0])\ndef smart_inference_mode():\n    \"\"\"Applies torch.inference_mode() decorator if torch>=1.9.0 else torch.no_grad() decorator.\"\"\"",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "smart_inference_mode",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def smart_inference_mode():\n    \"\"\"Applies torch.inference_mode() decorator if torch>=1.9.0 else torch.no_grad() decorator.\"\"\"\n    def decorate(fn):\n        \"\"\"Applies appropriate torch decorator for inference mode based on torch version.\"\"\"\n        if TORCH_1_9 and torch.is_inference_mode_enabled():\n            return fn  # already in inference_mode, act as a pass-through\n        else:\n            return (torch.inference_mode if TORCH_1_9 else torch.no_grad)()(fn)\n    return decorate\ndef get_cpu_info():",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_cpu_info",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_cpu_info():\n    \"\"\"Return a string with system CPU information, i.e. 'Apple M2'.\"\"\"\n    import cpuinfo  # pip install py-cpuinfo\n    k = \"brand_raw\", \"hardware_raw\", \"arch_string_raw\"  # info keys sorted by preference (not all keys always available)\n    info = cpuinfo.get_cpu_info()  # info dict\n    string = info.get(k[0] if k[0] in info else k[1] if k[1] in info else k[2], \"unknown\")\n    return string.replace(\"(R)\", \"\").replace(\"CPU \", \"\").replace(\"@ \", \"\")\ndef select_device(device=\"\", batch=0, newline=False, verbose=True):\n    \"\"\"\n    Selects the appropriate PyTorch device based on the provided arguments.",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "select_device",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def select_device(device=\"\", batch=0, newline=False, verbose=True):\n    \"\"\"\n    Selects the appropriate PyTorch device based on the provided arguments.\n    The function takes a string specifying the device or a torch.device object and returns a torch.device object\n    representing the selected device. The function also validates the number of available devices and raises an\n    exception if the requested device(s) are not available.\n    Args:\n        device (str | torch.device, optional): Device string or torch.device object.\n            Options are 'None', 'cpu', or 'cuda', or '0' or '0,1,2,3'. Defaults to an empty string, which auto-selects\n            the first available GPU, or CPU if no GPU is available.",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "time_sync",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def time_sync():\n    \"\"\"PyTorch-accurate time.\"\"\"\n    if torch.cuda.is_available():\n        torch.cuda.synchronize()\n    return time.time()\ndef fuse_conv_and_bn(conv, bn):\n    \"\"\"Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_conv_and_bn",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def fuse_conv_and_bn(conv, bn):\n    \"\"\"Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,\n            conv.out_channels,\n            kernel_size=conv.kernel_size,\n            stride=conv.stride,\n            padding=conv.padding,\n            dilation=conv.dilation,",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "fuse_deconv_and_bn",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def fuse_deconv_and_bn(deconv, bn):\n    \"\"\"Fuse ConvTranspose2d() and BatchNorm2d() layers.\"\"\"\n    fuseddconv = (\n        nn.ConvTranspose2d(\n            deconv.in_channels,\n            deconv.out_channels,\n            kernel_size=deconv.kernel_size,\n            stride=deconv.stride,\n            padding=deconv.padding,\n            output_padding=deconv.output_padding,",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def model_info(model, detailed=False, verbose=True, imgsz=640):\n    \"\"\"\n    Model information.\n    imgsz may be int or list, i.e. imgsz=640 or imgsz=[640, 320].\n    \"\"\"\n    if not verbose:\n        return\n    n_p = get_num_params(model)  # number of parameters\n    n_g = get_num_gradients(model)  # number of gradients\n    n_l = len(list(model.modules()))  # number of layers",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_num_params",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_num_params(model):\n    \"\"\"Return the total number of parameters in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters())\ndef get_num_gradients(model):\n    \"\"\"Return the total number of parameters with gradients in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters() if x.requires_grad)\ndef model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_num_gradients",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_num_gradients(model):\n    \"\"\"Return the total number of parameters with gradients in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters() if x.requires_grad)\ndef model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:\n        YOLOv8n info for loggers\n        ```python\n        results = {'model/parameters': 3151904,",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "model_info_for_loggers",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n    Example:\n        YOLOv8n info for loggers\n        ```python\n        results = {'model/parameters': 3151904,\n                   'model/GFLOPs': 8.746,\n                   'model/speed_ONNX(ms)': 41.244,\n                   'model/speed_TensorRT(ms)': 3.211,",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_flops",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_flops(model, imgsz=640):\n    \"\"\"Return a YOLO model's FLOPs.\"\"\"\n    if not thop:\n        return 0.0  # if not installed return 0.0 GFLOPs\n    try:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        if not isinstance(imgsz, list):\n            imgsz = [imgsz, imgsz]  # expand if int/float\n        try:",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_flops_with_torch_profiler",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_flops_with_torch_profiler(model, imgsz=640):\n    \"\"\"Compute model FLOPs (thop alternative).\"\"\"\n    if TORCH_2_0:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        stride = (max(int(model.stride.max()), 32) if hasattr(model, \"stride\") else 32) * 2  # max stride\n        im = torch.zeros((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n        with torch.profiler.profile(with_flops=True) as prof:\n            model(im)\n        flops = sum(x.flops for x in prof.key_averages()) / 1e9",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "initialize_weights",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def initialize_weights(model):\n    \"\"\"Initialize model weights to random values.\"\"\"\n    for m in model.modules():\n        t = type(m)\n        if t is nn.Conv2d:\n            pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n        elif t is nn.BatchNorm2d:\n            m.eps = 1e-3\n            m.momentum = 0.03\n        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "scale_img",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def scale_img(img, ratio=1.0, same_shape=False, gs=32):\n    \"\"\"Scales and pads an image tensor of shape img(bs,3,y,x) based on given ratio and grid size gs, optionally\n    retaining the original shape.\n    \"\"\"\n    if ratio == 1.0:\n        return img\n    h, w = img.shape[2:]\n    s = (int(h * ratio), int(w * ratio))  # new size\n    img = F.interpolate(img, size=s, mode=\"bilinear\", align_corners=False)  # resize\n    if not same_shape:  # pad/crop img",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "make_divisible",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def make_divisible(x, divisor):\n    \"\"\"Returns nearest x divisible by divisor.\"\"\"\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor\ndef copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "copy_attr",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue\n        else:\n            setattr(a, k, v)\ndef get_latest_opset():\n    \"\"\"Return second-most (for maturity) recently supported ONNX opset by this version of torch.\"\"\"\n    return max(int(k[14:]) for k in vars(torch.onnx) if \"symbolic_opset\" in k) - 1  # opset",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "get_latest_opset",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def get_latest_opset():\n    \"\"\"Return second-most (for maturity) recently supported ONNX opset by this version of torch.\"\"\"\n    return max(int(k[14:]) for k in vars(torch.onnx) if \"symbolic_opset\" in k) - 1  # opset\ndef intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.\"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\ndef is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "intersect_dicts",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.\"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\ndef is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "is_parallel",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\ndef de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "de_parallel",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\ndef one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "one_cycle",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\ndef init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_seeds",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe\n    # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287\n    if deterministic:\n        if TORCH_2_0:",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "strip_optimizer",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def strip_optimizer(f: Union[str, Path] = \"best.pt\", s: str = \"\") -> None:\n    \"\"\"\n    Strip optimizer from 'f' to finalize training, optionally save as 's'.\n    Args:\n        f (str): file path to model to strip the optimizer from. Default is 'best.pt'.\n        s (str): file path to save the model with stripped optimizer to. If not provided, 'f' will be overwritten.\n    Returns:\n        None\n    Example:\n        ```python",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "profile",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "def profile(input, ops, n=10, device=None):\n    \"\"\"\n    Ultralytics speed, memory and FLOPs profiler.\n    Example:\n        ```python\n        from ultralytics.utils.torch_utils import profile\n        input = torch.randn(16, 3, 640, 640)\n        m1 = lambda x: x * torch.sigmoid(x)\n        m2 = nn.SiLU()\n        profile(input, [m1, m2], n=100)  # profile over 100 iterations",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_9",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_1_9 = check_version(torch.__version__, \"1.9.0\")\nTORCH_1_13 = check_version(torch.__version__, \"1.13.0\")\nTORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_1_13",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_1_13 = check_version(torch.__version__, \"1.13.0\")\nTORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCH_2_0",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCH_2_0 = check_version(torch.__version__, \"2.0.0\")\nTORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_10",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_10 = check_version(torchvision.__version__, \"0.10.0\")\nTORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_11",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_11 = check_version(torchvision.__version__, \"0.11.0\")\nTORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TORCHVISION_0_13",
        "kind": 5,
        "importPath": "Identification.yolov10.ultralytics.utils.torch_utils",
        "description": "Identification.yolov10.ultralytics.utils.torch_utils",
        "peekOfCode": "TORCHVISION_0_13 = check_version(torchvision.__version__, \"0.13.0\")\n@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:\n        dist.barrier(device_ids=[0])",
        "detail": "Identification.yolov10.ultralytics.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "TritonRemoteModel",
        "kind": 6,
        "importPath": "Identification.yolov10.ultralytics.utils.triton",
        "description": "Identification.yolov10.ultralytics.utils.triton",
        "peekOfCode": "class TritonRemoteModel:\n    \"\"\"\n    Client for interacting with a remote Triton Inference Server model.\n    Attributes:\n        endpoint (str): The name of the model on the Triton server.\n        url (str): The URL of the Triton server.\n        triton_client: The Triton client (either HTTP or gRPC).\n        InferInput: The input class for the Triton client.\n        InferRequestedOutput: The output request class for the Triton client.\n        input_formats (List[str]): The data types of the model inputs.",
        "detail": "Identification.yolov10.ultralytics.utils.triton",
        "documentation": {}
    },
    {
        "label": "run_ray_tune",
        "kind": 2,
        "importPath": "Identification.yolov10.ultralytics.utils.tuner",
        "description": "Identification.yolov10.ultralytics.utils.tuner",
        "peekOfCode": "def run_ray_tune(\n    model, space: dict = None, grace_period: int = 10, gpu_per_trial: int = None, max_samples: int = 10, **train_args\n):\n    \"\"\"\n    Runs hyperparameter tuning using Ray Tune.\n    Args:\n        model (YOLO): Model to run the tuner on.\n        space (dict, optional): The hyperparameter search space. Defaults to None.\n        grace_period (int, optional): The grace period in epochs of the ASHA scheduler. Defaults to 10.\n        gpu_per_trial (int, optional): The number of GPUs to allocate per trial. Defaults to None.",
        "detail": "Identification.yolov10.ultralytics.utils.tuner",
        "documentation": {}
    },
    {
        "label": "yolov10_inference",
        "kind": 2,
        "importPath": "Identification.yolov10.app",
        "description": "Identification.yolov10.app",
        "peekOfCode": "def yolov10_inference(image, video, model_id, image_size, conf_threshold):\n    model = YOLOv10.from_pretrained(f'jameslahm/{model_id}')\n    if image:\n        results = model.predict(source=image, imgsz=image_size, conf=conf_threshold)\n        annotated_image = results[0].plot()\n        return annotated_image[:, :, ::-1], None\n    else:\n        video_path = tempfile.mktemp(suffix=\".webm\")\n        with open(video_path, \"wb\") as f:\n            with open(video, \"rb\") as g:",
        "detail": "Identification.yolov10.app",
        "documentation": {}
    },
    {
        "label": "yolov10_inference_for_examples",
        "kind": 2,
        "importPath": "Identification.yolov10.app",
        "description": "Identification.yolov10.app",
        "peekOfCode": "def yolov10_inference_for_examples(image, model_path, image_size, conf_threshold):\n    annotated_image, _ = yolov10_inference(image, None, model_path, image_size, conf_threshold)\n    return annotated_image\ndef app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                image = gr.Image(type=\"pil\", label=\"Image\", visible=True)\n                video = gr.Video(label=\"Video\", visible=False)\n                input_type = gr.Radio(",
        "detail": "Identification.yolov10.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": "Identification.yolov10.app",
        "description": "Identification.yolov10.app",
        "peekOfCode": "def app():\n    with gr.Blocks():\n        with gr.Row():\n            with gr.Column():\n                image = gr.Image(type=\"pil\", label=\"Image\", visible=True)\n                video = gr.Video(label=\"Video\", visible=False)\n                input_type = gr.Radio(\n                    choices=[\"Image\", \"Video\"],\n                    value=\"Image\",\n                    label=\"Input Type\",",
        "detail": "Identification.yolov10.app",
        "documentation": {}
    },
    {
        "label": "gradio_app",
        "kind": 5,
        "importPath": "Identification.yolov10.app",
        "description": "Identification.yolov10.app",
        "peekOfCode": "gradio_app = gr.Blocks()\nwith gradio_app:\n    gr.HTML(\n        \"\"\"\n    <h1 style='text-align: center'>\n    YOLOv10: Real-Time End-to-End Object Detection\n    </h1>\n    \"\"\")\n    gr.HTML(\n        \"\"\"",
        "detail": "Identification.yolov10.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.yolov10.flops",
        "description": "Identification.yolov10.flops",
        "peekOfCode": "model = YOLOv10('yolov10n.yaml')\nmodel.model.model[-1].export = True\nmodel.model.model[-1].format = 'onnx'\ndel model.model.model[-1].cv2\ndel model.model.model[-1].cv3\nmodel.fuse()",
        "detail": "Identification.yolov10.flops",
        "documentation": {}
    },
    {
        "label": "model.model.model[-1].export",
        "kind": 5,
        "importPath": "Identification.yolov10.flops",
        "description": "Identification.yolov10.flops",
        "peekOfCode": "model.model.model[-1].export = True\nmodel.model.model[-1].format = 'onnx'\ndel model.model.model[-1].cv2\ndel model.model.model[-1].cv3\nmodel.fuse()",
        "detail": "Identification.yolov10.flops",
        "documentation": {}
    },
    {
        "label": "model.model.model[-1].format",
        "kind": 5,
        "importPath": "Identification.yolov10.flops",
        "description": "Identification.yolov10.flops",
        "peekOfCode": "model.model.model[-1].format = 'onnx'\ndel model.model.model[-1].cv2\ndel model.model.model[-1].cv3\nmodel.fuse()",
        "detail": "Identification.yolov10.flops",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Identification.real_time_yolo_demo",
        "description": "Identification.real_time_yolo_demo",
        "peekOfCode": "model = YOLO(\"yolov10n.pt\")\n# capture video\ncap = cv2.VideoCapture(0)\n# Loop through the video frames\nwhile cap.isOpened():\n    # Read a frame from the video\n    success, frame = cap.read()\n    if success:\n        # Run YOLO inference on the frame\n        results = model(frame)",
        "detail": "Identification.real_time_yolo_demo",
        "documentation": {}
    },
    {
        "label": "cap",
        "kind": 5,
        "importPath": "Identification.real_time_yolo_demo",
        "description": "Identification.real_time_yolo_demo",
        "peekOfCode": "cap = cv2.VideoCapture(0)\n# Loop through the video frames\nwhile cap.isOpened():\n    # Read a frame from the video\n    success, frame = cap.read()\n    if success:\n        # Run YOLO inference on the frame\n        results = model(frame)\n        # Visualize the results on the frame\n        annotated_frame = results[0].plot()",
        "detail": "Identification.real_time_yolo_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Identification.train",
        "description": "Identification.train",
        "peekOfCode": "def main():\n    config_path = r'datasets/config.yaml'\n    # Load a model\n    model = YOLO(\"yolov10n.pt\")\n    # Use the model with a reduced batch size\n    model.train(data=config_path, epochs=100, batch=16, amp=False)\nif __name__ == '__main__':\n    main()",
        "detail": "Identification.train",
        "documentation": {}
    }
]